<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>__vic's C++ library (POSIX)</title>
<style type="text/css">
body {
	font-family: verdana, sans-serif;
	font-size: 10pt;
	background-color: #777777;
	margin: 0;
}
div.page-wrap {
	background-color: white;
	width: 210mm; /* A4 */
	margin: 0 auto;
	padding: 2mm 5mm;
}
p, div {
	margin-top: 6pt;
	margin-bottom: 0;
}
h1, h2, h3, h4, h5, h6 {
	font-weight: bold;
	margin-top: 9pt;
	margin-bottom: 12pt;
	margin-left: 0;
}
h1 { font-size: 16pt; }
h2 { font-size: 13pt; }
h3 { font-size: 11pt; }
h4 { font-size: 11pt; }
span.h1_num, span.h2_num {
	margin-right: 2em;
	font-family: sans-serif;
}
span.h3_num, span.h4_num {
	margin-right: 2em;
	font-weight: normal;
	font-size: smaller;
}
h1.main-title {
	font-size: 2em;
	font-weight: bold;
}
caption.toc {
	text-align: left;
	font-weight: bold;
	font-size: 13pt;
	margin-top: 9pt;
	margin-bottom: 12pt;
	margin-left: 0;
}
td.toc-chapter-no {
	padding-right: 1ex;
	vertical-align: top;
}
a { text-decoration: none; }
a:hover { text-decoration: underline; }
pre.code {
	background-color: #EEE;
	border: 1px solid #CCCCCC;
	padding-top: 6pt;
	padding-bottom: 6pt;
	padding-left: 2pt;
	font-family: monospace;
	font-size: 10pt;
	width: 17.3cm; /* 80ch */
}
pre.prototype {
	font-family: monospace;
	margin-top: 0;
	margin-bottom: 0;
}
div.section {
	font-weight: bold;
}
div.todo {
	color: red;
	font-weight: bold;
}
span.ver {
	font-size: smaller;
	color: #C0C0C0;
}
span.nonterminal {
	font-family: monospace;
	font-style: italic;
}
span.sign {
	color: #C0C0C0;
	font-family: monospace;
	font-size: 9pt;
	font-weight: bold;
}
blockquote {
	margin-top: 6pt;
	margin-bottom: 0;
	margin-right: 0;
}
blockquote * {
	margin-top: 0;
	margin-bottom: 0;
}
</style>
</head>
<body><div class="page-wrap">
<h1 class="main-title">__vic's C++ library (POSIX)<span class="ver"> v1.0 [Draft]</span>
</h1>
<table style="font-size:10pt;" cellspacing="0" cellpadding="0">
<caption class="toc">Contents</caption>
<tr>
<td class="toc-chapter-no">1</td>
<td><a href="#intro">Introduction</a></td>
</tr>
<tr>
<td class="toc-chapter-no">1.1</td>
<td><a href="#why">Why this library was created?</a></td>
</tr>
<tr>
<td class="toc-chapter-no">1.2</td>
<td><a href="#general-structure">General structure and usage</a></td>
</tr>
<tr><td colspan="2" style="font-size:5pt;">Â </td></tr>
<tr>
<td class="toc-chapter-no">2</td>
<td><a href="#components-reference">Library components reference</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1</td>
<td><a href="#defs.h"><tt>__vic/defs.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1.1</td>
<td style="padding-left:4ex"><a href="#nullptr"><tt>nullptr</tt> <span class="sign">[C++98 only]</span></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1.2</td>
<td style="padding-left:4ex"><a href="#noexcept"><tt>noexcept</tt> <span class="sign">[C++98 only]</span></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1.3</td>
<td style="padding-left:4ex"><a href="#array_size"><tt>array_size()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1.4</td>
<td style="padding-left:4ex"><a href="#non_copyable"><tt>non_copyable</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1.5</td>
<td style="padding-left:4ex"><a href="#non_heap_allocatable"><tt>non_heap_allocatable</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1.6</td>
<td style="padding-left:4ex"><a href="#std--move"><tt>std::move()</tt>, <tt>std::forward()</tt>, <tt>std::swap()</tt>
<span class="sign">[C++11]</span></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1.7</td>
<td style="padding-left:4ex"><a href="#VIC_SWAP_HEADER"><tt>__VIC_SWAP_HEADER</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1.8</td>
<td style="padding-left:4ex"><a href="#platform-dependent-macros">Platform-dependent macros</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.2</td>
<td><a href="#algorithm.h"><tt>__vic/algorithm.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.2.1</td>
<td style="padding-left:4ex"><a href="#skip_if_front"><tt>skip_if_front()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.2.2</td>
<td style="padding-left:4ex"><a href="#skip_if_back"><tt>skip_if_back()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.3</td>
<td><a href="#ascii.h"><tt>__vic/ascii.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.3.1</td>
<td style="padding-left:4ex"><a href="#ascii--is-functions"><tt>ascii::is</tt>-functions</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.3.2</td>
<td style="padding-left:4ex"><a href="#ascii--todigit"><tt>ascii::todigit()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.3.3</td>
<td style="padding-left:4ex"><a href="#ascii--toxdigit"><tt>ascii::toxdigit_upper()</tt>, <tt>ascii::toxdigit_lower()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.3.4</td>
<td style="padding-left:4ex"><a href="#ascii--digit_to_number"><tt>ascii::digit_to_number()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.3.5</td>
<td style="padding-left:4ex"><a href="#ascii--xdigit_to_number"><tt>ascii::xdigit_to_number()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.3.6</td>
<td style="padding-left:4ex"><a href="#ascii--tolower-char"><tt>ascii::tolower(char)</tt>, <tt>ascii::toupper(char)</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.3.7</td>
<td style="padding-left:4ex"><a href="#ascii--equal_icase-char"><tt>ascii::equal_icase(char,char)</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.4</td>
<td><a href="#ascii_string.h"><tt>__vic/ascii_string.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.4.1</td>
<td style="padding-left:4ex"><a href="#ascii--tolower-str"><tt>ascii::tolower()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.4.2</td>
<td style="padding-left:4ex"><a href="#ascii--toupper-str"><tt>ascii::toupper()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.4.3</td>
<td style="padding-left:4ex"><a href="#ascii--equal_icase-str"><tt>ascii::equal_icase()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5</td>
<td><a href="#base16.h"><tt>__vic/base16.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.1</td>
<td style="padding-left:4ex"><a href="#base16"><tt>base16</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.2</td>
<td style="padding-left:4ex"><a href="#base16--bad_format"><tt>base16::bad_format</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.3</td>
<td style="padding-left:4ex"><a href="#base16--bad_digit"><tt>base16::bad_digit</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.4</td>
<td style="padding-left:4ex"><a href="#base16--bad_length"><tt>base16::bad_length</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.5</td>
<td style="padding-left:4ex"><a href="#base16--status"><tt>base16::status</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.6</td>
<td style="padding-left:4ex"><a href="#base16--encode_upper"><tt>base16::encode_upper()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.7</td>
<td style="padding-left:4ex"><a href="#base16--encode_lower"><tt>base16::encode_lower()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.8</td>
<td style="padding-left:4ex"><a href="#base16--encode_byte_lower"><tt>base16::encode_byte_lower()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.9</td>
<td style="padding-left:4ex"><a href="#base16--encode_byte_upper"><tt>base16::encode_byte_upper()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.10</td>
<td style="padding-left:4ex"><a href="#base16--decode"><tt>base16::decode()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.11</td>
<td style="padding-left:4ex"><a href="#base16--try_decode"><tt>base16::try_decode()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6</td>
<td><a href="#base64.h"><tt>__vic/base64.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.1</td>
<td style="padding-left:4ex"><a href="#base64"><tt>base64</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.2</td>
<td style="padding-left:4ex"><a href="#base64--bad_format"><tt>base64::bad_format</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.3</td>
<td style="padding-left:4ex"><a href="#base64--bad_digit"><tt>base64::bad_digit</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.4</td>
<td style="padding-left:4ex"><a href="#base64--bad_length"><tt>base64::bad_length</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.5</td>
<td style="padding-left:4ex"><a href="#base64--status"><tt>base64::status</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.6</td>
<td style="padding-left:4ex"><a href="#base64--encode"><tt>base64::encode()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.7</td>
<td style="padding-left:4ex"><a href="#base64--decode"><tt>base64::decode()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.8</td>
<td style="padding-left:4ex"><a href="#base64--try_decode"><tt>base64::try_decode()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.9</td>
<td style="padding-left:4ex"><a href="#base64--encoded_length"><tt>base64::encoded_length()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.10</td>
<td style="padding-left:4ex"><a href="#base64--max_decoded_length"><tt>base64::max_decoded_length()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.7</td>
<td><a href="#bin_file.h"><tt>__vic/bin_file.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.7.1</td>
<td style="padding-left:4ex"><a href="#bin_file"><tt>bin_file</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8</td>
<td><a href="#bits.h"><tt>__vic/bits.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.1</td>
<td style="padding-left:4ex"><a href="#lo_nibble"><tt>lo_nibble()</tt>, <tt>hi_nibble()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.2</td>
<td style="padding-left:4ex"><a href="#msb_ones"><tt>msb_ones()</tt>, <tt>lsb_ones()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.3</td>
<td style="padding-left:4ex"><a href="#get_lsbs"><tt>get_lsbs()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.4</td>
<td style="padding-left:4ex"><a href="#ord"><tt>ord()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.5</td>
<td style="padding-left:4ex"><a href="#popcount"><tt>popcount()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.6</td>
<td style="padding-left:4ex"><a href="#msb_position"><tt>msb_position()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.7</td>
<td style="padding-left:4ex"><a href="#ispow2"><tt>ispow2()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.8</td>
<td style="padding-left:4ex"><a href="#ceil2"><tt>ceil2()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.9</td>
<td style="padding-left:4ex"><a href="#floor2"><tt>floor2()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.10</td>
<td style="padding-left:4ex"><a href="#ceil_log2"><tt>ceil_log2()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.11</td>
<td style="padding-left:4ex"><a href="#floor_log2"><tt>floor_log2()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.12</td>
<td style="padding-left:4ex"><a href="#rotl"><tt>rotl()</tt>, <tt>rotr()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.13</td>
<td style="padding-left:4ex"><a href="#swapped_nibbles"><tt>swapped_nibbles()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.9</td>
<td><a href="#date_time.h"><tt>__vic/date_time.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.9.1</td>
<td style="padding-left:4ex"><a href="#is_leap_year"><tt>is_leap_year()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.9.2</td>
<td style="padding-left:4ex"><a href="#days_in_month"><tt>days_in_month()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.9.3</td>
<td style="padding-left:4ex"><a href="#days_between_years"><tt>days_between_years()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.9.4</td>
<td style="padding-left:4ex"><a href="#invalid_date"><tt>invalid_date</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.9.5</td>
<td style="padding-left:4ex"><a href="#validate_date_time"><tt>validate_date()</tt>, <tt>validate_time()</tt>,
<tt>validate_date_time()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.10</td>
<td><a href="#endian.h"><tt>__vic/endian.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.10.1</td>
<td style="padding-left:4ex"><a href="#endianness"><tt>endianness</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.10.2</td>
<td style="padding-left:4ex"><a href="#endian--from"><tt>endian::from_...()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.10.3</td>
<td style="padding-left:4ex"><a href="#endian--to"><tt>endian::to_...()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.10.4</td>
<td style="padding-left:4ex"><a href="#swab"><tt>swab16()</tt>, <tt>swab32()</tt>, <tt>swab64()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.11</td>
<td><a href="#error.h"><tt>__vic/error.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.11.1</td>
<td style="padding-left:4ex"><a href="#exception"><tt>exception</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.11.2</td>
<td style="padding-left:4ex"><a href="#libc_error"><tt>libc_error</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.12</td>
<td><a href="#fixed_vector.h"><tt>__vic/fixed_vector.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.12.1</td>
<td style="padding-left:4ex"><a href="#fixed_vector"><tt>fixed_vector</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13</td>
<td><a href="#fs.h"><tt>__vic/fs.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.1</td>
<td style="padding-left:4ex"><a href="#path_exists"><tt>path_exists()</tt>, <tt>file_exists()</tt>, <tt>dir_exists()</tt>
</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.2</td>
<td style="padding-left:4ex"><a href="#mkdir"><tt>mkdir()</tt>, <tt>mkdir_if_absent()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.3</td>
<td style="padding-left:4ex"><a href="#rmdir"><tt>rmdir()</tt>, <tt>rmdir_if_exists()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.4</td>
<td style="padding-left:4ex"><a href="#get_current_dir"><tt>get_current_dir()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.5</td>
<td style="padding-left:4ex"><a href="#remove_file"><tt>remove_file()</tt>, <tt>remove_file_if_exists()</tt>,
<tt>remove_file_nt()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.6</td>
<td style="padding-left:4ex"><a href="#copy_file"><tt>copy_file()</tt>, <tt>copy_file_if_exists()</tt>,
<tt>copy_file_replace()</tt>, <tt>copy_file_replace_if_exists()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.7</td>
<td style="padding-left:4ex"><a href="#move_file"><tt>move_file()</tt>, <tt>move_file_if_exists()</tt>,
<tt>move_file_replace()</tt>, <tt>move_file_replace_if_exists()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.8</td>
<td style="padding-left:4ex"><a href="#rename_file"><tt>rename_file()</tt>, <tt>rename_file_if_exists()</tt>,
    <tt>rename_file_replace()</tt>, <tt>rename_file_replace_if_exists()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.9</td>
<td style="padding-left:4ex"><a href="#file_size"><tt>file_size()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.14</td>
<td><a href="#iterator.h"><tt>__vic/iterator.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.14.1</td>
<td style="padding-left:4ex"><a href="#begin-array"><tt>begin(T[])</tt>, <tt>end(T[])</tt>, <tt>cbegin(T[])</tt>,
<tt>cend(T[])</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.14.2</td>
<td style="padding-left:4ex"><a href="#advance"><tt>advance()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.14.3</td>
<td style="padding-left:4ex"><a href="#next"><tt>next()</tt>, <tt>prev()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.15</td>
<td><a href="#logger.h"><tt>__vic/logger.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.15.1</td>
<td style="padding-left:4ex"><a href="#logger"><tt>logger</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.16</td>
<td><a href="#memory.h"><tt>__vic/memory.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.16.1</td>
<td style="padding-left:4ex"><a href="#load_unaligned"><tt>load_unaligned()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.16.2</td>
<td style="padding-left:4ex"><a href="#store_unaligned"><tt>store_unaligned()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.17</td>
<td><a href="#mutex.h"><tt>__vic/mutex.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.17.1</td>
<td style="padding-left:4ex"><a href="#mutex"><tt>mutex</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.17.2</td>
<td style="padding-left:4ex"><a href="#mutex_lock"><tt>mutex_lock</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.18</td>
<td><a href="#packon.h"><tt>__vic/packon.h</tt> &amp; <tt>__vic/packoff.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.19</td>
<td><a href="#readers"><tt>__vic/readers/</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.19.1</td>
<td style="padding-left:4ex"><a href="#reader-concept"><tt>Reader</tt> concept</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.19.2</td>
<td style="padding-left:4ex"><a href="#iterator_reader"><tt>iterator_reader</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.19.3</td>
<td style="padding-left:4ex"><a href="#iterator_reader_n"><tt>iterator_reader_n</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.19.4</td>
<td style="padding-left:4ex"><a href="#container_reader"><tt>container_reader</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.19.5</td>
<td style="padding-left:4ex"><a href="#cstring_reader"><tt>cstring_reader</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.19.6</td>
<td style="padding-left:4ex"><a href="#string_reader"><tt>string_reader</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.19.7</td>
<td style="padding-left:4ex"><a href="#cstream_reader"><tt>cstream_reader</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.20</td>
<td><a href="#readonly_cstring.h"><tt>__vic/readonly_cstring.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.20.1</td>
<td style="padding-left:4ex"><a href="#readonly_cstring"><tt>readonly_cstring</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.21</td>
<td><a href="#set_of_chars.h"><tt>__vic/set_of_chars.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.21.1</td>
<td style="padding-left:4ex"><a href="#set_of_chars"><tt>set_of_chars</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.22</td>
<td><a href="#stdint.h"><tt>__vic/stdint.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.22.1</td>
<td style="padding-left:4ex"><a href="#intN_t">Exact-width integer types</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.22.2</td>
<td style="padding-left:4ex"><a href="#int_leastN_t">Minimum-width integer types</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.22.3</td>
<td style="padding-left:4ex"><a href="#int_fastN_t">Fastest minimum-width integer types</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.22.4</td>
<td style="padding-left:4ex"><a href="#intmax_t">Greatest-width integer types</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.22.5</td>
<td style="padding-left:4ex"><a href="#intptr_t">Integer types capable of holding object pointers</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.22.6</td>
<td style="padding-left:4ex"><a href="#int_exactly_bytes"><tt>int_exactly_bytes&lt;&gt;</tt>, <tt>uint_exactly_bytes&lt;&gt;</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.23</td>
<td><a href="#stdio_file.h"><tt>__vic/stdio_file.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.23.1</td>
<td style="padding-left:4ex"><a href="#stdio_file"><tt>stdio_file</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.23.2</td>
<td style="padding-left:4ex"><a href="#read-FILE-char"><tt>read(std::FILE, char&amp;)</tt>,
    <tt>read(std::FILE, unsigned char&amp;)</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.23.3</td>
<td style="padding-left:4ex"><a href="#write-FILE-char"><tt>write(std::FILE, char)</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.23.4</td>
<td style="padding-left:4ex"><a href="#getline-FILE"><tt>getline(std::FILE)</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.24</td>
<td><a href="#str2num.h"><tt>__vic/str2num.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.24.1</td>
<td style="padding-left:4ex"><a href="#decimal_to_number"><tt>decimal_to_number()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.24.2</td>
<td style="padding-left:4ex"><a href="#decimal_to_number_range"><tt>decimal_to_number_range()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.24.3</td>
<td style="padding-left:4ex"><a href="#decimal_parser"><tt>decimal_parser</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.24.4</td>
<td style="padding-left:4ex"><a href="#number_parse_status"><tt>number_parse_status</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.25</td>
<td><a href="#string_buffer.h"><tt>__vic/string_buffer.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.25.1</td>
<td style="padding-left:4ex"><a href="#string_buffer"><tt>string_buffer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.26</td>
<td><a href="#string_ref.h"><tt>__vic/string_ref.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.26.1</td>
<td style="padding-left:4ex"><a href="#string_ref"><tt>string_ref</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.27</td>
<td><a href="#string_utils.h"><tt>__vic/string_utils.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.27.1</td>
<td style="padding-left:4ex"><a href="#trim"><tt>trim</tt> functions</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.27.2</td>
<td style="padding-left:4ex"><a href="#sift"><tt>sift()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.27.3</td>
<td style="padding-left:4ex"><a href="#sift_if"><tt>sift_if()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.27.4</td>
<td style="padding-left:4ex"><a href="#pad_front"><tt>pad_front()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.27.5</td>
<td style="padding-left:4ex"><a href="#pad_back"><tt>pad_back()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.27.6</td>
<td style="padding-left:4ex"><a href="#starts_with"><tt>starts_with()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.27.7</td>
<td style="padding-left:4ex"><a href="#ends_with"><tt>ends_with()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28</td>
<td><a href="#tchar.h"><tt>__vic/tchar.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.1</td>
<td style="padding-left:4ex"><a href="#tchar--length"><tt>tchar::length()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.2</td>
<td style="padding-left:4ex"><a href="#tchar--empty"><tt>tchar::empty()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.3</td>
<td style="padding-left:4ex"><a href="#tchar--end"><tt>tchar::end()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.4</td>
<td style="padding-left:4ex"><a href="#tchar--compare"><tt>tchar::compare()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.5</td>
<td style="padding-left:4ex"><a href="#tchar--equal"><tt>tchar::equal()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.6</td>
<td style="padding-left:4ex"><a href="#tchar--copy"><tt>tchar::copy()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.7</td>
<td style="padding-left:4ex"><a href="#tchar--move"><tt>tchar::move()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.8</td>
<td style="padding-left:4ex"><a href="#tchar--concat"><tt>tchar::concat()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.9</td>
<td style="padding-left:4ex"><a href="#tchar--find"><tt>tchar::find()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.10</td>
<td style="padding-left:4ex"><a href="#tchar--rfind"><tt>tchar::rfind()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.11</td>
<td style="padding-left:4ex"><a href="#tchar--find_if"><tt>tchar::find_if()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.12</td>
<td style="padding-left:4ex"><a href="#tchar--find_if_not"><tt>tchar::find_if_not()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.13</td>
<td style="padding-left:4ex"><a href="#tchar--rfind_if"><tt>tchar::rfind_if()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.14</td>
<td style="padding-left:4ex"><a href="#tchar--rfind_if_not"><tt>tchar::rfind_if_not()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.15</td>
<td style="padding-left:4ex"><a href="#tchar--find_first_of"><tt>tchar::find_first_of()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.16</td>
<td style="padding-left:4ex"><a href="#tchar--find_first_not_of"><tt>tchar::find_first_not_of()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.17</td>
<td style="padding-left:4ex"><a href="#tchar--find_last_of"><tt>tchar::find_last_of()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.18</td>
<td style="padding-left:4ex"><a href="#tchar--find_last_not_of"><tt>tchar::find_last_not_of()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.19</td>
<td style="padding-left:4ex"><a href="#tchar--skip"><tt>tchar::skip()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.29</td>
<td><a href="#thread.h"><tt>__vic/thread.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.29.1</td>
<td style="padding-left:4ex"><a href="#thread"><tt>thread</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.29.2</td>
<td style="padding-left:4ex"><a href="#thread--id"><tt>thread::id</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.29.3</td>
<td style="padding-left:4ex"><a href="#this_thread"><tt>this_thread</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.30</td>
<td><a href="#throw_errno.h"><tt>__vic/throw_errno.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.30.1</td>
<td style="padding-left:4ex"><a href="#throw_errno"><tt>throw_errno()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.31</td>
<td><a href="#to_text.h"><tt>__vic/to_text.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.31.1</td>
<td style="padding-left:4ex"><a href="#to_text_append"><tt>to_text_append()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32</td>
<td><a href="#type_traits.h"><tt>__vic/type_traits.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.1</td>
<td style="padding-left:4ex"><a href="#integral_constant"><tt>integral_constant</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.2</td>
<td style="padding-left:4ex"><a href="#true_type"><tt>true_type</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.3</td>
<td style="padding-left:4ex"><a href="#false_type"><tt>false_type</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.4</td>
<td style="padding-left:4ex"><a href="#is_same"><tt>is_same</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.5</td>
<td style="padding-left:4ex"><a href="#is_const"><tt>is_const</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.6</td>
<td style="padding-left:4ex"><a href="#is_signed_integer"><tt>is_signed_integer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.7</td>
<td style="padding-left:4ex"><a href="#is_unsigned_integer"><tt>is_unsigned_integer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.8</td>
<td style="padding-left:4ex"><a href="#remove_const"><tt>remove_const</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.9</td>
<td style="padding-left:4ex"><a href="#remove_volatile"><tt>remove_volatile</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.10</td>
<td style="padding-left:4ex"><a href="#remove_cv"><tt>remove_cv</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.11</td>
<td style="padding-left:4ex"><a href="#remove_reference"><tt>remove_reference</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.12</td>
<td style="padding-left:4ex"><a href="#remove_cvref"><tt>remove_cvref</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.13</td>
<td style="padding-left:4ex"><a href="#remove_pointer"><tt>remove_pointer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.14</td>
<td style="padding-left:4ex"><a href="#enable_if"><tt>enable_if</tt>, <tt>disable_if</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.15</td>
<td style="padding-left:4ex"><a href="#index_sequence"><tt>index_sequence</tt>, <tt>make_index_sequence</tt> <span class="sign">[C++11]</span></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.33</td>
<td><a href="#unicode.h"><tt>__vic/unicode.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.33.1</td>
<td style="padding-left:4ex"><a href="#unicode_t"><tt>unicode_t</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.33.2</td>
<td style="padding-left:4ex"><a href="#utf_transcode"><tt>utf_transcode()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.33.3</td>
<td style="padding-left:4ex"><a href="#unicode_code_point_constants"><tt>Code point constants</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.34</td>
<td><a href="#utf8.status.h"><tt>__vic/utf8/status.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.34.1</td>
<td style="padding-left:4ex"><a href="#utf8--status"><tt>utf8::status</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.34.2</td>
<td style="padding-left:4ex"><a href="#utf8--is_error"><tt>utf8::is_error()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.34.3</td>
<td style="padding-left:4ex"><a href="#utf8--throw_if_error"><tt>utf8::throw_if_error()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.35</td>
<td><a href="#utf8.exceptions.h"><tt>__vic/utf8/exceptions.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.36</td>
<td><a href="#utf8.reader.h"><tt>__vic/utf8/reader.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.36.1</td>
<td style="padding-left:4ex"><a href="#utf8--reader"><tt>utf8::reader</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.37</td>
<td><a href="#utf8.writer.h"><tt>__vic/utf8/writer.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.37.1</td>
<td style="padding-left:4ex"><a href="#utf8--writer"><tt>utf8::writer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.38</td>
<td><a href="#utf16.defs.h"><tt>__vic/utf16/defs.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.38.1</td>
<td style="padding-left:4ex"><a href="#utf16--code_unit_t"><tt>utf16::code_unit_t</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.39</td>
<td><a href="#utf16.status.h"><tt>__vic/utf16/status.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.39.1</td>
<td style="padding-left:4ex"><a href="#utf16--status"><tt>utf16::status</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.39.2</td>
<td style="padding-left:4ex"><a href="#utf16--is_error"><tt>utf16::is_error()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.39.3</td>
<td style="padding-left:4ex"><a href="#utf16--throw_if_error"><tt>utf16::throw_if_error()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.40</td>
<td><a href="#utf16.exceptions.h"><tt>__vic/utf16/exceptions.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.41</td>
<td><a href="#utf16.reader.h"><tt>__vic/utf16/reader.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.41.1</td>
<td style="padding-left:4ex"><a href="#utf16--reader"><tt>utf16::reader</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.42</td>
<td><a href="#utf16.writer.h"><tt>__vic/utf16/writer.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.42.1</td>
<td style="padding-left:4ex"><a href="#utf16--writer"><tt>utf16::writer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.43</td>
<td><a href="#waitable_event.h"><tt>__vic/waitable_event.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.43.1</td>
<td style="padding-left:4ex"><a href="#waitable_event"><tt>waitable_event</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.44</td>
<td><a href="#writers"><tt>__vic/writers/</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.44.1</td>
<td style="padding-left:4ex"><a href="#writer-concept"><tt>Writer</tt> concept</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.44.2</td>
<td style="padding-left:4ex"><a href="#null_writer"><tt>null_writer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.44.3</td>
<td style="padding-left:4ex"><a href="#push_back_writer"><tt>push_back_writer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.44.4</td>
<td style="padding-left:4ex"><a href="#iterator_writer"><tt>iterator_writer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.44.5</td>
<td style="padding-left:4ex"><a href="#string_writer"><tt>string_writer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.44.6</td>
<td style="padding-left:4ex"><a href="#cstream_writer"><tt>cstream_writer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.45</td>
<td><a href="#posix.cond_variable.h"><tt>__vic/posix/cond_variable.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.45.1</td>
<td style="padding-left:4ex"><a href="#posix--cond_variable"><tt>posix::cond_variable</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.46</td>
<td><a href="#posix.daemon_control.h"><tt>__vic/posix/daemon_control.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.46.1</td>
<td style="padding-left:4ex"><a href="#posix--daemon_control"><tt>posix::daemon_control</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.47</td>
<td><a href="#posix.dir_entries.h"><tt>__vic/posix/dir_entries.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.47.1</td>
<td style="padding-left:4ex"><a href="#posix--dir_entries"><tt>posix::dir_entries</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.48</td>
<td><a href="#posix.dir_files.h"><tt>__vic/posix/dir_files.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.48.1</td>
<td style="padding-left:4ex"><a href="#posix--dir_files"><tt>posix::dir_files</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.49</td>
<td><a href="#posix.error.h"><tt>__vic/posix/error.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.49.1</td>
<td style="padding-left:4ex"><a href="#posix--is_EAGAIN"><tt>posix::is_EAGAIN()</tt>, <tt>posix::is_ENOENT()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.50</td>
<td><a href="#posix.file.h"><tt>__vic/posix/file.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.50.1</td>
<td style="padding-left:4ex"><a href="#posix--file"><tt>posix::file</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.51</td>
<td><a href="#posix.file_stat.h"><tt>__vic/posix/file_stat.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.51.1</td>
<td style="padding-left:4ex"><a href="#posix--file_stat"><tt>posix::file_stat</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.52</td>
<td><a href="#posix.fs.h"><tt>__vic/posix/fs.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.52.1</td>
<td style="padding-left:4ex"><a href="#posix--basename"><tt>posix::basename()</tt>, <tt>posix::dirname()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.52.2</td>
<td style="padding-left:4ex"><a href="#posix--add_trailing_slash"><tt>posix::add_trailing_slash()</tt>,
    <tt>posix::with_trailing_slash()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.53</td>
<td><a href="#posix.iov.h"><tt>__vic/posix/iov.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.53.1</td>
<td style="padding-left:4ex"><a href="#posix--ovectors"><tt>posix::ovectors</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.53.2</td>
<td style="padding-left:4ex"><a href="#posix--total-iovec"><tt>posix::total(iovec[])</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.53.3</td>
<td style="padding-left:4ex"><a href="#posix--cut_prefix-iovec"><tt>posix::cut_prefix(iovec[])</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.53.4</td>
<td style="padding-left:4ex"><a href="#posix--writev_all"><tt>posix::writev_all()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.54</td>
<td><a href="#posix.mutex.h"><tt>__vic/posix/mutex.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.54.1</td>
<td style="padding-left:4ex"><a href="#posix--mutex"><tt>posix::mutex</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.54.2</td>
<td style="padding-left:4ex"><a href="#posix--mutex_lock"><tt>posix::mutex_lock</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.55</td>
<td><a href="#posix.pidfile.h"><tt>__vic/posix/pidfile.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.55.1</td>
<td style="padding-left:4ex"><a href="#posix--pidfile"><tt>posix::pidfile</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.56</td>
<td><a href="#posix.process.h"><tt>__vic/posix/process.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.56.1</td>
<td style="padding-left:4ex"><a href="#posix--daemon"><tt>posix::daemon()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.56.2</td>
<td style="padding-left:4ex"><a href="#posix--ignore_signals"><tt>posix::ignore_signals()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.56.3</td>
<td style="padding-left:4ex"><a href="#posix--process_alive"><tt>posix::process_alive()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.57</td>
<td><a href="#posix.sigset.h"><tt>__vic/posix/sigset.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.57.1</td>
<td style="padding-left:4ex"><a href="#posix--sigset"><tt>posix::sigset</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.58</td>
<td><a href="#posix.thread.h"><tt>__vic/posix/thread.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.58.1</td>
<td style="padding-left:4ex"><a href="#posix--this_thread"><tt>posix::this_thread</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.58.2</td>
<td style="padding-left:4ex"><a href="#posix--this_thread--sigwait"><tt>posix::this_thread::sigwait()</tt>,
       <tt>posix::this_thread::sigwait_at_most()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.58.3</td>
<td style="padding-left:4ex"><a href="#posix--this_thread--sigwaitinfo"><tt>posix::this_thread::sigwaitinfo()</tt>,
       <tt>posix::this_thread::sigwaitinfo_at_most()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.58.4</td>
<td style="padding-left:4ex"><a href="#posix--this_thread--block_signals"><tt>posix::this_thread::block_signals()</tt>,
       <tt>posix::this_thread::unblock_signals()</tt>,
       <tt>posix::this_thread::set_sigmask()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.59</td>
<td><a href="#posix.time.h"><tt>__vic/posix/time.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.59.1</td>
<td style="padding-left:4ex"><a href="#posix--time_spec"><tt>posix::time_spec</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.59.2</td>
<td style="padding-left:4ex"><a href="#posix--nanoseconds_since_epoch"><tt>posix::nanoseconds_since_epoch()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.59.3</td>
<td style="padding-left:4ex"><a href="#posix--realtime_clock"><tt>posix::realtime_clock</tt>, <tt>posix::monotonic_clock</tt></a></td>
</tr>
<tr><td colspan="2" style="font-size:5pt;">Â </td></tr>
<tr>
<td class="toc-chapter-no">3</td>
<td><a href="#build">Build and install</a></td>
</tr>
<tr><td colspan="2" style="font-size:5pt;">Â </td></tr>
</table>




<h1 id="intro">
<span class="h1_num">1</span>Introduction</h1>

<h2 id="why">
<span class="h2_num">1.1</span>Why this library was created?</h2>


<p>This library contains the features I'm missing in the Standard C++
library. It's a kind of my personal
<a href="http://www.boost.org/">Boost</a>.</p>

<p>Additionally, it's an abstraction layer that hides implementation details,
quirks and idiosyncrasies of OS'es, compilers and the standard library
implementations.</p>



<h2 id="general-structure">
<span class="h2_num">1.2</span>General structure and usage</h2>


<p>The topmost structural units of the library are headers and the library file
(or archive) - <tt>lib__vic.a</tt> or <tt>__vic.lib</tt>. Usually the library
file has some suffix like <tt>lib__vic14.a</tt>. All the headers
are located in the <tt>__vic/</tt> subdirectory. One should include them like
this:</p>

<pre class="code">
#include &lt;__vic/<span class="nonterminal">header.h</span>&gt;
</pre>

<p>Where <tt><span class="nonterminal">header.h</span></tt> is a name of the desired header.</p>

<p>Almost all the code is placed within <tt>__vic</tt> namespace, including
other namespaces.</p>

<p>During program linking, the library file must be given to the linker.
Example:</p>

<pre class="code">
$ g++ -std=c++14 prog.cpp -l__vic14
</pre>

<p>The library can be built using one of the ISO C++ standards: C++98, C++11,
C++14, C++17, C++20 or C++23. The standard suffix is used as a suffix for the
library file (archive).</p>

<p>Some features require a specific minimal standard version to be available,
e.g. many of them require at least C++11. These features are marked with
<span class="sign">[C++11]</span> sign that means "C++11 or later".</p>

<p>Some features are available only in particular standard mode and not
available otherwise. Such features are marked with <span class="sign">[C++98 only]</span>
sign.</p>

<p>Detailed description of the library components is provided in the subsequent
chapters. Descriptions are grouped by headers. C++23 language syntax is mainly
used as a more complete and expressive one.</p>





<h1 id="components-reference">
<span class="h1_num">2</span>Library components reference</h1>

<h2 id="defs.h">
<span class="h2_num">2.1</span><tt>__vic/defs.h</tt>
</h2>

<p>Misc. fundamental definitions.</p>


<h3 id="nullptr">
<span class="h3_num">2.1.1</span><tt>nullptr</tt> <span class="sign">[C++98 only]</span>
</h3>


<p>Null pointer literal. Can be used instead of <tt>NULL</tt> or <tt>0</tt>.
In ISO C++ 98 mode defined as</p>

<pre class="code">
const int nullptr = 0;
</pre>

<p>This definition allows to write C++11-style code using C++98 standard.</p>

<p>It is one of the few global definitions inroduced by the library. Definition
can be prevented by definition <tt>__VIC_NO_NULLPTR_DEF</tt> macro before
inclusion.</p>

<div class="section">Example</div>
<pre class="code">
int *p = nullptr;
pthread_create(&amp;tid, nullptr, thread_func, nullptr);
</pre>





<h3 id="noexcept">
<span class="h3_num">2.1.2</span><tt>noexcept</tt> <span class="sign">[C++98 only]</span>
</h3>


<p>A macro in C++98 mode, synonym for <tt>throw()</tt>. In other standard modes
the definition is absent.</p>




<h3 id="array_size">
<span class="h3_num">2.1.3</span><tt>array_size()</tt>
</h3>


<pre class="code">
template&lt;class T, size_t N&gt;
constexpr size_t array_size(T (&amp;array)[N]);
</pre>

<p>Returns number of elements in the array. Can be used as a compile-time
expression.</p>

<div class="section">Example</div>
<pre class="code">
int m[] = { 1, 2, 3, 5, 7 };

size_t n = __vic::array_size(m); // n == 5

int *dup = new int[n];
</pre>





<h3 id="non_copyable">
<span class="h3_num">2.1.4</span><tt>non_copyable</tt>
</h3>


<pre class="code">
class non_copyable
{
    non_copyable(const non_copyable &amp;) = delete;
    non_copyable &amp;operator=(const non_copyable &amp;) = delete;
protected:
    non_copyable() = default;
};
</pre>

<p>Inheriting of this class suppresses generation of copy constructor and
copy assignment. Same as <tt>boost::noncopyable</tt>.</p>

<div class="section">Example</div>
<pre class="code">
class C : private __vic::non_copyable
{
};

C c1;
C c2 = c1; // Error! Non-copyable object
</pre>





<h3 id="non_heap_allocatable">
<span class="h3_num">2.1.5</span><tt>non_heap_allocatable</tt>
</h3>


<pre class="code">
class non_heap_allocatable
{
    void *operator new(std::size_t ) = delete;
    void *operator new(std::size_t , const std::nothrow_t &amp; ) = delete;
    void *operator new[](std::size_t ) = delete;
    void *operator new[](std::size_t , const std::nothrow_t &amp; ) = delete;
protected:
    non_heap_allocatable() = default;
};
</pre>

<p>Inheriting of this class prevents creation of the class object on a free
store using operator <tt>new</tt>.</p>

<div class="section">Example</div>
<pre class="code">
class C : private __vic::non_heap_allocatable
{
};

C c; // Ok. Allocation on stack
C *p = new C; // Error! Attempt to allocate on heap
</pre>





<h3 id="std--move">
<span class="h3_num">2.1.6</span><tt>std::move()</tt>, <tt>std::forward()</tt>, <tt>std::swap()</tt>
<span class="sign">[C++11]</span>
</h3>


<p>The header always includes this utilities in C++11 mode.</p>




<h3 id="VIC_SWAP_HEADER">
<span class="h3_num">2.1.7</span><tt>__VIC_SWAP_HEADER</tt>
</h3>


<p>A macro for <tt>#include</tt>. Expands to the header name that contains
<tt>std::swap()</tt> definition, dependig on the used language standard.</p>

<div class="section">Example</div>
<pre class="code">
#include __VIC_SWAP_HEADER
</pre>





<h3 id="platform-dependent-macros">
<span class="h3_num">2.1.8</span>Platform-dependent macros</h3>


<p>The library provides set of compiler-independent macros that help to
determine the target platform and some platform-specific traits by checking
macro presence using <tt>#ifdef</tt>.</p>

<p>List of hardware platforms (processors):</p>
<ul>
<li>
<tt>__VIC_X86__</tt> - Intel x86 (IA32)</li>
<li>
<tt>__VIC_X64__</tt> - x64 aka AMD 64</li>
<li>
<tt>__VIC_IA64__</tt> - Intel IA64</li>
<li>
<tt>__VIC_POWERPC__</tt> - PowerPC</li>
</ul>

<p>Other macros:</p>
<ul><li>
<tt>__VIC_STRICT_RAM_ALIGNMENT__</tt> - attempt to read unaligned
        data will cause bus error</li></ul>






<h2 id="algorithm.h">
<span class="h2_num">2.2</span><tt>__vic/algorithm.h</tt>
</h2>


<p>Generic algorithms.</p>


<h3 id="skip_if_front">
<span class="h3_num">2.2.1</span><tt>skip_if_front()</tt>
</h3>


<pre class="code">
template&lt;
    std::forward_iterator Iter,
    std::predicate&lt;std::iter_value_t&lt;Iter&gt;&gt; Pred
&gt;
Iter skip_if_front(Iter begin, Iter end, Pred pred);
</pre>

<p>Skips all leading elements that match the given predicate and returns new
begin iterator.</p>




<h3 id="skip_if_back">
<span class="h3_num">2.2.2</span><tt>skip_if_back()</tt>
</h3>


<pre class="code">
template&lt;
    std::bidirectional_iterator Iter,
    std::predicate&lt;std::iter_value_t&lt;Iter&gt;&gt; Pred
&gt;
Iter skip_if_back(Iter begin, Iter end, Pred pred);
</pre>

<p>Skips all trailing elements that match the given predicate and returns new
end iterator.</p>






<h2 id="ascii.h">
<span class="h2_num">2.3</span><tt>__vic/ascii.h</tt>
</h2>


<p>Fast, compact and locale-independent tools for ASCII-characters
processing. All the tools are located within <tt>__vic::ascii</tt>
namespace.</p>


<h3 id="ascii--is-functions">
<span class="h3_num">2.3.1</span><tt>ascii::is</tt>-functions</h3>


<pre class="code">
namespace ascii {

constexpr bool isdigit(char c);
constexpr bool isxdigit(char c);
constexpr bool islower(char c);
constexpr bool isupper(char c);
constexpr bool isalpha(char c);
constexpr bool isalnum(char c);
constexpr bool isspace(char c);
constexpr bool isblank(char c);
constexpr bool isprint(char c);
constexpr bool isgraph(char c);
constexpr bool ispunct(char c);
constexpr bool iscntrl(char c);
constexpr bool isascii(char c);

}
</pre>

<p>Counterparts of the corresponding <tt>&lt;cctype&gt;</tt> functions.</p>




<h3 id="ascii--todigit">
<span class="h3_num">2.3.2</span><tt>ascii::todigit()</tt>
</h3>


<pre class="code">
constexpr char ascii::todigit(int d);
</pre>

<p>Converts integer value from 0 to 9 to the decimal digit. The result is
undefined if the input value goes beyond the range.</p>
<div>
<u>Precondition</u>: <tt>0 &lt;= d &amp;&amp; d &lt;= 9</tt>
</div>




<h3 id="ascii--toxdigit">
<span class="h3_num">2.3.3</span><tt>ascii::toxdigit_upper()</tt>, <tt>ascii::toxdigit_lower()</tt>
</h3>


<pre class="code">
namespace ascii {

constexpr char toxdigit_upper(int d);
constexpr char toxdigit_lower(int d);

}
</pre>

<p>Converts integer value from 0 to 15 to the hexadecimal digit. The first one
uses upper case for <tt>A</tt>-<tt>F</tt>, the latter - lower. The result
is undefined if the input value goes beyond the range.</p>
<div>
<u>Precondition</u>: <tt>0 &lt;= d &amp;&amp; d &lt;= 15</tt>
</div>




<h3 id="ascii--digit_to_number">
<span class="h3_num">2.3.4</span><tt>ascii::digit_to_number()</tt>
</h3>


<pre class="code">
constexpr int ascii::digit_to_number(char d);
</pre>

<p>Converts the given decimal digit to the number if <tt>ascii::isdigit(d)</tt>.
<tt>-1</tt> is returned otherwise.</p>




<h3 id="ascii--xdigit_to_number">
<span class="h3_num">2.3.5</span><tt>ascii::xdigit_to_number()</tt>
</h3>


<pre class="code">
constexpr int ascii::xdigit_to_number(char d);
</pre>

<p>Converts the given hexadecimal digit to the number if
<tt>ascii::isxdigit(d)</tt>. <tt>-1</tt> is returned otherwise.</p>




<h3 id="ascii--tolower-char">
<span class="h3_num">2.3.6</span><tt>ascii::tolower(char)</tt>, <tt>ascii::toupper(char)</tt>
</h3>


<pre class="code">
namespace ascii {

constexpr char tolower(char c);
constexpr char toupper(char c);
constexpr char upper_to_lower(char upper);
constexpr char lower_to_upper(char lower);

}
</pre>

<div>
<pre class="prototype">constexpr char tolower(char c)</pre>
<pre class="prototype">constexpr char toupper(char c)</pre>
<blockquote>


<p>Counterparts of the corresponding <tt>&lt;cctype&gt;</tt> functions.</p>
</blockquote>
</div>

<div>
<pre class="prototype">constexpr char upper_to_lower(char upper)</pre>
<blockquote>

<p>More restricted counterpart of <tt>tolower()</tt>. The result is undefined
if the argument is not an ASCII capital letter.</p>
<div>
<u>Precondition</u>: <tt>ascii::isupper(upper)</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">constexpr char lower_to_upper(char lower)</pre>
<blockquote>

<p>More restricted counterpart of <tt>toupper()</tt>. The result is undefined
if the argument is not an ASCII small letter.</p>
<div>
<u>Precondition</u>: <tt>ascii::islower(lower)</tt>
</div>
</blockquote>
</div>




<h3 id="ascii--equal_icase-char">
<span class="h3_num">2.3.7</span><tt>ascii::equal_icase(char,char)</tt>
</h3>


<pre class="code">
constexpr bool ascii::equal_icase(char ch1, char ch2);
</pre>

<p>Checks equality of the two ASCII-characters ignoring the case.</p>






<h2 id="ascii_string.h">
<span class="h2_num">2.4</span><tt>__vic/ascii_string.h</tt>
</h2>


<p>ASCII-strings processing tools.</p>


<h3 id="ascii--tolower-str">
<span class="h3_num">2.4.1</span><tt>ascii::tolower()</tt>
</h3>


<pre class="code">
namespace ascii {

char *tolower(char *str);
std::string &amp;tolower(std::string &amp;str);

}
</pre>

<p>Translates all Latin capital letters of <tt>str</tt> to the small ones.
Returns <tt>str</tt>. C-string must not be <tt>nullptr</tt>!</p>




<h3 id="ascii--toupper-str">
<span class="h3_num">2.4.2</span><tt>ascii::toupper()</tt>
</h3>


<pre class="code">
namespace ascii {

char *toupper(char *str);
std::string &amp;toupper(std::string &amp;str);

}
</pre>

<p>Translates all Latin small letters of <tt>str</tt> to the capital ones.
Returns <tt>str</tt>. C-string must not be <tt>nullptr</tt>!</p>




<h3 id="ascii--equal_icase-str">
<span class="h3_num">2.4.3</span><tt>ascii::equal_icase()</tt>
</h3>


<pre class="code">
namespace ascii {

bool equal_icase(const char *s1, const char *s2);
bool equal_icase(const char *s1, size_t s1_len,
                 const char *s2, size_t s2_len);

#if __cpp_lib_string_view // C++17

bool equal_icase(std::string_view s1, std::string_view s2);

#else // until C++17

bool equal_icase(const std::string &amp;s1, const std::string &amp;s2);
bool equal_icase(const std::string &amp;s1, const char *s2);
bool equal_icase(const char *s1, const std::string &amp;s2);

#endif
}
</pre>

<p>Checks equality of two ASCII-strings ignoring the case. The pointers must not
be <tt>nullptr</tt>!</p>






<h2 id="base16.h">
<span class="h2_num">2.5</span><tt>__vic/base16.h</tt>
</h2>


<p>Base16 encoder and decoder.</p>


<h3 id="base16">
<span class="h3_num">2.5.1</span><tt>base16</tt>
</h3>


<p>A class used as a namespace. Contains only types, constants and static
functions. No objects of this class are supposed to be created.</p>




<h3 id="base16--bad_format">
<span class="h3_num">2.5.2</span><tt>base16::bad_format</tt>
</h3>


<pre class="code">
struct base16::bad_format : public std::exception {};
</pre>

<p>Abstract base exception class.</p>




<h3 id="base16--bad_digit">
<span class="h3_num">2.5.3</span><tt>base16::bad_digit</tt>
</h3>


<pre class="code">
struct base16::bad_digit : public base16::bad_format
{
    const char *what() const noexcept;
};
</pre>

<p>Exception class thrown by <a href="#base16--decode"><tt>base16::decode()</tt></a> when the input sequence
contains character that is not a valid HEX digit.</p>




<h3 id="base16--bad_length">
<span class="h3_num">2.5.4</span><tt>base16::bad_length</tt>
</h3>


<pre class="code">
struct base16::bad_length : public base16::bad_format
{
    const char *what() const noexcept;
};
</pre>

<p>Exception class thrown by <a href="#base16--decode"><tt>base16::decode()</tt></a> when the input sequence
length is odd.</p>




<h3 id="base16--status">
<span class="h3_num">2.5.5</span><tt>base16::status</tt>
</h3>


<pre class="code">
enum class base16::status
{
    ok,
    invalid_length,
    invalid_digit
};
using base16::status_t = base16::status; // for C++98
</pre>

<p>Input sequence parsing outcome status codes returned by
<a href="#base16--try_decode"><tt>base16::try_decode()</tt></a>.</p>




<h3 id="base16--encode_upper">
<span class="h3_num">2.5.6</span><tt>base16::encode_upper()</tt>
</h3>


<pre class="code">
// Bytes -&gt; Text
template&lt;class ByteReader, class CharWriter&gt;
void base16::encode_upper(ByteReader reader, CharWriter writer);
</pre>

<p>Encodes bytes from <tt>reader</tt> and writes the resulting characters to
<tt>writer</tt>. Upper case is used for hexadecimal digits.</p>

<p><tt>ByteReader</tt> has to model <tt>Reader&lt;unsigned char&gt;</tt> concept.
See <a href="#readers"><tt>__vic/readers/</tt></a>.</p>

<p><tt>CharWriter</tt> has to model <tt>Writer&lt;char&gt;</tt> concept.
See <a href="#writers"><tt>__vic/writers/</tt></a>.</p>


<div class="section">Example</div>
<pre class="code">
#include&lt;__vic/readers/string.h&gt;
#include&lt;__vic/writers/string.h&gt;

using bytes = std::string;
using bytes_reader = __vic::string_reader;

std::string encode_base16(const bytes &amp;s)
{
    std::string res;
    res.reserve(s.length() * 2);
    __vic::base16::encode_upper(bytes_reader(s), __vic::string_writer(res));
    return res;
}
</pre>





<h3 id="base16--encode_lower">
<span class="h3_num">2.5.7</span><tt>base16::encode_lower()</tt>
</h3>


<pre class="code">
// Bytes -&gt; Text
template&lt;class ByteReader, class CharWriter&gt;
void base16::encode_lower(ByteReader reader, CharWriter writer);
</pre>

<p>Same as <a href="#base16--encode_upper"><tt>base16::encode_upper()</tt></a> but lower case is used for
hexadecimal digits.</p>




<h3 id="base16--encode_byte_lower">
<span class="h3_num">2.5.8</span><tt>base16::encode_byte_lower()</tt>
</h3>


<pre class="code">
// Byte -&gt; Text
template&lt;class CharWriter&gt;
void base16::encode_byte_lower(unsigned char byte, CharWriter writer);
</pre>

<p>Same as <a href="#base16--encode_lower"><tt>base16::encode_lower()</tt></a> but encodes only single byte.</p>




<h3 id="base16--encode_byte_upper">
<span class="h3_num">2.5.9</span><tt>base16::encode_byte_upper()</tt>
</h3>


<pre class="code">
// Byte -&gt; Text
template&lt;class CharWriter&gt;
void base16::encode_byte_upper(unsigned char byte, CharWriter writer);
</pre>

<p>Same as <a href="#base16--encode_upper"><tt>base16::encode_upper()</tt></a> but encodes only single byte.</p>




<h3 id="base16--decode">
<span class="h3_num">2.5.10</span><tt>base16::decode()</tt>
</h3>


<pre class="code">
// Text -&gt; Bytes
template&lt;class CharReader, class ByteWriter&gt;
void base16::decode(CharReader reader, ByteWriter writer);
</pre>

<p>Decodes characters from <tt>reader</tt> and writes the resulting bytes to
<tt>writer</tt>. Exception derived from <a href="#base16--bad_format"><tt>base16::bad_format</tt></a> is
thrown if the input sequence has invalid Base16 format.</p>

<p><tt>CharReader</tt> has to model <tt>Reader&lt;char&gt;</tt> concept.
See <a href="#readers"><tt>__vic/readers/</tt></a>.</p>

<p><tt>ByteWriter</tt> has to model <tt>Writer&lt;unsigned char&gt;</tt> concept.
See <a href="#writers"><tt>__vic/writers/</tt></a>.</p>

<div class="section">Example</div>
<pre class="code">
#include&lt;__vic/readers/string.h&gt;
#include&lt;__vic/writers/string.h&gt;

using bytes = std::string;
using bytes_writer = __vic::string_writer;

bytes decode_base16(const std::string &amp;s)
{
    bytes res;
    res.reserve(s.length() / 2);
    __vic::base16::decode(__vic::string_reader(s), bytes_writer(res));
    return res;
}
</pre>





<h3 id="base16--try_decode">
<span class="h3_num">2.5.11</span><tt>base16::try_decode()</tt>
</h3>


<pre class="code">
// Text -&gt; Bytes
template&lt;class CharReader, class ByteWriter&gt;
base16::status_t base16::try_decode(CharReader reader, ByteWriter writer);
</pre>

<p>Same as <a href="#base16--decode"><tt>base16::decode()</tt></a> but returns <a href="#base16--status"><tt>base16::status</tt></a>
different from <tt>base16::status::ok</tt> in case of invalid input sequence
instead of throwing exception.</p>






<h2 id="base64.h">
<span class="h2_num">2.6</span><tt>__vic/base64.h</tt>
</h2>


<p>Base64 encoder and decoder.</p>


<h3 id="base64">
<span class="h3_num">2.6.1</span><tt>base64</tt>
</h3>


<p>A class used as a namespace. Contains only types, constants and static
functions. No objects of this class are supposed to be created.</p>




<h3 id="base64--bad_format">
<span class="h3_num">2.6.2</span><tt>base64::bad_format</tt>
</h3>


<pre class="code">
struct base64::bad_format : public std::exception {};
</pre>

<p>Abstract base exception class.</p>




<h3 id="base64--bad_digit">
<span class="h3_num">2.6.3</span><tt>base64::bad_digit</tt>
</h3>


<pre class="code">
struct base64::bad_digit : public base64::bad_format
{
    const char *what() const noexcept;
};
</pre>

<p>Exception class thrown by <a href="#base64--decode"><tt>base64::decode()</tt></a> when the input sequence
contains character that is not a valid Base64 digit.</p>




<h3 id="base64--bad_length">
<span class="h3_num">2.6.4</span><tt>base64::bad_length</tt>
</h3>


<pre class="code">
struct base64::bad_length : public base64::bad_format
{
    const char *what() const noexcept;
};
</pre>

<p>Exception class thrown by <a href="#base64--decode"><tt>base64::decode()</tt></a> when the input sequence
length is not a multiple of 4.</p>




<h3 id="base64--status">
<span class="h3_num">2.6.5</span><tt>base64::status</tt>
</h3>


<pre class="code">
enum class base64::status
{
    ok,
    invalid_length,
    invalid_digit
};
using base64::status_t = base64::status; // for C++98
</pre>

<p>Input sequence parsing outcome status codes returned by
<a href="#base64--try_decode"><tt>base64::try_decode()</tt></a>.</p>




<h3 id="base64--encode">
<span class="h3_num">2.6.6</span><tt>base64::encode()</tt>
</h3>


<pre class="code">
// Bytes -&gt; Text
template&lt;class ByteReader, class CharWriter&gt;
void base64::encode(ByteReader reader, CharWriter writer);
</pre>

<p>Encodes bytes from <tt>reader</tt> and writes the resulting characters to
<tt>writer</tt>.</p>

<p><tt>ByteReader</tt> has to model <tt>Reader&lt;unsigned char&gt;</tt> concept.
See <a href="#readers"><tt>__vic/readers/</tt></a>.</p>

<p><tt>CharWriter</tt> has to model <tt>Writer&lt;char&gt;</tt> concept.
See <a href="#writers"><tt>__vic/writers/</tt></a>.</p>

<div class="section">Example</div>
<pre class="code">
#include&lt;__vic/readers/string.h&gt;
#include&lt;__vic/writers/string.h&gt;

using bytes = std::string;
using bytes_reader = __vic::string_reader;

std::string encode_base64(const bytes &amp;s)
{
    std::string res;
    res.reserve(__vic::base64::encoded_length(s.length()));
    __vic::base64::encode(bytes_reader(s), __vic::string_writer(res));
    return res;
}
</pre>





<h3 id="base64--decode">
<span class="h3_num">2.6.7</span><tt>base64::decode()</tt>
</h3>


<pre class="code">
// Text -&gt; Bytes
template&lt;class CharReader, class ByteWriter&gt;
void base64::decode(CharReader reader, ByteWriter writer);
</pre>

<p>Decodes characters form <tt>reader</tt> and writes the resulting bytes to
<tt>writer</tt>. Exception derived from <a href="#base64--bad_format"><tt>base64::bad_format</tt></a> is
thrown if the input sequence has invalid Base64 format.</p>

<p><tt>CharReader</tt> has to model <tt>Reader&lt;char&gt;</tt> concept.
See <a href="#readers"><tt>__vic/readers/</tt></a>.</p>

<p><tt>ByteWriter</tt> has to model <tt>Writer&lt;unsigned char&gt;</tt> concept.
See <a href="#writers"><tt>__vic/writers/</tt></a>.</p>

<div class="section">Example</div>
<pre class="code">
#include&lt;__vic/readers/string.h&gt;
#include&lt;__vic/writers/string.h&gt;

using bytes = std::string;
using bytes_writer = __vic::string_writer;

bytes decode_base64(const std::string &amp;s)
{
    bytes res;
    res.reserve(__vic::base64::max_decoded_length(s.length()));
    __vic::base64::decode(__vic::string_reader(s), bytes_writer(res));
    return res;
}
</pre>





<h3 id="base64--try_decode">
<span class="h3_num">2.6.8</span><tt>base64::try_decode()</tt>
</h3>


<pre class="code">
// Text -&gt; Bytes
template&lt;class CharReader, class ByteWriter&gt;
base64::status_t base64::try_decode(CharReader reader, ByteWriter writer);
</pre>

<p>Same as <a href="#base64--decode"><tt>base64::decode()</tt></a> but returns <a href="#base64--status"><tt>base64::status</tt></a>
different from <tt>base64::status::ok</tt> in case of invalid input sequence
instead of throwing exception.</p>




<h3 id="base64--encoded_length">
<span class="h3_num">2.6.9</span><tt>base64::encoded_length()</tt>
</h3>


<pre class="code">
constexpr size_t base64::encoded_length(size_t orig_len);
</pre>

<p>Calculates the length of encoded sequence of characters using the original
length of the bytes sequence.</p>




<h3 id="base64--max_decoded_length">
<span class="h3_num">2.6.10</span><tt>base64::max_decoded_length()</tt>
</h3>


<pre class="code">
constexpr size_t base64::max_decoded_length(size_t orig_len);
</pre>

<p>Estimates the maximum length of decoded sequence of bytes using the original
length of the characters sequence. The actual value depends on trailing
<tt>'='</tt> in the encoded value.</p>






<h2 id="bin_file.h">
<span class="h2_num">2.7</span><tt>__vic/bin_file.h</tt>
</h2>


<h3 id="bin_file">
<span class="h3_num">2.7.1</span><tt>bin_file</tt>
</h3>


<pre class="code">
class bin_file : private non_copyable
{
public:
    enum in_t { in };
    enum out_t { out };
    enum append_t { append };

    bin_file();
    bin_file(const char *fname, in_t);
    bin_file(const char *fname, out_t);
    bin_file(const char *fname, append_t);
    ~bin_file();

    // BEGIN C++11
    bin_file(bin_file &amp;&amp;o) noexcept;
    bin_file &amp;operator=(bin_file &amp;&amp;o) noexcept;
    // END C++11

    bool open_in(const char *fname);
    bool open_out(const char *fname);
    bool open_append(const char *fname);

    size_t read_max(void *buf, size_t n);
    size_t read_some(void *buf, size_t n);

    void write_all(const void *buf, size_t n);

    bool is_open() const;
    void close();
    bool close_nt() noexcept;

    void swap(bin_file &amp;o) noexcept;

    [[noreturn]] void throw_last_error(const char *msg);
    void throw_if_closed(const char *msg);
};
</pre>

<p>Unbuffered binary file. OS-independent wrapper for low-level system API.</p>

<p>Following open modes are available:</p>
<ul>
<li>
<tt>in</tt> - open existing file for reading;</li>
<li>
<tt>out</tt> - create new file for writing, overwrite if exists;</li>
<li>
<tt>append</tt> - open existing file for appending (writing at end of
        file), create if does not exist.</li>
</ul>

<div class="section">Class members</div>

<div>
<pre class="prototype">enum in_t { in }</pre>
<pre class="prototype">enum out_t { out }</pre>
<pre class="prototype">enum append_t { append }</pre>
<blockquote>



<p>Constructor tags.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bin_file()</pre>
<blockquote>

<div>
<u>Postcondition</u>: <tt>is_open() == false()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bin_file(const char *fname, in_t)</pre>
<pre class="prototype">bin_file(const char *fname, out_t)</pre>
<pre class="prototype">bin_file(const char *fname, append_t)</pre>
<blockquote>



<p>Call <tt>open_in(fname)</tt>, <tt>open_out(fname)</tt> or
<tt>open_append(fname)</tt>, correspondingly. <tt>is_open()</tt> or
<tt>throw_if_closed()</tt> has to be called then to check the result.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~bin_file()</pre>
<blockquote>

<p>Closes the file if <tt>is_open() == true</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bin_file(bin_file &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<pre class="prototype">bin_file &amp;operator=(bin_file &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Move operations for C++11 mode.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool open_in(const char *fname)</pre>
<pre class="prototype">bool open_out(const char *fname)</pre>
<pre class="prototype">bool open_append(const char *fname)</pre>
<blockquote>



<p>Open file for reading, writing or appending, correspondingly. Return
<tt>is_open()</tt>.</p>
<div>
<u>Precondition</u>: <tt>is_open() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool is_open() const</pre>
<blockquote>

<p>Returns <tt>true</tt> if file is open.</p>
</blockquote>
</div>

<div>
<pre class="prototype">size_t read_max(void *buf, size_t n)</pre>
<blockquote>

<p>Tries to read <tt>n</tt> bytes to the specified buffer. Returns number of
bytes read. Returned value can be less than requested only when end of file
was reached. Throws on error.</p>
<div>
<u>Precondition</u>: <tt>is_open() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">size_t read_some(void *buf, size_t n)</pre>
<blockquote>

<p>Reads no more than <tt>n</tt> bytes to the specified buffer. Returns number
of bytes read or <tt>0</tt> in case of end-of-file. The function returns after
first chunk of any size was successfully received. Throws on error.</p>
<div>
<u>Precondition</u>: <tt>is_open() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void write_all(const void *buf, size_t n)</pre>
<blockquote>

<p>Writes the whole buffer to the file. Throws on error.</p>
<div>
<u>Precondition</u>: <tt>is_open() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void close()</pre>
<blockquote>

<p>Closes the file. Throws on error.</p>
<div>
<u>Precondition</u>: <tt>is_open() == true</tt>
</div>
<div>
<u>Postcondition</u>: <tt>is_open() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool close_nt() noexcept</pre>
<blockquote>

<p>A counterpart of <tt>close()</tt> but never throws, returns <tt>false</tt>
instead in case of error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void swap(bin_file &amp;o) noexcept</pre>
<blockquote>

<p>Swaps the value with <tt>o</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">[[noreturn]] void throw_last_error(const char *msg)</pre>
<blockquote>

<p>Throws exception with the last error description if available.
<tt>what()</tt> will contain <tt>msg</tt> as a substring anyway.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void throw_if_closed(const char *msg)</pre>
<blockquote>

<p>Calls <tt>throw_last_error(msg)</tt> if <tt>!is_open()</tt>.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
// Copy file
__vic::bin_file in("file", __vic::bin_file::in);
in.throw_if_closed("Cannot open file")
__vic::bin_file out("file.copy", __vic::bin_file::out);
out.throw_if_closed("Cannot create file")

char buf[512];
while(size_t n = in.read_some(buf, sizeof buf))
    out.write_all(buf, n);

out.close();
// in will be closed by destructor
</pre>






<h2 id="bits.h">
<span class="h2_num">2.8</span><tt>__vic/bits.h</tt>
</h2>


<p>Bits and bytes manipulation tools.</p>


<h3 id="lo_nibble">
<span class="h3_num">2.8.1</span><tt>lo_nibble()</tt>, <tt>hi_nibble()</tt>
</h3>


<pre class="code">
constexpr uint8_t lo_nibble(uint8_t byte);
constexpr uint8_t hi_nibble(uint8_t byte);
</pre>

<p>Return the value of the low-order/high-order half-byte (tetrad),
respectively.</p>




<h3 id="msb_ones">
<span class="h3_num">2.8.2</span><tt>msb_ones()</tt>, <tt>lsb_ones()</tt>
</h3>


<pre class="code">
template&lt;class T&gt; constexpr T lsb_ones(unsigned bits_num);
template&lt;class T&gt; constexpr T msb_ones(unsigned bits_num);
</pre>

<p>Return the value of the type <tt>T</tt> with all least/most significant
<tt>bits_num</tt> bits filled with <tt>1</tt>, respectively. All other bits
are set to <tt>0</tt>.</p>




<h3 id="get_lsbs">
<span class="h3_num">2.8.3</span><tt>get_lsbs()</tt>
</h3>


<pre class="code">
template&lt;class T&gt; constexpr T get_lsbs(T v, unsigned bits_num);
</pre>

<p>Returns <tt>bits_num</tt> least significant bits of <tt>v</tt>. In other
words, zeroes all but <tt>bits_num</tt> least significant bits.</p>




<h3 id="ord">
<span class="h3_num">2.8.4</span><tt>ord()</tt>
</h3>


<pre class="code">
constexpr int ord(char ch);
</pre>

<p>Returns the character code from 0 to 255.</p>
<div>
<u>Postcondition</u>: ord(ch) &gt;= 0</div>




<h3 id="popcount">
<span class="h3_num">2.8.5</span><tt>popcount()</tt>
</h3>


<pre class="code">
unsigned popcount(unsigned v);
unsigned popcount(unsigned long v);
unsigned popcount(unsigned long long v);
unsigned popcount(unsigned short v);
unsigned popcount(unsigned char v);
</pre>

<p>Returns the number of one bits in the given value.</p>




<h3 id="msb_position">
<span class="h3_num">2.8.6</span><tt>msb_position()</tt>
</h3>


<pre class="code">
unsigned msb_position(unsigned v)
unsigned msb_position(unsigned long v);
unsigned msb_position(unsigned long long v);
unsigned msb_position(unsigned short v);
unsigned msb_position(unsigned char v);
</pre>

<div>
<u>Precondition</u>: <tt>v != 0</tt>
</div>

<p>Returns the position of the most significant 1-bit. The result is unspecified
if <tt>v == 0</tt>.</p>




<h3 id="ispow2">
<span class="h3_num">2.8.7</span><tt>ispow2()</tt>
</h3>


<pre class="code">
template&lt;class UInt&gt;
bool ispow2(UInt n);
</pre>

<div>
<u>Precondition</u>: <tt>UInt</tt> is an unsigned integer type</div>

<p>Returns <tt>true</tt> if <tt>n</tt> is an integral power of 2.</p>




<h3 id="ceil2">
<span class="h3_num">2.8.8</span><tt>ceil2()</tt>
</h3>


<pre class="code">
template&lt;class UInt&gt;
UInt ceil2(UInt n);
</pre>

<div>
<u>Precondition</u>: <tt>UInt</tt> is an unsigned integer type</div>

<p>Returns the minimal value <tt>m</tt> such that <tt>ispow2(m) &amp;&amp;
m &gt;= n</tt>. If <tt>m</tt> is not representable as a value of type
<tt>UInt</tt>, the result is an unspecified value.</p>




<h3 id="floor2">
<span class="h3_num">2.8.9</span><tt>floor2()</tt>
</h3>


<pre class="code">
template&lt;class UInt&gt;
UInt floor2(UInt n);
</pre>

<div>
<u>Precondition</u>: <tt>UInt</tt> is an unsigned integer type</div>

<p>If <tt>n != 0</tt> returns the maximal value <tt>m</tt> such that
<tt>ispow2(m) &amp;&amp; m &lt;= n</tt>. Otherwise <tt>0</tt> is returned.</p>




<h3 id="ceil_log2">
<span class="h3_num">2.8.10</span><tt>ceil_log2()</tt>
</h3>


<pre class="code">
template&lt;class UInt&gt;
unsigned ceil_log2(UInt n);
</pre>

<div>
<u>Precondition</u>: <tt>UInt</tt> is an unsigned integer type</div>

<p>Returns <tt>ceil(log2(n))</tt> if <tt>n != 0</tt> or 0 otherwise.</p>




<h3 id="floor_log2">
<span class="h3_num">2.8.11</span><tt>floor_log2()</tt>
</h3>


<pre class="code">
template&lt;class UInt&gt;
unsigned floor_log2(UInt n);
</pre>

<div>
<u>Precondition</u>: <tt>UInt</tt> is an unsigned integer type</div>

<p>Returns <tt>floor(log2(n))</tt> if <tt>n != 0</tt> or 0 otherwise.</p>




<h3 id="rotl">
<span class="h3_num">2.8.12</span><tt>rotl()</tt>, <tt>rotr()</tt>
</h3>


<pre class="code">
unsigned long long rotl(unsigned long long v, int shift);
unsigned long      rotl(unsigned long v, int shift);
unsigned           rotl(unsigned v, int shift);
unsigned short     rotl(unsigned short v, int shift);
unsigned char      rotl(unsigned char v, int shift);

unsigned long long rotr(unsigned long long v, int shift);
unsigned long      rotr(unsigned long v, int shift);
unsigned           rotr(unsigned v, int shift);
unsigned short     rotr(unsigned short v, int shift);
unsigned char      rotr(unsigned char v, int shift);
</pre>

<p>The functions perform circular left (<tt>rotl</tt>) or right
(<tt>rotr</tt>) bitwise shift (rotation).</p>
<div>
<u>Precondition</u>: <tt>0 &lt;= shift &amp;&amp; shift &lt; sizeof(v)*CHAR_BIT</tt>
</div>




<h3 id="swapped_nibbles">
<span class="h3_num">2.8.13</span><tt>swapped_nibbles()</tt>
</h3>


<pre class="code">
constexpr uint8_t swapped_nibbles(uint8_t b);
</pre>

<p>Swaps a low-order half-byte with a high-order one and returns the value.</p>






<h2 id="date_time.h">
<span class="h2_num">2.9</span><tt>__vic/date_time.h</tt>
</h2>


<p>Date and time utilies.</p>


<h3 id="is_leap_year">
<span class="h3_num">2.9.1</span><tt>is_leap_year()</tt>
</h3>


<pre class="code">
constexpr bool is_leap_year(int year);
</pre>

<p>Determines if the year is a leap year according to Gregorian calendar.</p>




<h3 id="days_in_month">
<span class="h3_num">2.9.2</span><tt>days_in_month()</tt>
</h3>


<pre class="code">
int days_in_month(int month, int year);
</pre>

<p>Returns number of days in the month. Month is a number from 1 to 12.
The second parameter is used only if the month is 2 (february), otherwise
is just ignored.</p>




<h3 id="days_between_years">
<span class="h3_num">2.9.3</span><tt>days_between_years()</tt>
</h3>


<pre class="code">
long days_between_years(unsigned year1, unsigned year2);
</pre>

<p>Returns the difference in days between the beginning of the 2nd year and
the beginning of the 1st year.</p>




<h3 id="invalid_date">
<span class="h3_num">2.9.4</span><tt>invalid_date</tt>
</h3>


<pre class="code">
class invalid_date; // : public std::exception
</pre>

<p>The exception thrown when the value of the date or time element is
invalid.</p>




<h3 id="validate_date_time">
<span class="h3_num">2.9.5</span><tt>validate_date()</tt>, <tt>validate_time()</tt>,
<tt>validate_date_time()</tt>
</h3>


<pre class="code">
void validate_date(int yy, int mm, int dd);
void validate_time(int hh, int mi, int ss);
void validate_date_time(int yy, int mm, int dd, int hh, int mi, int ss);
</pre>

<p>Checks if the date/time value is valid. Following constraints are checked:
</p>
<ul>
<li>
<tt>yy</tt> (year) - cannot be <tt>0</tt>,</li>
<li>
<tt>mm</tt> (month) - <tt>1..12</tt>,</li>
<li>
<tt>dd</tt> (day of the month) - <tt>1..{28..31}</tt>, depending
        on the month,</li>
<li>
<tt>hh</tt> (hour) - <tt>0..23</tt>,</li>
<li>
<tt>mi</tt> (minute) - <tt>0..59</tt>,</li>
<li>
<tt>ss</tt> (second) - <tt>0..59</tt>.</li>
</ul>

<p><tt>invalid_date</tt> is thrown in case of the constraint violation.</p>

<div>
<u><b>Note</b></u>: Specific time values as <tt>24:00:00</tt> (midnight at the end of a
day) or <tt>59:60</tt> (leap second) are considered as invalid!</div>






<h2 id="endian.h">
<span class="h2_num">2.10</span><tt>__vic/endian.h</tt>
</h2>


<p>Byte order-related utilities.</p>


<h3 id="endianness">
<span class="h3_num">2.10.1</span><tt>endianness</tt>
</h3>


<pre class="code">
namespace endian {
enum endianness
{
    unknown = 0,
    little  = 1234,
    big     = 4321,
    pdp     = 3412,
    native  = <span class="nonterminal">&lt;one-of-the-above&gt;</span>
};
} // namespace

using endian::endianness;
</pre>

<p>Byte order constants. <tt>endian::native</tt> is set equal to one of the
constants and represents the byte order used on the current platform (like
<tt>__BYTE_ORDER__</tt> macro on UNIX-like platforms). The values are supposed
to be used for template specializations or for compile-time checks (e.g. in
<tt>static_assert</tt>).</p>

<div class="section">Examples</div>
<pre class="code">
template&lt;__vic::endianness &gt; struct some_algo; // not implemented

// Implementation for little-endian
template&lt;&gt; struct some_algo&lt;__vic::endian::little&gt;
{
    static void doit() { ... }
};
// Implementation for big-endian
template&lt;&gt; struct some_algo&lt;__vic::endian::big&gt;
{
    static void doit() { ... }
};

// Automatically choose an appropriate implementation for the used platform
some_algo&lt;__vic::endian::native&gt;::doit();
</pre>

<pre class="code">
static_assert(__vic::endian::native == __vic::endian:little,
    "Litte-endian is expected");
</pre>





<h3 id="endian--from">
<span class="h3_num">2.10.2</span><tt>endian::from_...()</tt>
</h3>


<pre class="code">
template&lt;class T&gt; [[nodiscard]] constexpr T endian::from_little(T v);
template&lt;class T&gt; [[nodiscard]] constexpr T endian::from_big(T v);
</pre>

<p>Return a value represented in native byte order converted from litte/big
endian if appropriate.</p>

<p><tt>T</tt> can be any integral type or enum with size up to
<tt>sizeof(long long)</tt>.</p>

<div class="section">Example</div>
<pre class="code">
uint16_t v;
read_bytes(&amp;v, 2); // serialized as big endian
std::cout &lt;&lt; "The value is " &lt;&lt; __vic::endian::from_big(v) &lt;&lt; '\n';
</pre>





<h3 id="endian--to">
<span class="h3_num">2.10.3</span><tt>endian::to_...()</tt>
</h3>


<pre class="code">
template&lt;class T&gt; [[nodiscard]] constexpr T endian::to_little(T v);
template&lt;class T&gt; [[nodiscard]] constexpr T endian::to_big(T v);
</pre>

<p>Return a value represented in litte/big endian byte order.</p>

<p><tt>T</tt> can be any integral type or enum with size up to
<tt>sizeof(long long)</tt>.</p>

<div class="section">Example</div>
<pre class="code">
uint16_t v = __vic::endian::to_big(...);
write_bytes(&amp;v, 2); // serialize as big endian
</pre>





<h3 id="swab">
<span class="h3_num">2.10.4</span><tt>swab16()</tt>, <tt>swab32()</tt>, <tt>swab64()</tt>
</h3>


<pre class="code">
[[nodiscard]] constexpr uint16_t swab16(uint16_t v);
[[nodiscard]] constexpr uint32_t swab32(uint32_t v);
[[nodiscard]] constexpr uint64_t swab64(uint64_t v);
</pre>

<p>Fast utilities to reverse byte order (usually implemented using
compiler-specific intrinsics).</p>

<div class="section">Example</div>
<pre class="code">
static_assert(__vic::swab32(0x01020304) == 0x04030201);
</pre>







<h2 id="error.h">
<span class="h2_num">2.11</span><tt>__vic/error.h</tt>
</h2>


<p>Error handling tools.</p>


<h3 id="exception">
<span class="h3_num">2.11.1</span><tt>exception</tt>
</h3>


<pre class="code">
class exception : public std::exception
{
public:
    exception();
    explicit exception(const char *message);
    const char *what() const noexcept;
protected:
    void set_message(const char *message);
};
</pre>

<p>Small extension of <tt>std::exception</tt> - the object carries message
specified in the constructor, <tt>what()</tt> returns this message. Can be used
either as a base or a concrete exception class. Does not use/depend on
<tt>std::string</tt> as opposed to <tt>std::logic_error</tt> and
<tt>std::runtime_error</tt>. You also don't have to decide which one of them
you should use in the particular case.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">exception()</pre>
<blockquote>

<p>Creates the object with an empty message.</p>
</blockquote>
</div>

<div>
<pre class="prototype">explicit exception(const char *message)</pre>
<blockquote>

<p>Creates the object with the specified message.</p>
</blockquote>
</div>

<div>
<pre class="prototype">const char *what() const noexcept</pre>
<blockquote>

<p>Returns the message specified before.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void set_message(const char *message)</pre>
<blockquote>

<p>Sets a new message.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
struct custom_exception : public __vic::exception
{
    explicit custom_exception(const char *msg) : __vic::exception(msg) {}
};

throw custom_exception("Error condition description");
</pre>





<h3 id="libc_error">
<span class="h3_num">2.11.2</span><tt>libc_error</tt>
</h3>


<pre class="code">
class libc_error : public std::exception
{
public:
    explicit libc_error(int err_no = errno);
    explicit libc_error(const char *prompt, int err_no = errno);

    const char *what() const noexcept;
    int code() const;
    int get_errno() const;
};
</pre>

<p>This class is an easy and straightforward replacement of the standard error
handling machinery used in the C-world - <tt>errno</tt>, with exceptions. The
class is also suitable for usage in the multithread environment instead of
not always reentrant call <tt>std::strerror()</tt>.</p>
<p>Below you can see typical C code:</p>

<pre class="code">
// C:

int fd;
if((fd = open("qqqq", O_RDONLY)) == -1)
{
    perror("open");
    if(errno == ENOENT) exit(1);
}
</pre>

<p>If the file is not found, the message like this</p>
<pre class="code">
open: No such file or directory
</pre>
<p>is printed to <tt>stderr</tt> and the program exits with the status
<tt>1</tt>.</p>

<p>What issues are inherent in this code? Firstly, not every program has
<tt>stderr</tt>, so a library function is not allowed to print error messages
there. Secondly, the value of the global variable <tt>errno</tt> can be
rewritten by any subsequent call unless the value is saved explicitly right
after the call. Thirdly, the decision about termination of the process can only
be made by the application. An ordinary library function is not allowed to do
this. Fourthly, in general case C++ program cannot call <tt>std::exit()</tt>,
because destructors of the live objects allocated on the stack won't be
called, and program's logic can be corrupted.</p>

<p>The example adapted for C++ using our class:</p>

<pre class="code">
// C++:

try
{
    int fd = open("qqqq", O_RDONLY);
    if(fd == -1) throw __vic::libc_error("open");
    // or just
    // if(fd == -1) throw __vic::libc_error();
}
catch(const __vic::libc_error &amp;ex)
{
    std::cerr &lt;&lt; ex.what() &lt;&lt; '\n';
    if(ex.code() == ENOENT) return 1;
}
</pre>

<p>As it can be seen, the function handles erroneous situation correctly and
reports it to the caller. Afterwards the caller can handle the error
appropriately. In the elementary case it acts as the former C-program: prints
the message to the standard error output stream and terminates. Moreover,
error code is now saved in the exception and cannot be rewritten by accident.
</p>

<div>
<u><b>Note</b></u>: Usually exceptions of this class shouldn't be thrown explicitly! Use
<a href="#throw_errno"><tt>throw_errno()</tt></a> instead.</div>

<div class="section">Class members</div>

<div>
<pre class="prototype">explicit libc_error(int err_no = errno)</pre>
<blockquote>

<p><tt>err_no</tt> - error code.</p>
<div>
<u>Postcondition</u>: <tt>code() == err_no</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">explicit libc_error(const char *prompt, int err_no = errno)</pre>
<blockquote>

<p><tt>prompt</tt> - a title of the error message. The parameter has the same
meaning as the parameter of <tt>std::perror()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">const char *what() const noexcept</pre>
<blockquote>

<p>Returns error description in the <tt>std::perror()</tt> format.</p>
</blockquote>
</div>

<div>
<pre class="prototype">int code() const</pre>
<pre class="prototype">int get_errno() const</pre>
<blockquote>


<p>Returns stored error code.</p>
</blockquote>
</div>








<h2 id="fixed_vector.h">
<span class="h2_num">2.12</span><tt>__vic/fixed_vector.h</tt>
</h2>


<h3 id="fixed_vector">
<span class="h3_num">2.12.1</span><tt>fixed_vector</tt>
</h3>

<pre class="code">
template&lt;class T&gt;
class fixed_vector : private non_copyable
{
public:
    using value_type     = T;
    using iterator       = <span class="nonterminal">&lt;implementation-defined&gt;</span>;
    using const_iterator = <span class="nonterminal">&lt;implementation-defined&gt;</span>;

    fixed_vector();
    explicit fixed_vector(size_t max_size);
    ~fixed_vector();

    // BEGIN C++11
    fixed_vector(fixed_vector &amp;&amp;o) noexcept;
    fixed_vector &amp;operator=(fixed_vector &amp;&amp;o) noexcept;
    template&lt;class... Args&gt; T &amp;emplace_back(Args &amp;&amp;... args)
    // END C++11

    // size in objects
    size_t size() const;
    size_t capacity() const;
    bool full() const;
    bool empty() const;

    void recreate(size_t new_max_size, bool size_exact = false);
    void *alloc(); // returns pointer to memory for object allocation
    void push_allocated(); // adds last allocated object to the container
    void pop_back();
    void clear();
    void swap(fixed_vector &amp;o) noexcept;

    // element access
    T &amp;operator[](size_t i);
    iterator begin();
    iterator end();
    T &amp;front();
    T &amp;back();

    const T &amp;operator[](size_t i) const;
    const_iterator begin() const;
    const_iterator end() const;
    const_iterator cbegin() const;
    const_iterator cend() const;
    const T &amp;front() const;
    const T &amp;back() const;
};
template&lt;class T&gt;
void swap(fixed_vector&lt;T&gt; &amp;o1, fixed_vector&lt;T&gt; &amp;o2) noexcept;
</pre>

<p>The standard containers in C++98 don't allow to store non-copiable elements.
Even in C++11 elements of containers like <tt>std::vector</tt> have to be at
least noexcept movable. This class solves the problem. It is a dynamic array
for non-copyable objects or just <tt>std::vector</tt> without autogrowing
<tt>capacity()</tt>.</p>

<p>Without <tt>emplace_back()</tt> it is impossible to create arbitrary new
object right in the container's memory. C++98 lacks forwarding references so it
is ear impossible to pass arbitrary parameters to the element's constructor.
<tt>fixed_vector</tt> overcomes this problem using the following mechanism.
The new element is created using several phases:</p>
<ol>
<li>Requesting memory for the new element in the container -
        <tt>alloc()</tt>,</li>
<li>Creation of the object using placement new -
        <tt>new(ptr) type(...)</tt>,</li>
<li>Fixation of the newly created object in the container -
        <tt>push_allocated()</tt>.</li>
</ol>
<p>See the example at the end of the article.</p>

<p>Maximum capacity is specified on creation of the container. Later it
can be changed but all the elements has to be destroyed before. In other words,
the container can be recreated (<tt>recreate()</tt> function).</p>

<p>When available, <tt>emplace_back()</tt> must be used for elements creation.
If not, the unsafe interface described above must be used with care. It is very
ugly and error-prone but solves the task. After the element is created in the
container, you operate with it almost as easy as with any other copyable object
in the standard container. Anyway, it is more efficient and convenient to use
in general than alternative approaches like creating the objects on the free
store and placing only pointers to the container, even if we have
<tt>std::unique_ptr</tt> to manage lifetime of the objects.</p>

<p>Fundamental differences from <tt>std::vector</tt>:</p>
<ol>
<li>Elements don't have to be copyable or movable (<tt>std::vector</tt>
        requires at least noexcept-movability);</li>
<li>Elements have stable addresses after addition of new element;</li>
<li>
<tt>emplace_back()</tt> has precondition (<tt>!full()</tt>).</li>
</ol>

<div class="section">Class members</div>

<div>
<pre class="prototype">typename value_type</pre>
<blockquote>

<p>Type of the elements.</p>
</blockquote>
</div>

<div>
<pre class="prototype">typename iterator</pre>
<pre class="prototype">typename const_iterator</pre>
<blockquote>


<p>Iterators.</p>
</blockquote>
</div>

<div>
<pre class="prototype">fixed_vector()</pre>
<blockquote>

<p>Create the object without memory allocation.</p>
<div>
<u>Postcondition</u>: <tt>capacity() == 0</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">explicit fixed_vector(size_t max_size)</pre>
<blockquote>

<p>Allocates memory for <tt>max_size</tt> elements.</p>
<div>
<u>Postcondition</u>: <tt>capacity() == max_size</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">~fixed_vector()</pre>
<blockquote>

<p>Calls <tt>clear()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">fixed_vector(fixed_vector &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<pre class="prototype">fixed_vector &amp;operator=(fixed_vector &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Move operations for C++11 mode.</p>
</blockquote>
</div>

<div>
<pre class="prototype">size_t size() const</pre>
<pre class="prototype">size_t capacity() const</pre>
<blockquote>


<p>Current size and capacity of the container.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool empty() const</pre>
<blockquote>

<p>Returns <tt>size() == 0</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool full() const</pre>
<blockquote>

<p>Returns <tt>size() == capacity()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void recreate(size_t new_max_size, bool size_exact = false)</pre>
<blockquote>

<p>Recreates the container. At first calls <tt>clear()</tt>, then reallocates
memory buffer if <tt>new_max_size &gt; capacity()</tt> or <tt>size_exact</tt> is
<tt>true</tt> and <tt>new_max_size != capacity()</tt>.</p>
<div>
<u>Postcondition</u>: <tt>capacity() &gt;= new_max_size &amp;&amp; empty() == true</tt>
(if <tt>size_exact == true</tt> then <tt>capacity() == new_max_size &amp;&amp;
empty() == true</tt>)</div>
</blockquote>
</div>

<div>
<pre class="prototype">void *alloc()</pre>
<blockquote>

<p>Returns the raw memory block where new instance of <tt>value_type</tt>
can be allocated.</p>
<div>
<u>Precondition</u>: <tt>!full()</tt>
</div>
<div>
<u>Note</u>: Use <tt>emplace_back()</tt> in C++11 mode.</div>
</blockquote>
</div>

<div>
<pre class="prototype">void push_allocated()</pre>
<blockquote>

<p>This call right after <tt>alloc()</tt> adds the just created object to the
container.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class... Args&gt; T &amp;emplace_back(Args &amp;&amp;... args) <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Constructs new object and adds it to the container (<tt>alloc()</tt> +
<tt>new</tt> + <tt>push_allocated()</tt> with a single call). A reference to
the new object is returned.</p>
<div>
<u>Precondition</u>: <tt>!full()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void pop_back()</pre>
<blockquote>

<p>Remove the last element from the container.</p>
<div>
<u>Precondition</u>: <tt>!empty()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void clear()</pre>
<blockquote>

<p>Destroys the elements in the reverse order they were created.</p>
<div>
<u>Postcondition</u>: <tt>size() == 0</tt> (<tt>empty() == true</tt>)</div>
</blockquote>
</div>

<div>
<pre class="prototype">void swap(fixed_vector &amp;o)</pre>
<pre class="prototype">template&lt;class T&gt; void swap(fixed_vector&lt;T&gt; &amp;o1, fixed_vector&lt;T&gt; &amp;o2) noexcept</pre>
<blockquote>


<p>Swaps the value with <tt>o</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">T &amp;operator[](size_t i)</pre>
<pre class="prototype">const T &amp;operator[](size_t i) const</pre>
<blockquote>


<p>Access to the elements by index.</p>
<div>
<u>Precondition</u>: <tt>i &lt; size()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">T &amp;front()</pre>
<pre class="prototype">const T &amp;front() const</pre>
<pre class="prototype">T &amp;back()</pre>
<pre class="prototype">const T &amp;back() const</pre>
<blockquote>




<p>Access to the first and the last elements.</p>
<div>
<u>Precondition</u>: <tt>!empty()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">iterator begin()</pre>
<pre class="prototype">const_iterator begin() const</pre>
<pre class="prototype">const_iterator cbegin() const</pre>
<pre class="prototype">iterator end()</pre>
<pre class="prototype">const_iterator end() const</pre>
<pre class="prototype">const_iterator cend() const</pre>
<blockquote>






<p>Access to the elements via iterators.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
// Creating vector for 2 objects of class C
__vic::fixed_vector&lt;C&gt; v(2);

// Creating new object in C++98 mode:
new(v.alloc()) C(...); // Request memory and construct the object
v.push_allocated();    // Fixate successfully created object in the container

// Creating new object in C++11 mode:
v.emplace_back(...);
</pre>






<h2 id="fs.h">
<span class="h2_num">2.13</span><tt>__vic/fs.h</tt>
</h2>


<p>Filesystem utilities.</p>

<div>
<u><b>Note</b></u>: All paths are expected to be UTF-8 encoded!</div>


<h3 id="path_exists">
<span class="h3_num">2.13.1</span><tt>path_exists()</tt>, <tt>file_exists()</tt>, <tt>dir_exists()</tt>
</h3>


<pre class="code">
bool path_exists(const char *path);
bool path_exists(const std::string &amp;path);

bool file_exists(const char *path);
bool file_exists(const std::string &amp;path);

bool dir_exists(const char *path);
bool dir_exists(const std::string &amp;path);
</pre>

<p><tt>path_exists()</tt> checks whether the path exists in the system. Second
and third functions additionally check, besides the presence, if the path
references to a regular file or to a directory, respectively.</p>




<h3 id="mkdir">
<span class="h3_num">2.13.2</span><tt>mkdir()</tt>, <tt>mkdir_if_absent()</tt>
</h3>


<pre class="code">
void mkdir(const char *path, mode_t mode = 0777);
void mkdir(const std::string &amp;path, mode_t mode = 0777);

bool mkdir_if_absent(const char *path, mode_t mode = 0777);
bool mkdir_if_absent(const std::string &amp;path, mode_t mode = 0777);
</pre>

<p>Creates a directory. Throws exception in case of failure.
<tt>mkdir_if_absent()</tt> returns <tt>false</tt> instead of throwing if
the directory already exists.</p>




<h3 id="rmdir">
<span class="h3_num">2.13.3</span><tt>rmdir()</tt>, <tt>rmdir_if_exists()</tt>
</h3>


<pre class="code">
void rmdir(const char *path);
void rmdir(const std::string &amp;path);

bool rmdir_if_exists(const char *path);
bool rmdir_if_exists(const std::string &amp;path);
</pre>

<p>Deletes an empty directory. Throws exception in case of failure.
<tt>rmdir_if_exists()</tt> returns <tt>false</tt> instead of throwing if
the directory doesn't exist.</p>




<h3 id="get_current_dir">
<span class="h3_num">2.13.4</span><tt>get_current_dir()</tt>
</h3>


<pre class="code">
std::string get_current_dir();
</pre>

<p>Returns current working directory.</p>




<h3 id="remove_file">
<span class="h3_num">2.13.5</span><tt>remove_file()</tt>, <tt>remove_file_if_exists()</tt>,
<tt>remove_file_nt()</tt>
</h3>


<pre class="code">
void remove_file(const char *path);
void remove_file(const std::string &amp;path);

bool remove_file_if_exists(const char *path);
bool remove_file_if_exists(const std::string &amp;path);

bool remove_file_nt(const char *path) noexcept;
bool remove_file_nt(const std::string &amp;path) noexcept;
</pre>

<p>Deletes the file. Throws exception in case of failure.</p>

<p><tt>remove_file_if_exists()</tt> returns <tt>false</tt> instead of throwing
if the file doesn't exist.</p>

<p><tt>remove_file_nt()</tt> doestn't throw any exceptions at all,
<tt>false</tt> is returned  in case of failure.</p>




<h3 id="copy_file">
<span class="h3_num">2.13.6</span><tt>copy_file()</tt>, <tt>copy_file_if_exists()</tt>,
<tt>copy_file_replace()</tt>, <tt>copy_file_replace_if_exists()</tt>
</h3>


<pre class="code">
void copy_file(
    const char *src_path, const char *dest_path, bool replace = false);
void copy_file(
    const std::string &amp;src_path, const std::string &amp;dest_path,
    bool replace = false);

bool copy_file_if_exists(
    const char *src_path, const char *dest_path, bool replace = false);
bool copy_file_if_exists(
    const std::string &amp;src_path, const std::string &amp;dest_path,
    bool replace = false);

void copy_file_replace(
    const char *src_path, const char *dest_path);
void copy_file_replace(
    const std::string &amp;src_path, const std::string &amp;dest_path);

bool copy_file_replace_if_exists(
    const char *src_path, const char *dest_path);
bool copy_file_replace_if_exists(
    const std::string &amp;src_path, const std::string &amp;dest_path);
</pre>

<p>Creates a new file <tt>dest_path</tt> which is a copy of a file
<tt>src_path</tt>. If the new file exists and <tt>replace == false</tt>,
the functions fail.</p>

<p><tt>copy_file_if_exists()</tt> returns <tt>false</tt> instead of throwing
if <tt>src_path</tt> doesn't exist.</p>

<p><tt>copy_file_replace()</tt> is the same as <tt>copy_file(..., true)</tt>.
</p>

<p><tt>copy_file_replace_if_exists()</tt> is the same as
<tt>copy_file_if_exists(..., true)</tt>.</p>




<h3 id="move_file">
<span class="h3_num">2.13.7</span><tt>move_file()</tt>, <tt>move_file_if_exists()</tt>,
<tt>move_file_replace()</tt>, <tt>move_file_replace_if_exists()</tt>
</h3>


<pre class="code">
void move_file(const char *src_path, const char *dest_path);
void move_file(const std::string &amp;src_path, const std::string &amp;dest_path);

bool move_file_if_exists(const char *src_path, const char *dest_path);
bool move_file_if_exists(
    const std::string &amp;src_path, const std::string &amp;dest_path);

void move_file_replace(const char *src_path, const char *dest_path);
void move_file_replace(
    const std::string &amp;src_path, const std::string &amp;dest_path);

bool move_file_replace_if_exists(
    const char *src_path, const char *dest_path);
bool move_file_replace_if_exists(
    const std::string &amp;src_path, const std::string &amp;dest_path);
</pre>

<p>Moves a file <tt>src_path</tt> to new location specified by
<tt>dest_path</tt>.</p>

<p>The functions with <tt>_replace</tt> suffix overwrite existing destination
file if exists, others - fail in such case.</p>

<p><tt>move_file_if_exists()</tt> returns <tt>false</tt> instead of throwing
if <tt>src_path</tt> doesn't exist.</p>




<h3 id="rename_file">
<span class="h3_num">2.13.8</span><tt>rename_file()</tt>, <tt>rename_file_if_exists()</tt>,
    <tt>rename_file_replace()</tt>, <tt>rename_file_replace_if_exists()</tt>
</h3>


<pre class="code">
void rename_file(const char *src_name, const char *dest_name);
void rename_file(const std::string &amp;src_name, const std::string &amp;dest_name);

bool rename_file_if_exists(const char *src_name, const char *dest_name);
bool rename_file_if_exists(
    const std::string &amp;src_name, const std::string &amp;dest_name);

void rename_file_replace(const char *src_name, const char *dest_name);
void rename_file_replace(
    const std::string &amp;src_name, const std::string &amp;dest_name);

bool rename_file_replace_if_exists(
    const char *src_name, const char *dest_name);
bool rename_file_replace_if_exists(
    const std::string &amp;src_name, const std::string &amp;dest_name);
</pre>

<p>Renames a file <tt>src_path</tt> to <tt>dest_path</tt>. The new path
has to be located within the same physical filesystem.</p>

<p>As opposed to <tt>std::rename()</tt>, the functions without
<tt>_replace</tt> suffix fail if <tt>dest_path</tt> exists.</p>

<p><tt>rename_file_if_exists()</tt> returns <tt>false</tt> instead of throwing
if <tt>src_path</tt> doesn't exist.</p>




<h3 id="file_size">
<span class="h3_num">2.13.9</span><tt>file_size()</tt>
</h3>


<pre class="code">
uintmax_t file_size(const char *path);
uintmax_t file_size(const std::string &amp;path);
</pre>

<p>Returns file size in bytes.</p>






<h2 id="iterator.h">
<span class="h2_num">2.14</span><tt>__vic/iterator.h</tt>
</h2>


<p>Iterators-related utilities.</p>


<h3 id="begin-array">
<span class="h3_num">2.14.1</span><tt>begin(T[])</tt>, <tt>end(T[])</tt>, <tt>cbegin(T[])</tt>,
<tt>cend(T[])</tt>
</h3>


<pre class="code">
template&lt;class T, size_t N&gt; constexpr T *begin(T (&amp;arr)[N]);
template&lt;class T, size_t N&gt; constexpr T *end(T (&amp;arr)[N]);

template&lt;class T, size_t N&gt; constexpr const T *cbegin(T (&amp;arr)[N]);
template&lt;class T, size_t N&gt; constexpr const T *cend(T (&amp;arr)[N]);
</pre>

<p>Return a pointer to the beginning and past-the-end of the array.</p>

<div class="section">Example</div>
<pre class="code">
int vals[] = { 1, 2, 3 };
std::list&lt;int&gt; lst(__vic::begin(vals), __vic::end(vals));
assert(lst.size() == 3);
</pre>





<h3 id="advance">
<span class="h3_num">2.14.2</span><tt>advance()</tt>
</h3>


<pre class="code">
template&lt;class Iter&gt;
void advance(Iter &amp;it, Iter end, size_t n);
</pre>

<p>A counterpart of <tt>std::advance()</tt> but differs in parameters and
behaviour:</p>
<ol>
<li>Allows only forward movement (<tt>++</tt>),</li>
<li>Checks the range bounds. Returns immediately if <tt>end</tt> is
        reached.</li>
</ol>




<h3 id="next">
<span class="h3_num">2.14.3</span><tt>next()</tt>, <tt>prev()</tt>
</h3>


<pre class="code">
template&lt;class ForwardIterator&gt;
ForwardIterator next(ForwardIterator it);

template&lt;class ForwardIterator&gt;
ForwardIterator next(ForwardIterator it, size_t n);

template&lt;class BidirectionalIterator&gt;
BidirectionalIterator prev(BidirectionalIterator it);

template&lt;class BidirectionalIterator&gt;
BidirectionalIterator prev(BidirectionalIterator it, size_t n);
</pre>

<p><tt>next()</tt> returns an iterator advanced by <tt>n</tt> positions.
<tt>prev()</tt> does the same but in reverse order. As opposed to C++11 STL
functions of the same name, the offset cannot be negative. The versions with
single parameter just call <tt>++it</tt>/<tt>--it</tt> and return the result.
</p>

<div class="section">Example</div>
<pre class="code">
template&lt;class Container&gt;
void f(const Container &amp;c)
{
    // Begin a traversal starting from the second element
    // v.begin() + 1 works only with RandomAccessIterator
    // ++v.begin() may cause a compile error
    for(auto it = __vic::next(c.begin()); it != c.end(); ++it) ...;
}
</pre>







<h2 id="logger.h">
<span class="h2_num">2.15</span><tt>__vic/logger.h</tt>
</h2>


<h3 id="logger">
<span class="h3_num">2.15.1</span><tt>logger</tt>
</h3>


<pre class="code">
class logger : private non_copyable
{
public:
    enum class severity : unsigned char
    {
        trace,
        debug,
        info,
        notice,
        warning,
        error,
        fatal
    };
    using severity_t = severity; // use this alias as a type name
    struct output
    {
        virtual void publish_record(severity_t , const char * , size_t ) = 0;
    protected:
        ~output() = default;
    };
    class settings_t
    {
        struct output &amp;output() const;
        severity_t level() const;
    };
    class record;

    explicit logger(output &amp;out, severity_t = severity::info);
    explicit logger(settings_t s);
    ~logger();

    severity_t level() const;
    void level(severity_t new_level);
    settings_t settings() const;
    output &amp;reset_output(output &amp;out);
    output &amp;get_output();
    const output &amp;get_output() const;

    static constexpr size_t min_buffer_size = ...;
    void shrink_buffer(size_t limit);

    void message(severity_t severity, const char *msg, size_t msg_len);
#if __cpp_lib_string_view // C++17
    void message(severity_t severity, std::string_view msg);

    void trace(std::string_view msg);
    void debug(std::string_view msg);
    void info(std::string_view msg);
    void notice(std::string_view msg);
    void warning(std::string_view msg);
    void error(std::string_view msg);
    void fatal(std::string_view msg);
#else // until C++17
    void message(severity_t severity, const char *msg);
    void message(severity_t severity, const std::string &amp;msg);

    void trace(const char *msg);
    void debug(const char *msg);
    void info(const char *msg);
    void notice(const char *msg);
    void warning(const char *msg);
    void error(const char *msg);
    void fatal(const char *msg);

    void trace(const std::string &amp;msg);
    void debug(const std::string &amp;msg);
    void info(const std::string &amp;msg);
    void notice(const std::string &amp;msg);
    void warning(const std::string &amp;msg);
    void error(const std::string &amp;msg);
    void fatal(const std::string &amp;msg);
#endif
    record trace();
    record debug();
    record info();
    record notice();
    record warning();
    record error();
    record fatal();

    bool trace_visible() const;
    bool debug_visible() const;
    bool info_visible() const;
    bool notice_visible() const;
    bool warning_visible() const;
    bool error_visible() const;
    bool fatal_visible() const;
};
class logger::record
{
public:
    record(logger &amp;log, severity_t sev);
    ~record();

    record append(const char *str, size_t str_len);

    template&lt;class T&gt; record operator&lt;&lt;(const T &amp;v);
};
const char *to_string(logger::severity_t s);
#if __cpp_lib_string_view // C++17
constexpr std::string_view to_string_view(logger::severity s);
#endif
</pre>

<p>Logging front-end. Provides building of the
log records using operator <tt>&lt;&lt;</tt>, like <tt>iostream</tt>. Each log
record has the associated severity. The logger itself can filter out the
records by severity. There are 7 predefined levels of the severity (in
ascending order):</p>
<ol>
<li>TRACE - detailed debug,</li>
<li>DEBUG - debug,</li>
<li>INFO - informational,</li>
<li>NOTICE - normal but significant event,</li>
<li>WARNING - insignificant error or suspicious situation,</li>
<li>ERROR - severe error but the application can continue,</li>
<li>FATAL - critical unrecoverable error, the application can't
        continue.</li>
</ol>

<p>INFO is the default logging level but any other can be chosen. If severity
of the log message (record) is below the logging level, it will be ignored and
will not be published in the log's output.</p>

<p>For creation of messages with the required severity, the set of functions
with the same name as the severity is available. For instance <tt>info()</tt>
for INFO messages. Or alternatively the universal function <tt>message()</tt>
can be used, in which the severity is the argument. Usually the specific
functions should be used.</p>

<p>There are two ways of logging. The first is plain and common:</p>
<pre class="code">
log.trace("Trace message");
log.debug("Debug message");
log.info("Info message");
log.notice("Notice");
log.warning("Warning");
log.error("Recoverable error");
log.fatal("Fatal error");
</pre>

<p>The second is slightly more complex but provides more capabilities:</p>
<pre class="code">
log.error() &lt;&lt; "Cannot open file " &lt;&lt; filename &lt;&lt; '!';
log.warning() &lt;&lt; "Loop iteration no " &lt;&lt; i;
</pre>

<p>The call without parameters creates the object of type
<tt>logger::record</tt> with the corresponding severity. Futher, the message
is formed using operators <tt>&lt;&lt;</tt>. The message will be output to the
log at the end of the full-expression (term from the Standard).</p>

<p>If the message can't or shouldn't be formed with a single expression,
the named object of type <tt>logger::record</tt> has to be created, and parts
of the message have to be written to it. The resulting message will be output
to the log by it's destructor:</p>
<pre class="code">
{
    logger::record rec = log.info(); // Begin new record
    rec &lt;&lt; "List elements: ";
    for(auto el : list) rec &lt;&lt; el &lt;&lt; ", ";
    // Constructed record will be printed to the log when the block exits
}
</pre>

<div>
<u><b>Note</b></u>: In order to optimize the performace, use the plain functional notation
when the complete message is available:</div>
<pre class="code">
log.info("Message");
// but not
log.info() &lt;&lt; "Message";
</pre>

<p>Output of the records with the severities DEBUG and TRACE is usually disabled.
Such records will not be published in the log but the program will waste
time to format it. Therefore before creating any debug message using operator
<tt>&lt;&lt;</tt> one should check if debug is enabled using
<tt>debug_visible()</tt> or <tt>trace_visible()</tt> call:</p>
<pre class="code">
if(log.debug_visible())
    log.debug() &lt;&lt; ...; // build the message
</pre>
<p>This advice doesn't cover plain calls <tt>debug(msg)</tt> and
<tt>trace(msg)</tt>, which have a prepared message already and don't perform any
formatting.</p>

<p>To use <tt>logger</tt> one has to implement abstract base class
<tt>logger::output</tt> (override <tt>publish_record()</tt>). The implementation
has to output the passed record somewhere, e.g. to file, terminal or DB. The
output specified during <tt>logger</tt> construction can be replaced later
using <tt>reset_output()</tt>.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">severity::trace</pre>
<pre class="prototype">severity::debug</pre>
<pre class="prototype">severity::info</pre>
<pre class="prototype">severity::notice</pre>
<pre class="prototype">severity::warning</pre>
<pre class="prototype">severity::error</pre>
<pre class="prototype">severity::fatal</pre>
<blockquote>







<p>Severity constants. Use this form for both C++11 and C++98 mode.</p>
</blockquote>
</div>

<div>
<pre class="prototype">typename severity_t</pre>
<blockquote>

<p>Use this identifier as a type name if your code has to be C++98-compatible.
Since C++11 it is just a synonym for <tt>severity</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">class output</pre>
<blockquote>

<p>Logging back-end interface.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void output::publish_record(severity_t sev, const char *buf, size_t buf_len)</pre>
<blockquote>

<p>The implementaion of this pure virtual function has to output the content of
<tt>buf</tt> to the log as one record. <tt>buf_len</tt> is the length of
<tt>buf</tt>. The function is always called with <tt>sev &gt;= level()</tt>.
The implementation can rely on it.</p>
</blockquote>
</div>

<div>
<pre class="prototype">class settings_t</pre>
<blockquote>

<p>Keeps the logger settings: logging level and reference to output
(<tt>level()</tt> + <tt>get_output()</tt>).</p>
</blockquote>
</div>

<div>
<pre class="prototype">explicit logger(output &amp;out, severity_t level = severity::info)</pre>
<blockquote>

<p>Creates logger with the specified output and logging level. The output object
must outlive the logger object!</p>
<div>
<u>Postcondition</u>: <tt>this-&gt;level() == level &amp;&amp; &amp;this-&gt;get_output() == &amp;out</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">explicit logger(settings_t s)</pre>
<blockquote>

<p>Creates logger using the specified settings.</p>
</blockquote>
</div>

<div>
<pre class="prototype">severity_t level() const</pre>
<blockquote>

<p>Returns current logging level.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void level(severity_t new_level)</pre>
<blockquote>

<p>Sets the logging level.</p>
<div>
<u>Postcondition</u>: <tt>level() == new_level</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">settings_t settings() const</pre>
<blockquote>

<p>Returns current logging settings.</p>
</blockquote>
</div>

<div>
<pre class="prototype">output &amp;reset_output(output &amp;out)</pre>
<blockquote>

<p>Sets new output and returns the previous one.</p>
<div>
<u>Postcondition</u>: <tt>&amp;get_output() == &amp;out</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">output &amp;get_output()</pre>
<pre class="prototype">const output &amp;get_output() const</pre>
<blockquote>


<p>Returns reference to the current logging output.</p>
</blockquote>
</div>

<div>
<pre class="prototype">static constexpr size_t min_buffer_size</pre>
<blockquote>

<p>Minimal size of the internal buffer in bytes.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void shrink_buffer(size_t limit)</pre>
<blockquote>

<p>Sets the internal buffer size to <tt>min_buffer_size</tt> if it is more than
<tt>limit</tt> bytes. Allows to restrict the buffer growth when long records
are formed.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void message(severity_t severity, const char *msg, size_t msg_len)</pre>
<pre class="prototype">void message(severity_t severity, std::string_view msg) <span class="sign">[C++17]</span></pre>
<pre class="prototype">void message(severity_t severity, const char *msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void message(severity_t severity, const std::string &amp;msg) <span class="sign">[until C++17]</span></pre>
<blockquote>




<p>Writes the message with the specified severity.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void trace(std::string_view msg) <span class="sign">[C++17]</span></pre>
<pre class="prototype">void trace(const char *msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void trace(const std::string &amp;msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void debug(std::string_view msg) <span class="sign">[C++17]</span></pre>
<pre class="prototype">void debug(const char *msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void debug(const std::string &amp;msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void info(std::string_view msg) <span class="sign">[C++17]</span></pre>
<pre class="prototype">void info(const char *msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void info(const std::string &amp;msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void notice(std::string_view msg) <span class="sign">[C++17]</span></pre>
<pre class="prototype">void notice(const char *msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void notice(const std::string &amp;msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void warning(std::string_view msg) <span class="sign">[C++17]</span></pre>
<pre class="prototype">void warning(const char *msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void warning(const std::string &amp;msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void error(std::string_view msg) <span class="sign">[C++17]</span></pre>
<pre class="prototype">void error(const char *msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void error(const std::string &amp;msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void fatal(std::string_view msg) <span class="sign">[C++17]</span></pre>
<pre class="prototype">void fatal(const char *msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void fatal(const std::string &amp;msg) <span class="sign">[until C++17]</span></pre>
<blockquote>





















<p>Writes the message with the corresponding severity.</p>
</blockquote>
</div>

<div>
<pre class="prototype">logger::record trace()</pre>
<pre class="prototype">logger::record debug()</pre>
<pre class="prototype">logger::record info()</pre>
<pre class="prototype">logger::record notice()</pre>
<pre class="prototype">logger::record warning()</pre>
<pre class="prototype">logger::record error()</pre>
<pre class="prototype">logger::record fatal()</pre>
<blockquote>







<p>Creates new record with the corresponding severity. Message parts can be
added using operators <tt>&lt;&lt;</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool trace_visible() const</pre>
<pre class="prototype">bool debug_visible() const</pre>
<pre class="prototype">bool info_visible() const</pre>
<pre class="prototype">bool notice_visible() const</pre>
<pre class="prototype">bool warning_visible() const</pre>
<pre class="prototype">bool error_visible() const</pre>
<pre class="prototype">bool fatal_visible() const</pre>
<blockquote>







<p>Returns <tt>true</tt> if a record with the corresponding severity will be
published. Usage of this functions enables to avoid formatting of the
messages which eventually will not be published.</p>
</blockquote>
</div>

<div>
<pre class="prototype">record::record(logger &amp;log, severity_t sev)</pre>
<blockquote>

<p>Creates the log record with the specified severity. Usually the <tt>logger</tt>'s
functions like <tt>info()</tt> without parameters should be used instead.</p>
</blockquote>
</div>

<div>
<pre class="prototype">record::~record()</pre>
<blockquote>

<p>Outputs the constructed record to the log.</p>
</blockquote>
</div>

<div>
<pre class="prototype">record record::append(const char *str, size_t str_len)</pre>
<blockquote>

<p>Appends the string to the message.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class T&gt; record record::operator&lt;&lt;(const T &amp;v)</pre>
<blockquote>

<p>The set of inserters for various data types. Call <tt>sb &lt;&lt; v</tt>
where type of <tt>sb</tt> is <tt>__vic::string_buffer</tt>.</p>
</blockquote>
</div>



<div class="section">Free functions</div>

<div>
<pre class="prototype">const char *to_string(logger::severity_t s)</pre>
<pre class="prototype">constexpr std::string_view to_string_view(logger::severity s) <span class="sign">[C++17]</span></pre>
<blockquote>


<p>Returns text label for the specified severity that can be printed to the
log. For example, <tt>"DEBUG"</tt> will be returned for
<tt>severity::debug</tt>.</p>
</blockquote>
</div>



<div class="section">Example</div>

<pre class="code">
/////////////////////////////////////////////////////////////////////////////
// Output messages to std::clog with the severity label
class coutput : public __vic::logger::output
{
public:
    void publish_record(__vic::logger::severity_t s,
                            const char *rec, size_t rec_n)
    {
        std::clog &lt;&lt; to_string(s) &lt;&lt; ": ";
        std::clog.write(rec, rec_n) &lt;&lt; std::endl;
    }
};
/////////////////////////////////////////////////////////////////////////////

int main()
{
    coutput log_output:
    __vic::logger log(log_output, __vic::logger::severity::debug);

    log.info("Application is started");

    for(int i = 0; i &lt; 5; i++)
        log.debug() &lt;&lt; "Loop i = " &lt;&lt; i;

    log.warning("Application end");
}
</pre>

<p>Output:</p>

<pre class="code">
INFO: Application is started
DEBUG: Loop i = 0
DEBUG: Loop i = 1
DEBUG: Loop i = 2
DEBUG: Loop i = 3
DEBUG: Loop i = 4
WARNING: Application end
</pre>







<h2 id="memory.h">
<span class="h2_num">2.16</span><tt>__vic/memory.h</tt>
</h2>


<p>Memory-related utilities.</p>


<h3 id="load_unaligned">
<span class="h3_num">2.16.1</span><tt>load_unaligned()</tt>
</h3>


<pre class="code">
template&lt;class T&gt;
T load_unaligned(const void *p);
</pre>

<p>Load value from potentially unaligned address without causing bus error
(<tt>SIGBUS</tt>).</p>

<div class="section">Example</div>
<pre class="code">
const void *p = ...;
// int data = *static_cast&lt;const int *&gt;(p); // potential bus error
int data = __vic::load_unaligned&lt;int&gt;(p);
</pre>





<h3 id="store_unaligned">
<span class="h3_num">2.16.2</span><tt>store_unaligned()</tt>
</h3>


<pre class="code">
template&lt;class T&gt;
void store_unaligned(void *p, T v);
</pre>

<p>Store value to potentially unaligned address without causing bus error
(<tt>SIGBUS</tt>).</p>

<div class="section">Example</div>
<pre class="code">
void *p = ...;
// *static_cast&lt;int *&gt;(p) = 123; // potential bus error
__vic::store_unaligned(p, 123);
</pre>







<h2 id="mutex.h">
<span class="h2_num">2.17</span><tt>__vic/mutex.h</tt>
</h2>



<h3 id="mutex">
<span class="h3_num">2.17.1</span><tt>mutex</tt>
</h3>


<pre class="code">
class mutex : private non_copyable
{
public:
    mutex();
    ~mutex();

    void lock();
    bool try_lock();
    bool unlock() noexcept;
};
</pre>

<p>Plain non-recursive mutex.</p>

<div class="section">Usage notes</div>
<p>In most cases explicit usage of <tt>lock()</tt> and <tt>unlock()</tt> should
be avoided. Use class <a href="#mutex_lock"><tt>mutex_lock</tt></a> to manage locks instead. It provides
exception safety and it's handy for usage.</p>
<p>In C++11 mode <tt>std::mutex</tt> can be a better alternative.</p>


<div class="section">Class members</div>

<div>
<pre class="prototype">mutex()</pre>
<blockquote>

<p>Creates unlocked mutex.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~mutex()</pre>
<blockquote>

<p>Destroys the mutex.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void lock()</pre>
<blockquote>

<p>Acquires the mutex. Waits until released if acquired by other
thread at the moment.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool try_lock()</pre>
<blockquote>

<p>Tries to acquire the mutex. Immediately returns <tt>false</tt> if it's
already acquired by another thread, without waiting.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool unlock() noexcept</pre>
<blockquote>

<p>Releases the mutex acquired before. In some cases can return <tt>false</tt>
in case of error, but in general error detection is not guaranteed.</p>
</blockquote>
</div>



<div class="section">Example</div>
<p>See <a href="#mutex_lock"><tt>mutex_lock</tt></a>.</p>





<h3 id="mutex_lock">
<span class="h3_num">2.17.2</span><tt>mutex_lock</tt>
</h3>


<pre class="code">
class mutex_lock : private non_copyable
{
public:
    enum adopt_t { adopt };

    explicit mutex_lock(mutex &amp;mtx);
    mutex_lock(mutex &amp;mtx, adopt_t);
    ~mutex_lock();
};
</pre>

<p>Manages the lock on a mutex. The lock exists while the object is alive.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">adopt</pre>
<blockquote>

<p>Constructor tag, suppresses the mutex acquisition.</p>
</blockquote>
</div>

<div>
<pre class="prototype">explicit mutex_lock(mutex &amp;mtx)</pre>
<blockquote>

<p>Acquires <tt>mtx</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~mutex_lock()</pre>
<blockquote>

<p>Releases <tt>mtx</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">mutex_lock(mutex &amp;mtx, adopt_t)</pre>
<blockquote>

<p>Adopts already acquired <tt>mtx</tt>. See the example.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
// Typical usage
__vic::mutex mtx;
void reentrant_function()
{
    __vic::mutex_lock lock(mtx);
    // Critical section code until the end of the block
    ...
}

// Usage of non-acquiring constructor
if(mtx.try_lock()) // Try to acquire the mutex
{
    // The mutex has been successfully acquired
    __vic::mutex_lock lock(mtx, __vic::mutex_lock::adopt);
    // Critical section code until the end of the block
    ...
}
else
{
    // The mutex is acquired by another thread
    ...
}
</pre>







<h2 id="packon.h">
<span class="h2_num">2.18</span><tt>__vic/packon.h</tt> &amp; <tt>__vic/packoff.h</tt>
</h2>


<p>Inclusion of the first file turns off struct members alignment. In other
words, turns on "structures packing" - size of the struct is strictly a sum of
its members sizes. Inclusion of the second one restores the default alignment.
So that the pair of <tt>#include</tt> directives forms a section in the source
file where structs alignment is disabled.</p>

<div>
<u><b>Note</b></u>: Each <tt>#include&lt;__vic/packon.h&gt;</tt> must have the corresponding
<tt>#include&lt;__vic/packoff.h&gt;</tt>.</div>

<div class="section">Example</div>
<pre class="code">
struct unpacked
{
    bool f1;
    int f2;
};
static_assert(sizeof(unpacked) &gt;= sizeof(bool) + sizeof(int),
    "Total struct size can exceed the sum of members sizes");

#include&lt;__vic/packon.h&gt; // alignment disabled starting from here

struct packed
{
    bool f1;
    int f2;
};
static_assert(sizeof(packed) == sizeof(bool) + sizeof(int),
    "Total struct size is exactly the sum of members sizes");

#include&lt;__vic/packoff.h&gt; // alignment enabled again
</pre>




<h2 id="readers">
<span class="h2_num">2.19</span><tt>__vic/readers/</tt>
</h2>



<h3 id="reader-concept">
<span class="h3_num">2.19.1</span><tt>Reader</tt> concept</h3>


<pre class="code">
template&lt;class ElementT&gt;
class <span class="nonterminal">Reader</span>
{
public:
    Reader(Reader &amp;&amp;o); or Reader(const Reader &amp;o);
    bool read(ElementT &amp;v); // throws on errors
};
</pre>

<p>A concept used by the library algorithms to read logical sequence of elements
of type <tt>ElementT</tt> element by element. It is a generalization and rework
of the <tt>InputIterator</tt> concept. In particular it handles streams,
NULL-terminated strings and other sequences where <tt>end</tt>-iterator is
meaningless or expensive to obtain better. At the same time, a traditional
[<tt>begin</tt>,<tt>end</tt>) pair of iterators is just a particular case and
fully and well handled by <tt>__vic::iterator_reader</tt> adapter.</p>

<p>When the particular class meets the requirements of this concept for some
<tt>ElementT = T</tt> it is said <b>to model</b> the <tt>Reader&lt;T&gt;</tt>
concept.</p>

<p>Each instance of the class has to be move- or copy-constructible.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">bool read(ElementT &amp;v)</pre>
<blockquote>

<p>Attempts to get the next element of the sequence. Returns <tt>true</tt> and
places the value to <tt>v</tt> on success. Returns <tt>false</tt> if no element
available (EOF). Throws an exception in other cases.</p>
</blockquote>
</div>






<h3 id="iterator_reader">
<span class="h3_num">2.19.2</span><tt>iterator_reader</tt>
</h3>


<pre class="code">
#include&lt;__vic/readers/iterator.h&gt;

template&lt;class InputIterator,
         class T = typename std::iterator_traits&lt;InputIterator&gt;::value_type&gt;
class iterator_reader
{
public:
    iterator_reader(InputIterator begin, InputIterator end);
    bool read(T &amp;v);
    InputIterator position() const;
};

template&lt;class InputIterator&gt; iterator_reader&lt;InputIterator&gt;
make_iterator_reader(InputIterator begin, InputIterator end);

template&lt;class T, class InputIterator&gt; iterator_reader&lt;InputIterator,T&gt;
make_iterator_reader_for(InputIterator begin, InputIterator end);
</pre>

<p>An adapter for a traditional [<tt>begin</tt>,<tt>end</tt>) pair of iterators.
</p>

<p>Additional <tt>position()</tt> function returns the current iterator
position.</p>

<p>Can be created using constructor or one of <tt>make_...</tt> functions.</p>




<h3 id="iterator_reader_n">
<span class="h3_num">2.19.3</span><tt>iterator_reader_n</tt>
</h3>


<pre class="code">
#include&lt;__vic/readers/iterator.h&gt;

template&lt;class InputIterator,
         class T = typename std::iterator_traits&lt;InputIterator&gt;::value_type&gt;
class iterator_reader_n
{
public:
    iterator_reader_n(InputIterator begin, size_t n);
    bool read(T &amp;v);
    InputIterator position() const;
};

template&lt;class InputIterator&gt; iterator_reader_n&lt;InputIterator&gt;
make_iterator_reader_n(InputIterator begin, size_t n);

template&lt;class T, class InputIterator&gt; iterator_reader_n&lt;InputIterator,T&gt;
make_iterator_reader_n_for(InputIterator begin, size_t n);
</pre>

<p>An adapter for iterator + elements counter.</p>

<p>Additional <tt>position()</tt> function returns the current iterator
position.</p>

<p>Can be created using constructor or one of <tt>make_...</tt> functions.</p>




<h3 id="container_reader">
<span class="h3_num">2.19.4</span><tt>container_reader</tt>
</h3>


<pre class="code">
#include&lt;__vic/readers/container.h&gt;

template&lt;class Cont, class T = typename Cont::value_type&gt;
class container_reader
{
public:
    explicit container_reader(const Cont &amp;c);
    bool read(T &amp;v);
    typename Cont::const_iterator position() const;
};

template&lt;class Cont&gt;
container_reader&lt;Cont&gt; make_container_reader(const Cont &amp;c);

template&lt;class T, class Cont&gt;
container_reader&lt;Cont,T&gt; make_container_reader_for(const Cont &amp;c);
</pre>

<p>An adapter for STL-style container classes with <tt>begin()</tt> and
<tt>end()</tt> members.</p>

<p>Additional <tt>position()</tt> function returns the current iterator
position.</p>

<p>Can be created using constructor or one of <tt>make_...</tt> functions.</p>




<h3 id="cstring_reader">
<span class="h3_num">2.19.5</span><tt>cstring_reader</tt>
</h3>


<pre class="code">
#include&lt;__vic/readers/cstring.h&gt;

template&lt;class charT&gt;
class basic_cstring_reader
{
public:
    explicit basic_cstring_reader(const charT *s);
    bool read(charT &amp;ch);
    const charT *position() const;
};

template&lt;&gt;
class basic_cstring_reader&lt;char&gt;
{
public:
    explicit basic_cstring_reader(const char *s);
    bool read(char &amp;ch);
    bool read(unsigned char &amp;ch);
    const char *position() const;
};
using cstring_reader = basic_cstring_reader&lt;char&gt;;

template&lt;class charT&gt;
basic_cstring_reader&lt;charT&gt; make_cstring_reader(const charT *s);
</pre>

<p>An adapter for NULL-terminated C-style strings.</p>

<p>Additional <tt>position()</tt> function returns the current pointer
position.</p>

<p><tt>char</tt> specialization models <tt>Reader&lt;unsigned char&gt;</tt> as
well as <tt>Reader&lt;char&gt;</tt>.</p>

<p>Can be created using constructor or <tt>make_...</tt> function.</p>




<h3 id="string_reader">
<span class="h3_num">2.19.6</span><tt>string_reader</tt>
</h3>


<pre class="code">
#include&lt;__vic/readers/string.h&gt;

template&lt;
    class charT,
    class Tr = std::char_traits&lt;charT&gt;,
    class Al = std::allocator&lt;charT&gt;
&gt;
class basic_string_reader
{
public:
    explicit basic_string_reader(const std::basic_string&lt;charT,Tr,Al&gt; &amp;s);
    bool read(charT &amp;ch);
    const charT *position() const;
};

template&lt;class Tr, class Al&gt;
class basic_string_reader&lt;char,Tr,Al&gt;
{
public:
    explicit basic_string_reader(const std::basic_string&lt;char,Tr,Al&gt; &amp;s);
    bool read(char &amp;ch);
    bool read(unsigned char &amp;ch);
    const char *position() const;
};
using string_reader = basic_string_reader&lt;char&gt;;

template&lt;class charT, class Tr, class Al&gt;
basic_string_reader&lt;charT,Tr,Al&gt;
    make_string_reader(const std::basic_string&lt;charT,Tr,Al&gt; &amp;s);
</pre>

<p>An adapter for <tt>std::basic_string</tt>.</p>

<p>Additional <tt>position()</tt> function returns the current pointer
position.</p>

<p><tt>char</tt> specialization models <tt>Reader&lt;unsigned char&gt;</tt> as
well as <tt>Reader&lt;char&gt;</tt>.</p>

<p>Can be created using constructor or <tt>make_...</tt> function.</p>




<h3 id="cstream_reader">
<span class="h3_num">2.19.7</span><tt>cstream_reader</tt>
</h3>


<pre class="code">
#include&lt;__vic/readers/cstream.h&gt;

class cstream_reader
{
public:
    explicit cstream_reader(std::FILE *fp);
    bool read(char &amp;ch) { return __vic::read(fp, ch); }
    bool read(unsigned char &amp;ch) { return __vic::read(fp, ch); }
};

cstream_reader make_cstream_reader(std::FILE *fp);
</pre>

<p>Models <tt>Reader&lt;char&gt;</tt> and <tt>Reader&lt;unsigned char&gt;</tt> for
<tt>std::FILE</tt>.</p>

<p>Can be created using constructor or <tt>make_...</tt> function.</p>






<h2 id="readonly_cstring.h">
<span class="h2_num">2.20</span><tt>__vic/readonly_cstring.h</tt>
</h2>


<h3 id="readonly_cstring">
<span class="h3_num">2.20.1</span><tt>readonly_cstring</tt>
</h3>


<pre class="code">
class readonly_cstring
{
public:
    readonly_cstring();
    readonly_cstring(const char *str);
    readonly_cstring(const char *begin, const char *end);
    readonly_cstring(const char *chars, size_t n);
    readonly_cstring(const readonly_cstring &amp;str);
    ~readonly_cstring() noexcept;

    // BEGIN C++11
    readonly_cstring(readonly_cstring &amp;&amp;str) noexcept;
    readonly_cstring &amp;operator=(readonly_cstring &amp;&amp;str) noexcept;
    // END C++11

    readonly_cstring &amp;operator=(const char *str);
    readonly_cstring &amp;operator=(const readonly_cstring &amp;str);
    readonly_cstring &amp;assign(const char *begin, const char *end);
    readonly_cstring &amp;assign(const char *chars, size_t n);

    bool empty() const;
    const char *c_str() const;
    operator const char*() const;

    char *reserve(size_t n);
    void swap(readonly_cstring &amp;str) noexcept;
};

int compare(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2);
int compare(const readonly_cstring &amp;s1, const char *s2);
int compare(const char *s1, const readonly_cstring &amp;s2);

bool operator==(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2);
bool operator!=(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2);
bool operator&lt;(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2);
bool operator&gt;(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2);
bool operator&lt;=(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2);
bool operator&gt;=(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2);

bool operator==(const readonly_cstring &amp;s1, const char *s2);
bool operator!=(const readonly_cstring &amp;s1, const char *s2);
bool operator&lt;(const readonly_cstring &amp;s1, const char *s2);
bool operator&gt;(const readonly_cstring &amp;s1, const char *s2);
bool operator&lt;=(const readonly_cstring &amp;s1, const char *s2);
bool operator&gt;=(const readonly_cstring &amp;s1, const char *s2);

bool operator==(const char *s1, const readonly_cstring &amp;s2);
bool operator!=(const char *s1, const readonly_cstring &amp;s2);
bool operator&lt;(const char *s1, const readonly_cstring &amp;s2);
bool operator&gt;(const char *s1, const readonly_cstring &amp;s2);
bool operator&lt;=(const char *s1, const readonly_cstring &amp;s2);
bool operator&gt;=(const char *s1, const readonly_cstring &amp;s2);

void swap(readonly_cstring &amp;s1, readonly_cstring &amp;s2) noexcept;
</pre>

<p>The simple non-mutable null-terminated string class with automatic memory
management. Has simple and predictable structure that can be useful when
ABI compatibility/stability is required or when usage of <tt>std::string</tt>
is objectionable for some reason. The functionality provided by the class is
also minimal. It provides string copying and storing and read access to it.
One cannot modify string parts - only replace the whole value.</p>

<p>If one need to store a string value in a class, usage of this class may be a
good choice. It's easier-to-use, more clear and safer than array of chars
(<tt>char[]</tt>) and can be more efficient than <tt>std::string</tt>,
though, of course, less universal. If modifications of the string parts are
expected, usage of another string class should be considered, for instance,
<tt>__vic::string_buffer</tt>. Class <tt>readonly_cstring</tt> is not designed
for such purposes.</p>

<div class="section">Guarantees provided by the class design</div>
<ul>
<li>Null pointer value is treated as an empty string.</li>
<li>Cast to C-string (<tt>const char *</tt>) always returns valid
        pointer, never <tt>nullptr</tt>.</li>
<li>For each string value, exact amount of memory is allocated. No extra
        memory reserved.</li>
<li>Class contains single data member - pointer to the holded string,
        so the total object's size is likely one pointer.</li>
</ul>


<div class="section">Class members</div>

<div>
<pre class="prototype">readonly_cstring()</pre>
<blockquote>

<p>Creates an empty string.</p>
<div>
<u>Postcondition</u>: <tt>empty() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">readonly_cstring(const char *str)</pre>
<pre class="prototype">readonly_cstring(const readonly_cstring &amp;str)</pre>
<blockquote>


<p>Creates a copy of <tt>str</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">readonly_cstring(const char *begin, const char *end)</pre>
<pre class="prototype">readonly_cstring(const char *chars, size_t n)</pre>
<blockquote>


<p>Creates a string from characters range.</p>
</blockquote>
</div>

<div>
<pre class="prototype">readonly_cstring &amp;operator=(const char *str)</pre>
<pre class="prototype">readonly_cstring &amp;operator=(const readonly_cstring &amp;str)</pre>
<blockquote>


<p>Assigns <tt>str</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">readonly_cstring(readonly_cstring &amp;&amp;str) noexcept <span class="sign">[C++11]</span></pre>
<pre class="prototype">readonly_cstring &amp;operator=(readonly_cstring &amp;&amp;str) noexcept <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Move operations for C++11 mode.</p>
</blockquote>
</div>

<div>
<pre class="prototype">readonly_cstring &amp;assign(const char *begin, const char *end)</pre>
<pre class="prototype">readonly_cstring &amp;assign(const char *chars, size_t n)</pre>
<blockquote>


<p>Assigns the string constructed from characters range.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool empty() const</pre>
<blockquote>

<p>Returns <tt>true</tt> if string is empty.</p>
</blockquote>
</div>

<div>
<pre class="prototype">const char *c_str() const</pre>
<pre class="prototype">operator const char*() const</pre>
<blockquote>


<p>Returns a pointer to the stored string. The pointer is never null.</p>
</blockquote>
</div>

<div>
<pre class="prototype">char *reserve(size_t n)</pre>
<blockquote>

<p>Allocates internal buffer for <tt>n</tt> chars and returns the pointer to
it. Can be useful in conjunction with functions like <tt>std::sprintf()</tt>.</p>
<div>
<u>Note</u>: Try to avoid this unsafe function!</div>
</blockquote>
</div>

<div>
<pre class="prototype">void swap(readonly_cstring &amp;str) noexcept</pre>
<blockquote>

<p>Swaps the value with <tt>str</tt>.</p>
</blockquote>
</div>



<div class="section">Free functions</div>

<div>
<pre class="prototype">int compare(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2)</pre>
<pre class="prototype">int compare(const readonly_cstring &amp;s1, const char *s2)</pre>
<pre class="prototype">int compare(const char *s1, const readonly_cstring &amp;s2)</pre>
<blockquote>



<p>Compares two strings as <tt>std::strcmp</tt> does.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool operator==(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2)</pre>
<pre class="prototype">...</pre>
<pre class="prototype">bool operator&gt;=(const char *s1, const readonly_cstring &amp;s2)</pre>
<blockquote>



<p>Full set of comparators for <tt>readonly_cstring</tt> and <tt>const char *</tt>
in all combinations.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void swap(readonly_cstring &amp;s1, readonly_cstring &amp;s2) noexcept</pre>
<blockquote>

<p>Specialization of the standard algorithm.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
class C
{
    __vic::readonly_cstring st;
public:
    explicit C(const char *str) : st(str) {}
    const char *get_str() const { return st; }
};
</pre>






<h2 id="set_of_chars.h">
<span class="h2_num">2.21</span><tt>__vic/set_of_chars.h</tt>
</h2>


<h3 id="set_of_chars">
<span class="h3_num">2.21.1</span><tt>set_of_chars</tt>
</h3>


<pre class="code">
class set_of_chars
{
public:
    constexpr set_of_chars();
    template&lt;class Iter&gt; constexpr set_of_chars(Iter begin, Iter end);
    constexpr set_of_chars(std::initializer_list&lt;char&gt; set); // C++11
    constexpr set_of_chars(const char *c_str);

    constexpr bool contains(char ch) const;

    constexpr void add(char ch);
    constexpr void remove(char ch);

    template&lt;class Iter&gt; constexpr void add(Iter begin, Iter end);
    constexpr void add(const char *c_str);
    constexpr void add(std::initializer_list&lt;char&gt; set); // C++11

    template&lt;class Iter&gt; void assign(Iter begin, Iter end);
    void assign(const char *c_str)
    void assign(std::initializer_list&lt;char&gt; set); // C++11

    void clear();
};
</pre>

<p>Compact (only 32 bytes) and very fast implemetation of a set of chars. The
cost of the <tt>contains()</tt> operation is always constant regardles of the
argument and number of elements in the set.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">constexpr set_of_chars()</pre>
<blockquote>

<p>Creates an empty set.</p>
<div>
<u>Postcondition</u>: <tt>contains(char(ch)) == false</tt> for any char
</div>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class Iter&gt; constexpr set_of_chars(Iter begin, Iter end)</pre>
<pre class="prototype">constexpr set_of_chars(std::initializer_list&lt;char&gt; set) <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Creates a set filled with characters from the specified range of values.</p>
<div>
<u>Note</u>: <tt>constexpr</tt> since C++14 only!</div>
</blockquote>
</div>

<div>
<pre class="prototype">constexpr set_of_chars(const char *c_str)</pre>
<blockquote>

<p>Creates a set filled with characters from the specified C-string excluding
NULL-terminator.</p>
<div>
<u>Note</u>: <tt>constexpr</tt> since C++14 only!</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool contains(char ch) const</pre>
<blockquote>

<p>Checks whether the set contains <tt>ch</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">constexpr void add(char ch)</pre>
<blockquote>

<p>Adds <tt>ch</tt> to the set.</p>
<div>
<u>Postcondition</u>: <tt>contains(ch) == true</tt>
</div>
<div>
<u>Note</u>: <tt>constexpr</tt> since C++14 only!</div>
</blockquote>
</div>

<div>
<pre class="prototype">constexpr void remove(char ch)</pre>
<blockquote>

<p>Removes <tt>ch</tt> from the set.</p>
<div>
<u>Postcondition</u>: <tt>contains(ch) == false</tt>
</div>
<div>
<u>Note</u>: <tt>constexpr</tt> since C++14 only!</div>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class Iter&gt; constexpr void add(Iter begin, Iter end)</pre>
<pre class="prototype">constexpr void add(std::initializer_list&lt;char&gt; set) <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Calls <tt>add(ch)</tt> for each value in the range.</p>
<div>
<u>Note</u>: <tt>constexpr</tt> since C++14 only!</div>
</blockquote>
</div>

<div>
<pre class="prototype">constexpr void add(const char *c_str)</pre>
<blockquote>

<p>Calls <tt>add(ch)</tt> for each character in the C-string excluding
NULL-terminator.</p>
<div>
<u>Note</u>: <tt>constexpr</tt> since C++14 only!</div>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class Iter&gt; void assign(Iter begin, Iter end)</pre>
<pre class="prototype">void assign(const char *c_str)</pre>
<pre class="prototype">void assign(std::initializer_list&lt;char&gt; set) <span class="sign">[C++11]</span></pre>
<blockquote>



<p>Calls <tt>clear()</tt> then <tt>add()</tt> with the specified parameters.
</p>
</blockquote>
</div>

<div>
<pre class="prototype">void clear()</pre>
<blockquote>

<p>Removes all elements from the set.</p>
<div>
<u>Postcondition</u>: <tt>contains(char(ch)) == false</tt> for any char
</div>
</blockquote>
</div>







<h2 id="stdint.h">
<span class="h2_num">2.22</span><tt>__vic/stdint.h</tt>
</h2>


<p>ISO C99 <tt>&lt;stdint.h&gt;</tt> for C++98. Since C++11 - just a redirector to
<tt>&lt;cstdint&gt;</tt>.</p>
<p>Additionally, some metafunctions for template metaprogramming are provided.
</p>


<h3 id="intN_t">
<span class="h3_num">2.22.1</span>Exact-width integer types</h3>


<p>Following types are guaranteed to be available in the <b>global
namespace</b>:</p>
<ul>
<li><tt>int8_t</tt></li>
<li><tt>int16_t</tt></li>
<li><tt>int32_t</tt></li>
<li><tt>int64_t</tt></li>
<li><tt>uint8_t</tt></li>
<li><tt>uint16_t</tt></li>
<li><tt>uint32_t</tt></li>
<li><tt>uint64_t</tt></li>
</ul>




<h3 id="int_leastN_t">
<span class="h3_num">2.22.2</span>Minimum-width integer types</h3>


<p>Following types are guaranteed to be available in the <b>global
namespace</b>:</p>
<ul>
<li><tt>int_least8_t</tt></li>
<li><tt>int_least16_t</tt></li>
<li><tt>int_least32_t</tt></li>
<li><tt>int_least64_t</tt></li>
<li><tt>uint_least8_t</tt></li>
<li><tt>uint_least16_t</tt></li>
<li><tt>uint_least32_t</tt></li>
<li><tt>uint_least64_t</tt></li>
</ul>




<h3 id="int_fastN_t">
<span class="h3_num">2.22.3</span>Fastest minimum-width integer types</h3>


<p>Following types are guaranteed to be available in the <b>global
namespace</b>:</p>
<ul>
<li><tt>int_fast8_t</tt></li>
<li><tt>int_fast16_t</tt></li>
<li><tt>int_fast32_t</tt></li>
<li><tt>int_fast64_t</tt></li>
<li><tt>uint_fast8_t</tt></li>
<li><tt>uint_fast16_t</tt></li>
<li><tt>uint_fast32_t</tt></li>
<li><tt>uint_fast64_t</tt></li>
</ul>




<h3 id="intmax_t">
<span class="h3_num">2.22.4</span>Greatest-width integer types</h3>


<p>Following types are guaranteed to be available in the <b>global
namespace</b>:</p>
<ul>
<li><tt>intmax_t</tt></li>
<li><tt>uintmax_t</tt></li>
</ul>




<h3 id="intptr_t">
<span class="h3_num">2.22.5</span>Integer types capable of holding object pointers</h3>


<p>Following types are guaranteed to be available in the <b>global
namespace</b>:</p>
<ul>
<li><tt>intptr_t</tt></li>
<li><tt>uintptr_t</tt></li>
</ul>




<h3 id="int_exactly_bytes">
<span class="h3_num">2.22.6</span><tt>int_exactly_bytes&lt;&gt;</tt>, <tt>uint_exactly_bytes&lt;&gt;</tt>
</h3>


<pre class="code">
template&lt;unsigned SizeInBytes&gt;
struct int_exactly_bytes
{
    using type = <span class="nonterminal">&lt;signed-integer-type-of-the-corresponding-size&gt;</span>;
};

template&lt;unsigned SizeInBytes&gt;
struct uint_exactly_bytes
{
    using type = <span class="nonterminal">&lt;unsigned-integer-type-of-the-corresponding-size&gt;</span>;
};

// BEGIN C++11
template&lt;unsigned N&gt;
using int_exact_bytes = typename int_exactly_bytes&lt;N&gt;::type;

template&lt;unsigned N&gt;
using uint_exact_bytes = typename uint_exactly_bytes&lt;N&gt;::type;
// END C++11
</pre>

<p>Metafunctions returning the signed/unsigned interger type of the requested
exact size in bytes. Shorter aliases are available in C++11 mode and higher.
Valid <tt>SizeInBytes</tt> values are <tt>1</tt>, <tt>2</tt>, <tt>4</tt>,
<tt>8</tt>.</p>

<div class="section">Example</div>
<pre class="code">
typedef __vic::int_exactly_bytes&lt; sizeof(void *) &gt;::type my_intptr_t;
// or in C++11
using my_intptr_t = __vic::int_exact_bytes&lt; sizeof(void *) &gt;
assert( sizeof(my_intptr) == sizeof(intptr_t) );
</pre>







<h2 id="stdio_file.h">
<span class="h2_num">2.23</span><tt>__vic/stdio_file.h</tt>
</h2>


<p><tt>std::FILE</tt>-related C++ wrappers.</p>


<h3 id="stdio_file">
<span class="h3_num">2.23.1</span><tt>stdio_file</tt>
</h3>


<pre class="code">
class stdio_file : private non_copyable
{
public:
    explicit stdio_file(std::FILE *fp = nullptr);
    stdio_file(const char *name, const char *mode);
    ~stdio_file();

    // BEGIN C++11
    stdio_file(stdio_file &amp;&amp;o) noexcept;
    stdio_file &amp;operator=(stdio_file &amp;&amp;o) noexcept;
    // END C++11

    bool open(const char *name, const char *mode);
    bool is_open() const;
    void close();
    bool close_nt() noexcept;

    void swap(stdio_file &amp;o) noexcept;
    std::FILE *detach_handle() noexcept;
    std::FILE *attach_handle(std::FILE *fp) noexcept;
    std::FILE *handle() const;
    operator std::FILE*() const;
};
</pre>

<p>Thin RAII-wrapper for <tt>std::FILE *</tt>. Controls file's life time.
Automatic conversion to <tt>std::FILE *</tt> allows usage of the object
whereever the file pointer is allowed/required.</p>

<div>
<u><b>Note</b></u>: Although the class destructor closes the open file, it is more safe
to use explicit <tt>close()</tt> call. Errors can happen when closing file,
and <tt>close()</tt> can throw exception in such cases, while destructor -
can't, so the error will be unnoticed by the application.</div>

<div class="section">Class members</div>

<div>
<pre class="prototype">explicit stdio_file(std::FILE *fp = nullptr)</pre>
<blockquote>

<p>Wraps already existing stream pointer.</p>
<div>
<u>Precondition</u>: <tt>fp</tt> is either a pointer to the open file or
<tt>nullptr</tt>.</div>
</blockquote>
</div>

<div>
<pre class="prototype">stdio_file(const char *name, const char *mode)</pre>
<blockquote>

<p>Calls <tt>open(name, mode)</tt>. The result should be checked using
subsequent <tt>is_open()</tt> call!</p>
</blockquote>
</div>

<div>
<pre class="prototype">~stdio_file()</pre>
<blockquote>

<p>Calls <tt>std::fclose()</tt> if <tt>is_open() == true</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">stdio_file(stdio_file &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<pre class="prototype">stdio_file &amp;operator=(stdio_file &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Move operations for C++11 mode.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool open(const char *name, const char *mode)</pre>
<blockquote>

<p>Calls <tt>std::fopen(name, mode)</tt>. Returns <tt>true</tt> in case of
success.</p>
<div>
<u>Precondition</u>: <tt>is_open() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool is_open() const</pre>
<blockquote>

<p>Returns <tt>true</tt> if file is open.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void close()</pre>
<blockquote>

<p>Calls <tt>std::fclose()</tt>. No preliminary checks whether the file is open
are performed! Throws if <tt>std::fclose()</tt> fails.</p>
<div>
<u>Precondition</u>: <tt>is_open() == true</tt>
</div>
<div>
<u>Postcondition</u>: <tt>is_open() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool close_nt() noexcept</pre>
<blockquote>

<p>A counterpart of <tt>close()</tt> but never throws, returns <tt>false</tt>
instead in case of error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void swap(stdio_file &amp;o) noexcept</pre>
<blockquote>

<p>Swaps the value with <tt>o</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">std::FILE *detach_handle() noexcept</pre>
<blockquote>

<p>Releases the file out of the object's control.</p>
<div>
<u>Postcondition</u>: <tt>is_open() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">std::FILE *attach_handle(std::FILE *fp) noexcept</pre>
<blockquote>

<p>Takes <tt>fp</tt> under control and returns the previous handle value.</p>
<div>
<u>Precondition</u>: <tt>fp</tt> is either a poiner to the open file or
<tt>nullptr</tt>.</div>
<div>
<u>Postcondition</u>: <tt>handle() == fp</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">std::FILE *handle() const</pre>
<blockquote>

<p>Returns the held handle value.</p>
</blockquote>
</div>

<div>
<pre class="prototype">operator std::FILE*() const</pre>
<blockquote>

<p>Allows usage of the object as <tt>std::FILE *</tt>.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
__vic::stdio_file file("file.txt", "w");
if(!file.is_open()) throw __vic::exception("Cannot open file");
std::fprintf(file, "Message");
file.close();
// fclose() also will be called in case of exception by destructor
</pre>





<h3 id="read-FILE-char">
<span class="h3_num">2.23.2</span><tt>read(std::FILE, char&amp;)</tt>,
    <tt>read(std::FILE, unsigned char&amp;)</tt>
</h3>


<pre class="code">
bool read(std::FILE *fp, char &amp;ch);
bool read(std::FILE *fp, unsigned char &amp;ch);
</pre>

<p>Attempts to read a byte from the C-stream. Returns <tt>true</tt> on succes,
<tt>false</tt> on EOF or throws on error.</p>



<h3 id="write-FILE-char">
<span class="h3_num">2.23.3</span><tt>write(std::FILE, char)</tt>
</h3>


<pre class="code">
void write(std::FILE *fp, char ch);
</pre>

<p>Writes a byte to the C-stream. Throws on error.</p>



<h3 id="getline-FILE">
<span class="h3_num">2.23.4</span><tt>getline(std::FILE)</tt>
</h3>


<pre class="code">
bool getline(std::FILE *fp, std::string &amp;str, char delim = '\n');
</pre>

<p>A counterpart of <tt>std::getline</tt> but for C-stream. Returns
<tt>false</tt> if the end of the file was reached and nothing was read.</p>





<h2 id="str2num.h">
<span class="h2_num">2.24</span><tt>__vic/str2num.h</tt>
</h2>



<h3 id="decimal_to_number">
<span class="h3_num">2.24.1</span><tt>decimal_to_number()</tt>
</h3>


<pre class="code">
#if __cpp_lib_string_view // since C++17

void decimal_to_number(std::string_view s, long long &amp;res);
void decimal_to_number(std::string_view s, long &amp;res);
void decimal_to_number(std::string_view s, int &amp;res);
void decimal_to_number(std::string_view s, short &amp;res);
void decimal_to_number(std::string_view s, signed char &amp;res);

void decimal_to_number(std::string_view s, unsigned long long &amp;res);
void decimal_to_number(std::string_view s, unsigned long &amp;res);
void decimal_to_number(std::string_view s, unsigned &amp;res);
void decimal_to_number(std::string_view s, unsigned short &amp;res);
void decimal_to_number(std::string_view s, unsigned char &amp;res);

template&lt;class Integer&gt;
[[nodiscard]] Integer decimal_to_number(std::string_view s);

#else // until C++17

void decimal_to_number(const std::string &amp;s, long long &amp;res);
void decimal_to_number(const std::string &amp;s, long &amp;res);
void decimal_to_number(const std::string &amp;s, int &amp;res);
void decimal_to_number(const std::string &amp;s, short &amp;res);
void decimal_to_number(const std::string &amp;s, signed char &amp;res);

void decimal_to_number(const std::string &amp;s, unsigned long long &amp;res);
void decimal_to_number(const std::string &amp;s, unsigned long &amp;res);
void decimal_to_number(const std::string &amp;s, unsigned &amp;res);
void decimal_to_number(const std::string &amp;s, unsigned short &amp;res);
void decimal_to_number(const std::string &amp;s, unsigned char &amp;res);

void decimal_to_number(const char *s, long long &amp;res);
void decimal_to_number(const char *s, long &amp;res);
void decimal_to_number(const char *s, int &amp;res);
void decimal_to_number(const char *s, short &amp;res);
void decimal_to_number(const char *s, signed char &amp;res);

void decimal_to_number(const char *s, unsigned long long &amp;res);
void decimal_to_number(const char *s, unsigned long &amp;res);
void decimal_to_number(const char *s, unsigned &amp;res);
void decimal_to_number(const char *s, unsigned short &amp;res);
void decimal_to_number(const char *s, unsigned char &amp;res);

template&lt;class Integer&gt;
[[nodiscard]] Integer decimal_to_number(const std::string &amp;s);

template&lt;class Integer&gt;
[[nodiscard]] Integer decimal_to_number(const char *s);

#endif
</pre>

<p>The set of functions converts a string, that represents an integer in
decimal notation, to one of the standard C++ integer types. The string can be
a C-string as well as <tt>std::string</tt>.</p>

<p>As opposed to the standard converters, like <tt>std::strtol()</tt>, strict
validation of the format of the whole string and value range is performed. In
particular leading spaces and non-digit characters at the end are not allowed.
For unsigned types minus (<tt>'-'</tt>) is disallowed, which is happily accepted
by <tt>std::strtoul()</tt> by unknown reason.</p>

<p>In case of errors the following exceptions are thrown:</p>
<ul>
<li>
<tt>std::invalid_argument</tt> - the string is not a correct decimal
        integer;</li>
<li>
<tt>std::range_error</tt> - the string is probably correct but the
        result cannot be represented by the used type (integer overflow).</li>
</ul>

<p>There are two kinds of the function prototypes:</p>
<ol>
<li>The result is returned via additional output parameter and</li>
<li>The result is returned using the natural way, the type is specified
        using the template parameter.</li>
</ol>




<h3 id="decimal_to_number_range">
<span class="h3_num">2.24.2</span><tt>decimal_to_number_range()</tt>
</h3>


<pre class="code">
template&lt;class T, class InputIterator&gt;
void decimal_to_number_range(InputIterator begin, InputIterator end, T &amp;res);

template&lt;class T, class InputIterator&gt;
[[nodiscard]] T decimal_to_number_range(InputIterator begin, InputIterator end);
</pre>

<p>The functions are complete analogs of <tt>decimal_to_number()</tt> except
they work with generic ranges of characters instead of strings.</p>




<h3 id="decimal_parser">
<span class="h3_num">2.24.3</span><tt>decimal_parser</tt>
</h3>


<pre class="code">
template&lt;class T&gt;
class decimal_parser
{
    using status = number_parse_status; // for brevity only
public:
    template&lt;class InputIterator&gt;
    [[nodiscard]] status parse(InputIterator begin, InputIterator end);
#if __cpp_lib_string_view // since C++17
    [[nodiscard]] status parse(std::string_view str);
#else // until C++17
    [[nodiscard]] status parse(const std::string &amp;str);
    [[nodiscard]] status parse(const char *str);
#endif
    [[nodiscard]] T result() const;
};
</pre>

<p>A counterpart of <tt>decimal_to_number()</tt> functions but doesn't throw
exceptions, <a href="#number_parse_status"><tt>number_parse_status</tt></a> codes are returned instead by
<tt>parse()</tt>.</p>

<div class="section">Status codes</div>
<div>
<pre class="prototype">number_parse_status::ok</pre>
<blockquote>

<p>Success, the result can be obtained using <tt>result()</tt> function.</p>
</blockquote>
</div>
<div>
<pre class="prototype">number_parse_status::invalid_number</pre>
<blockquote>

<p>The string is not a correct decimal integer.</p>
</blockquote>
</div>
<div>
<pre class="prototype">number_parse_status::unrepresentable</pre>
<blockquote>

<p>The string is probably correct but the result cannot be represented by the
used type (integer overflow).</p>
</blockquote>
</div>


<div class="section">Class members</div>

<div>
<pre class="prototype">template&lt;class InputIterator&gt;
[[nodiscard]] status parse(InputIterator begin, InputIterator end)</pre>
<pre class="prototype">[[nodiscard]] status parse(std::string_view str) <span class="sign">[C++17]</span></pre>
<pre class="prototype">[[nodiscard]] status parse(const std::string &amp;str) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">[[nodiscard]] status parse(const char *str) <span class="sign">[until C++17]</span></pre>
<blockquote>




<p>Converts a range of characters or a string to a number.</p>
<div>
<u>Postcondition</u>: The result of conversion can be obtained by <tt>result()</tt>
call if <tt>number_parse_status::ok</tt> is returned.
</div>
</blockquote>
</div>

<div>
<pre class="prototype">[[nodiscard]] T result() const</pre>
<blockquote>

<p>Returns the result of conversion produced by the the last <tt>parse()</tt>
call.</p>
<div>
<u>Precondition</u>: The last <tt>parse()</tt> call returned
<tt>number_parse_status::ok</tt>.</div>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
template&lt;class T&gt;
bool to_number(const std::string &amp;s, T &amp;result) noexcept
{
    __vic::decimal_parser&lt;T&gt; p;
    if(p.parse(s) != __vic::number_parse_status::ok) return false;
    result = p.result();
    returt true; // 'result' contains the result of conversion
}
</pre>





<h3 id="number_parse_status">
<span class="h3_num">2.24.4</span><tt>number_parse_status</tt>
</h3>


<pre class="code">
enum class number_parse_status
{
    ok,
    invalid_number,
    unrepresentable
};
using number_parse_status_t = number_parse_status; // for C++98
</pre>

<p>Number parsing outcome status codes.</p>

<div class="section">Types</div>

<div>
<pre class="prototype">typename number_parse_status_t</pre>
<blockquote>

<p>Use this as a name of type if your code has to be C++98-compatible.</p>
</blockquote>
</div>








<h2 id="string_buffer.h">
<span class="h2_num">2.25</span><tt>__vic/string_buffer.h</tt>
</h2>


<h3 id="string_buffer">
<span class="h3_num">2.25.1</span><tt>string_buffer</tt>
</h3>


<pre class="code">
class string_buffer : public std::string
{
public:
    string_buffer();
    explicit string_buffer(size_type n);
    string_buffer(const char *str);
    string_buffer(std::string str);
    string_buffer(string_ref sr);
    string_buffer(const std::string &amp;str, size_type off, size_type n = npos);
    string_buffer(const char *char_buf, size_type n);
    string_buffer(const char *begin, const char *end);
    template&lt;class InputIterator&gt;
    string_buffer(InputIterator begin, InputIterator end);

    string_buffer &amp;operator&lt;&lt;(const char *str);
    string_buffer &amp;operator&lt;&lt;(const std::string &amp;str);
    string_buffer &amp;operator&lt;&lt;(string_ref sr);
    string_buffer &amp;operator&lt;&lt;(char ch);

    string_buffer &amp;operator&lt;&lt;(long long n);
    string_buffer &amp;operator&lt;&lt;(long n);
    string_buffer &amp;operator&lt;&lt;(int n);
    string_buffer &amp;operator&lt;&lt;(short n);
    string_buffer &amp;operator&lt;&lt;(signed char ch);

    string_buffer &amp;operator&lt;&lt;(unsigned long long n);
    string_buffer &amp;operator&lt;&lt;(unsigned long n);
    string_buffer &amp;operator&lt;&lt;(unsigned n);
    string_buffer &amp;operator&lt;&lt;(unsigned short n);
    string_buffer &amp;operator&lt;&lt;(unsigned char ch);

    string_buffer &amp;operator&lt;&lt;(long double n);
    string_buffer &amp;operator&lt;&lt;(double n);
    string_buffer &amp;operator&lt;&lt;(float n);

    string_buffer &amp;operator&lt;&lt;(bool flag);
    string_buffer &amp;operator&lt;&lt;(const void *p);

    string_buffer &amp;operator=(string_ref sr);
    string_buffer &amp;operator+=(string_ref sr);
    string_buffer &amp;assign(string_ref sr);
    string_buffer &amp;append(string_ref sr);

    // improved std::string calls
    string_buffer &amp;assign(const std::string &amp;str,
                            size_type off, size_type n = npos);
    string_buffer &amp;append(const std::string &amp;str,
                            size_type off, size_type n = npos);
    string_buffer &amp;insert(size_type pos, const std::string &amp;str,
                            size_type off, size_type n = npos);

    string_buffer &amp;reserve(size_type n);
    string_buffer &amp;clear();

    // missing container interface of std::string
    reference front();
    reference back();
    const_reference front() const;
    const_reference back() const;
    void pop_back();

    operator const char *() const;
};

string_buffer operator+(const string_buffer &amp;s1, const string_buffer &amp;s2);
string_buffer operator+(const string_buffer &amp;s1, const std::string &amp;s2);
string_buffer operator+(const std::string &amp;s1, const string_buffer &amp;s2);

string_buffer operator+(const string_buffer &amp;s1, const char *s2);
string_buffer operator+(const char *s1, const string_buffer &amp;s2);

string_buffer operator+(const string_buffer &amp;s, char ch);
string_buffer operator+(char ch, const string_buffer &amp;s);

template&lt;class T&gt;
string_buffer &amp;operator&lt;&lt;(string_buffer &amp;&amp;s, const T &amp;v); // C++11

using msg = string_buffer;
</pre>

<p>Class is an extended and improved <tt>std::string</tt>. It has following
advantages:</p>

<ol>
<li>Left-associative append operator (<tt>&lt;&lt;</tt>) that allows
constructions like this:
<pre class="code">
str &lt;&lt; "Error message: " &lt;&lt; err_msg &lt;&lt; "\n";
</pre>
</li>
<li>Specific amount of bytes can be reserved using constructor as well as
<tt>reserve()</tt> call. Reserving required amount of space in advance can
improve performance significantly.
<pre class="code">
__vic::string_buffer st(4096);

// is same as
std::string st;
st.reserve(4096);
</pre>
</li>
<li>Operator <tt>&lt;&lt;</tt> accepts all fundamental types: numbers, chars,
pointers, <tt>bool</tt>:
<pre class="code">
for(int i=0; i&lt;10; i++)
    str &lt;&lt; "i = " &lt;&lt; i &lt;&lt; '\n';
</pre>
</li>
<li>All input <tt>nullptr</tt> values of <tt>const char *</tt> are treated as
an empty string. Such values usually cause crash with <tt>std::string</tt>.
<pre class="code">
std::string s1("Str");
const char *p = nullptr;
s1.append(p); // Oops.... Null pointer access!

__vic::string_buffer s2("Str");
s2.append(p); // Ok. s2 == "Str" still
s2 = p; // Ok. s2.empty() == true
</pre>
</li>
<li>Automatic conversion to <tt>const char *</tt> that allows usage of the
object in context requires C-string, without explicit <tt>c_str()</tt> call.
<pre class="code">
std::string fname(...);
FILE *fp = fopen(fname.c_str(), "r");

__vic::string_buffer fname(...);
FILE *fp = fopen(fname, "r");)
</pre>
</li>
<li>Some design irregularities of <tt>std::string</tt> are corrected. For
instance <tt>std::string</tt> is a complete container but operations
<tt>front()</tt> and <tt>back()</tt> are missed in C++98. There is
<tt>push_back()</tt> but no <tt>pop_back()</tt>.</li>
</ol>

<p>In spite of all these improvements, the interface of this class is completely
backward compatible with <tt>std::string</tt>. Objects can be passed in contexts
that require <tt>std::string</tt>. Class has no additional data-members.</p>

<p>Using of inserter (operator <tt>&lt;&lt;</tt>) provides the easiest way to
convert numbers to decimal string representation. Using of
<tt>std::ostringstream</tt> for this purposes is more functional (you can
specify radix, formatting, etc) but too tedious and not efficient in most
cases.</p>

<p>Additionally this type has a short synonym <tt>msg</tt>. It is very
convenient for usage when one needs to construct a complex message with a
single expression, without introducing unnecessary variables:</p>

<pre class="code">
oresult res = db_open(db_name);
if(res != 0) throw __vic::exception(
    __vic::msg(64) &lt;&lt; "Cannot open DB " &lt;&lt; db_name &lt;&lt; ". res = " &lt;&lt; res
);
</pre>

<p>As you can see, the maximum size of the message expected is specified in the
constructor for optimization purposes.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">string_buffer()</pre>
<blockquote>

<p>Create an empty string.</p>
<div>
<u>Postcondition</u>: <tt>empty() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">explicit string_buffer(size_type n)</pre>
<blockquote>

<p>Calls <tt>reserve(n)</tt>.</p>
<div>
<u>Postcondition</u>: <tt>capacity() &gt;= n</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer(const char *str)</pre>
<pre class="prototype">string_buffer(std::string str)</pre>
<blockquote>


<p>Creates the copy of <tt>str</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer(const std::string &amp;str, size_type off, size_type n = npos)</pre>
<blockquote>

<p>Creates the copy of <tt>str</tt> substring.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer(const char *char_buf, size_type n)</pre>
<blockquote>

<p>Creates string using buffer and its length.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer(string_ref sr)</pre>
<pre class="prototype">string_buffer(const char *begin, const char *end)</pre>
<pre class="prototype">template&lt;class InputIterator&gt;
string_buffer(InputIterator begin, InputIterator end)</pre>
<blockquote>



<p>Creates string from the chars range.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(const char *str)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(const std::string &amp;str)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(string_ref sr)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(char ch)</pre>
<blockquote>




<p>Calls <tt>std::string::append()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(long long n)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(long n)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(int n)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(short n)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(signed char ch)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(unsigned long long n)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(unsigned long n)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(unsigned n)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(unsigned short n)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(unsigned char ch)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(long double n)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(double n)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(float n)</pre>
<blockquote>













<p>Appends decimal representaion of <tt>n</tt> to the string.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(const void *p)</pre>
<blockquote>

<p>Appends pointers value in <tt>%p</tt> format of <tt>std::printf</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(bool flag)</pre>
<blockquote>

<p>Appends <tt>1</tt> (for <tt>true</tt>) or <tt>0</tt> (for <tt>false</tt>)
to the string.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer &amp;operator=(string_ref sr)</pre>
<pre class="prototype">string_buffer &amp;operator+=(string_ref sr)</pre>
<pre class="prototype">string_buffer &amp;assign(string_ref sr)</pre>
<pre class="prototype">string_buffer &amp;append(string_ref sr)</pre>
<blockquote>




<p>Operations for <tt>string_ref</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer &amp;reserve(size_type n)</pre>
<pre class="prototype">string_buffer &amp;clear()</pre>
<blockquote>


<p>Calls the corresponding <tt>std::string</tt> operation and additionally
returns the reference to itself, so the call can be used in complex
expressions.</p>
</blockquote>
</div>

<div>
<pre class="prototype">reference front()</pre>
<pre class="prototype">reference back()</pre>
<pre class="prototype">const_reference front() const</pre>
<pre class="prototype">const_reference back() const</pre>
<pre class="prototype">void pop_back()</pre>
<blockquote>





<p>Missed container operations in the <tt>std::string</tt> interface in
C++98.</p>
</blockquote>
</div>

<div>
<pre class="prototype">operator const char *() const</pre>
<blockquote>

<p>Calls <tt>std::string::c_str()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer operator+(const string_buffer &amp;s1, const string_buffer &amp;s2)</pre>
<pre class="prototype">string_buffer operator+(const string_buffer &amp;s1, const std::string &amp;s2)</pre>
<pre class="prototype">string_buffer operator+(const std::string &amp;s1, const string_buffer &amp;s2)</pre>
<pre class="prototype">string_buffer operator+(const string_buffer &amp;s1, const char *s2)</pre>
<pre class="prototype">string_buffer operator+(const char *s1, const string_buffer &amp;s2)</pre>
<pre class="prototype">string_buffer operator+(const string_buffer &amp;s, char ch)</pre>
<pre class="prototype">string_buffer operator+(char ch, const string_buffer &amp;s)</pre>
<blockquote>







<p>Concatenation of strings and characters.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class T&gt;
string_buffer &amp;operator&lt;&lt;(string_buffer &amp;&amp;s, const T &amp;v) <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Calls <tt>operator&lt;&lt;(string_buffer &amp;s, const T &amp;v)</tt>.</p>
</blockquote>
</div>







<h2 id="string_ref.h">
<span class="h2_num">2.26</span><tt>__vic/string_ref.h</tt>
</h2>


<h3 id="string_ref">
<span class="h3_num">2.26.1</span><tt>string_ref</tt>
</h3>


<pre class="code">
template&lt;class charT&gt;
class basic_string_ref
{
public:
    using value_type = charT;
    using iterator = const value_type *;
    using const_iterator = iterator;

    // Constructors
    basic_string_ref();
    basic_string_ref(const charT *str);
    basic_string_ref(const charT *chars, size_t n);
    basic_string_ref(const charT *begin, const charT *end);
    template&lt;class Traits, class Alloc&gt;
    explicit basic_string_ref(
        const std::basic_string&lt;charT,Traits,Alloc&gt; &amp;str);
    basic_string_ref(
        typename std::basic_string&lt;charT&gt;::const_iterator begin,
        typename std::basic_string&lt;charT&gt;::const_iterator end);
    // BEGIN C++11
    basic_string_ref(std::initializer_list&lt;charT&gt; );
    // END C++11

#if __cpp_lib_string_view // since C++17
    template&lt;class Traits&gt;
    basic_string_ref(std::basic_string_view&lt;charT,Traits&gt; s);
    operator std::basic_string_view&lt;charT&gt;() const;
#endif

    // Accessors
    iterator begin() const;
    iterator end() const;
    iterator cbegin() const;
    iterator cend() const;

    charT front() const;
    charT back() const;
    charT operator[](size_t i) const;
    const charT *data() const;

    bool empty() const;
    size_t size() const;
    size_t length() const;

    int compare(basic_string_ref s) const;

    // Converters
    std::basic_string&lt;charT&gt; str() const;
    template&lt;class Traits&gt;
    std::basic_string&lt;charT,Traits&gt; str() const;
    template&lt;class Traits, class Alloc&gt;
    std::basic_string&lt;charT,Traits,Alloc&gt; str(const Alloc &amp;a = Alloc())const;

    operator std::basic_string&lt;charT&gt;() const;
};

using string_ref = basic_string_ref&lt;char&gt; ;

template&lt;class charT&gt;
bool operator==(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2);
template&lt;class charT&gt;
bool operator!=(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2);
template&lt;class charT&gt;
bool operator&lt;(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2);
template&lt;class charT&gt;
bool operator&gt;(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2);
template&lt;class charT&gt;
bool operator&lt;=(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2);
template&lt;class charT&gt;
bool operator&gt;=(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2);

#ifdef __VIC_DEFINE_OSTREAM_INSERTERS
template&lt;class charT, class Traits&gt;
std::basic_ostream&lt;charT,Traits&gt; &amp;operator&lt;&lt;(
    std::basic_ostream&lt;charT,Traits&gt; &amp;os, const basic_string_ref&lt;charT&gt; &amp;sr);
#endif
</pre>

<p>The class represents a reference to the read-only continuous range of
characters. When used as a return value, it is significantly more lightweight
than <tt>std::string</tt>, because no string copy or memory allocation
performed. But, when <tt>std::string</tt> is required, automatic conversion
happens. Let's consider the example:</p>

<pre class="code">
class C
{
    std::string v;
public:
    std::string       get_v_1() const { return v; }
    __vic::string_ref get_v_2() const { return v; }
};
</pre>

<p>As you can see, class contains one string field. Two read-only
access-functions are defined. The first as usual returns <tt>std::string</tt>,
the second - <tt>string_ref</tt>. When the first is used, temporay string is
created every time. When the second is used, just reference is returned.</p>

<p>Another use case - input read-only string argument. The class is a drop-in
replacement for <tt>const std::string &amp;</tt>. In most cases, it can also
be used instead of <tt>const char *</tt>. The overhead in this case is an
additional scan of the string to find the NULL-terminator, which is nothing in
cases when we need the string end or length anyway. Let's consider 3 sets of
overloaded functions:</p>

<pre class="code">
void f1(const std::string &amp; );

void f2(const std::string &amp; );
void f2(const char * );

void f3(string_ref );
</pre>

<p>Each of them can be used as</p>

<pre class="code">
fx("Nul-terminated string");
</pre>

<p>as well as</p>

<pre class="code">
fx(std::string("std::string"));
</pre>

<p>But with <tt>f1()</tt> we will have redundant string copying in the first
case, just to read the value. With <tt>f2()</tt> several overloads are
required. And while it isn't a big issue when function has single argument,
with two or more string arguments it quickly becomes very tedious. The last
alternative - <tt>f3()</tt> - is at the same time as short and universal as
<tt>f1()</tt> and "friendlier" to the string literals and strings from the
C-world - they are not copied to the heap and not converted to
<tt>std::string</tt>.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">basic_string_ref()</pre>
<blockquote>

<div>
<u>Postcondition</u>: <tt>empty() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">basic_string_ref(const charT *str)</pre>
<pre class="prototype">template&lt;class Traits, class Alloc&gt;
basic_string_ref(const std::basic_string&lt;charT,Traits,Alloc&gt; &amp;str)</pre>
<blockquote>


<p>Creates reference to <tt>str</tt>.</p>
<div>
<u>Postcondition</u>: <tt>*this == str</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">basic_string_ref(const charT *chars, size_t n)</pre>
<pre class="prototype">basic_string_ref(const charT *begin, const charT *end)</pre>
<pre class="prototype">basic_string_ref(const charT *chars, size_t n)</pre>
<pre class="prototype">basic_string_ref(
    typename std::basic_string&lt;charT&gt;::const_iterator begin,
    typename std::basic_string&lt;charT&gt;::const_iterator end)</pre>
<pre class="prototype">basic_string_ref(std::initializer_list&lt;charT&gt; ) <span class="sign">[C++11]</span></pre>
<blockquote>





<p>Create reference to the range of the characters.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class Traits&gt;
basic_string_ref(std::basic_string_view&lt;charT,Traits&gt; s) <span class="sign">[C++17]</span></pre>
<pre class="prototype">operator std::basic_string_view&lt;charT&gt;() const <span class="sign">[C++17]</span></pre>
<blockquote>


<p>Converters from/to <tt>std::basic_string_view</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">iterator begin() const</pre>
<pre class="prototype">iterator cbegin() const</pre>
<pre class="prototype">const charT *data() const</pre>
<blockquote>



<p>Begin of the range of the characters.</p>
</blockquote>
</div>

<div>
<pre class="prototype">iterator end() const</pre>
<pre class="prototype">iterator cend() const</pre>
<blockquote>


<p>End of the range of the characters.</p>
</blockquote>
</div>

<div>
<pre class="prototype">charT front() const</pre>
<pre class="prototype">charT back() const</pre>
<blockquote>


<p>The first and the last character of the string correspondingly.</p>
<div>
<u>Precondition</u>: <tt>!empty()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">charT operator[](size_t i) const</pre>
<blockquote>

<p><tt>i</tt>-th character of the string.</p>
<div>
<u>Precondition</u>: <tt>i &lt; length()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool empty() const</pre>
<blockquote>

<p>Returns <tt>begin() == end()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">size_t size() const</pre>
<pre class="prototype">size_t length() const</pre>
<blockquote>


<p>Size of the string.</p>
</blockquote>
</div>

<div>
<pre class="prototype">int compare(basic_string_ref s) const</pre>
<blockquote>

<p>Compares the string with <tt>s</tt>. Returning values are the same as for
<tt>std::string::compare()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">std::basic_string&lt;charT&gt; str() const</pre>
<pre class="prototype">template&lt;class Traits&gt;
std::basic_string&lt;charT,Traits&gt; str() const</pre>
<pre class="prototype">template&lt;class Traits, class Alloc&gt;
std::basic_string&lt;charT,Traits,Alloc&gt; str(const Alloc &amp;a = Alloc()) const</pre>
<blockquote>



<p>Explicit converter to <tt>std::basic_string</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">operator std::basic_string&lt;charT&gt;() const</pre>
<blockquote>

<p>Implicit converter to <tt>std::basic_string</tt>.</p>
</blockquote>
</div>



<div class="section">Free functions</div>

<div>
<pre class="prototype">template&lt;class charT&gt;
bool operator==(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2)</pre>
<pre class="prototype">template&lt;class charT&gt;
bool operator!=(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2)</pre>
<pre class="prototype">template&lt;class charT&gt;
bool operator&lt;(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2)</pre>
<pre class="prototype">template&lt;class charT&gt;
bool operator&gt;(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2)</pre>
<pre class="prototype">template&lt;class charT&gt;
bool operator&lt;=(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2)</pre>
<pre class="prototype">template&lt;class charT&gt;
bool operator&gt;=(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2)</pre>
<blockquote>






<p>Full set of the comparison operators.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class charT, class Traits&gt;
std::basic_ostream&lt;charT,Traits&gt; &amp;operator&lt;&lt;(
    std::basic_ostream&lt;charT,Traits&gt; &amp;os, const basic_string_ref&lt;charT&gt; &amp;sr)</pre>
<blockquote>

<p>Inserter to an output stream. Defined (and <tt>&lt;ostream&gt;</tt> is included)
only if <tt>__VIC_DEFINE_OSTREAM_INSERTERS</tt> macro was defined before the
header inclusion.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
C c; // see the class description above
__vic::string_ref s = c. get_v_2();

// print the string using different ways
for(__vic::string_ref::iterator it = s.begin(); it != s.end(); ++it)
    std::cout &lt;&lt; *it;

// C++11
for(auto ch : s) std::cout &lt;&lt; ch;

std::copy(s.begin(), s.end(), std::ostream_iterator&lt;char&gt;(std::cout));

std::cout &lt;&lt; s;

// automatic conversion to std::string
std::string ss = s;
</pre>






<h2 id="string_utils.h">
<span class="h2_num">2.27</span><tt>__vic/string_utils.h</tt>
</h2>


<p>Miscellaneous strings-related utilities.</p>


<h3 id="trim">
<span class="h3_num">2.27.1</span><tt>trim</tt> functions</h3>


<pre class="code">
char *trim(char *str);
char *trim_front(char *str);
char *trim_back(char *str);
char *trim(char *str, char ch);
char *trim_front(char *str, char ch);
char *trim_back(char *str, char ch);
char *trim(char *str, const char *set);
char *trim_front(char *str, const char *set);
char *trim_back(char *str, const char *set);

std::string &amp;trim(std::string &amp;str);
std::string &amp;trim_front(std::string &amp;str);
std::string &amp;trim_back(std::string &amp;str);
std::string &amp;trim(std::string &amp;str, char ch);
std::string &amp;trim_front(std::string &amp;str, char ch);
std::string &amp;trim_back(std::string &amp;str, char ch);
std::string &amp;trim(std::string &amp;str, const char *set);
std::string &amp;trim_front(std::string &amp;str, const char *set);
std::string &amp;trim_back(std::string &amp;str, const char *set);

#if __cpp_lib_string_view // C++17
std::string_view trimmed(std::string_view str);
std::string_view trimmed_front(std::string_view str);
std::string_view trimmed_back(std::string_view str);
std::string_view trimmed(std::string_view str, char ch);
std::string_view trimmed_front(std::string_view str, char ch);
std::string_view trimmed_back(std::string_view str, char ch);
std::string_view trimmed(std::string_view str, const char *set);
std::string_view trimmed_front(std::string_view str, const char *set);
std::string_view trimmed_back(std::string_view str, const char *set);
#else // until C++17
std::string trimmed(const std::string &amp;str);
std::string trimmed_left(const std::string &amp;str);
std::string trimmed_right(const std::string &amp;str);
std::string trimmed(const std::string &amp;str, char ch);
std::string trimmed_left(const std::string &amp;str, char ch);
std::string trimmed_right(const std::string &amp;str, char ch);
std::string trimmed(const std::string &amp;str, const char *set);
std::string trimmed_left(const std::string &amp;str, const char *set);
std::string trimmed_right(const std::string &amp;str, const char *set);
#endif
</pre>

<p>The set of functions stripping unwanted characters from the string edges.
Characters to strip can be specified. One can specify single character
<tt>ch</tt> as well as the set of characters <tt>set</tt>. If no characters
is specified, all ASCII-whitespaces are implied. Following naming rules for
the functions are used:</p>
<ul>
<li>
<tt>trim</tt> - strips from both edges,</li>
<li>
<tt>trim_front</tt> - strips from the beginning,</li>
<li>
<tt>trim_back</tt> - strips from the end.</li>
</ul>

<p>Functions <tt>trim</tt> modify the string in-situ and return the pointer or
reference to it. If the original value should be preserved, <tt>trimmed</tt>
functions should be used.</p>
<ul><li>
<tt>trimmed</tt> - return stripped copy of the string, argument
        itself is not modified.</li></ul>

<p>The implementation is optimized for common case when the string does not have
anything to trim. In such cases no modifications of the argument are performed,
the function returns immediately after the checks are completed, and the call
is maximally cheap.</p>

<p>All <tt>nullptr</tt> values are treated as an empty string.</p>

<div class="section">Example</div>
<pre class="code">
char st1[] = "\t value    \n";

// CHOICE:
__vic::trim(st1);       // result: "value"
__vic::trim_front(st1); // result: "value    \n"
__vic::trim_back(st1);  // result: "\t value"

std::string st2("...value123");

// CHOICE:
// trim dot chars
__vic::trim_front(st1, '.');        // result: "value123"
// trim all digits
__vic::trim_back(st1, "123456789"); // result: "...value"
</pre>





<h3 id="sift">
<span class="h3_num">2.27.2</span><tt>sift()</tt>
</h3>


<pre class="code">
char *sift(char *str, const char *trash_chars);
std::string &amp;sift(std::string &amp;str, const char *trash_chars);
</pre>

<p>Removes all characters from the set from the string. All <tt>nullptr</tt>
values are treated as an empty string.</p>

<div class="section">Example</div>
<pre class="code">
char st[] = "..ab.c..d.e.";
__vic::sift(st, ".");
assert(std::strcmp(st, "abcde") == 0);
</pre>





<h3 id="sift_if">
<span class="h3_num">2.27.3</span><tt>sift_if()</tt>
</h3>


<pre class="code">
template&lt;class Pred&gt;
char *sift(char *str, Pred pred);
template&lt;class Pred&gt;
std::string &amp;sift(std::string &amp;str, Pred pred);
</pre>

<p>Removes all characters satify the predicate <tt>pred</tt>. All
<tt>nullptr</tt> values are treated as an empty string.</p>




<h3 id="pad_front">
<span class="h3_num">2.27.4</span><tt>pad_front()</tt>
</h3>


<pre class="code">
std::string &amp;pad_front(std::string &amp;str, size_t size, char pad_ch = ' ');
char *pad_front(char *str, size_t size, char pad_ch = ' ');
</pre>

<p>Complements the string up to length <tt>size</tt> by adding the required
number of <tt>pad_ch</tt> chars to the beginning. Nothing happens if
<tt>str</tt> length is equal or greather than <tt>size</tt> or the pointer is
null. Returns <tt>str</tt>.</p>




<h3 id="pad_back">
<span class="h3_num">2.27.5</span><tt>pad_back()</tt>
</h3>


<pre class="code">
std::string &amp;pad_back(std::string &amp;str, size_t size, char pad_ch = ' ');
char *pad_back(char *str, size_t size, char pad_ch = ' ');
</pre>

<p>Complements the string up to length <tt>size</tt> by adding the required
number of <tt>pad_ch</tt> chars to the end. Nothing happens if
<tt>str</tt> length is equal or greather than <tt>size</tt> or the pointer is
null. Returns
<tt>str</tt>.</p>




<h3 id="starts_with">
<span class="h3_num">2.27.6</span><tt>starts_with()</tt>
</h3>


<pre class="code">
bool starts_with(const char *s, char pref);
bool starts_with(const char *s, const char *pref);
bool starts_with(const char *s, const char *pref, size_t pref_len);

#if __cpp_lib_string_view // C++17
bool starts_with(std::string_view s, char pref);
bool starts_with(std::string_view s, std::string_view pref);
bool starts_with(std::string_view s, const char *pref);
#else // until C++17
bool starts_with(const std::string &amp;s, char pref);
bool starts_with(const std::string &amp;s, const char *pref);
bool starts_with(const std::string &amp;s, const std::string &amp;pref);
bool starts_with(const std::string &amp;s, const char *pref, size_t pref_len);
#endif

bool starts_with(const char *s, size_t s_len, char pref);
bool starts_with(const char *s, size_t s_len, const char *pref);
bool starts_with(const char *s, size_t s_len, const char *pref, size_t pref_len);
</pre>

<p>Returns <tt>true</tt> if string <tt>s</tt> starts with the specified
prefix.</p>




<h3 id="ends_with">
<span class="h3_num">2.27.7</span><tt>ends_with()</tt>
</h3>


<pre class="code">
#if __cpp_lib_string_view // C++17
bool ends_with(std::string_view s, char suff);
bool ends_with(std::string_view s, std::string_view suff);
#else // until C++17
bool ends_with(const char *s, char suff);
bool ends_with(const char *s, const char *suff);
bool ends_with(const char *s, const char *suff, size_t suff_len);
bool ends_with(const char *s, size_t s_len, const char *suff);

bool ends_with(const std::string &amp;s, char suff);
bool ends_with(const std::string &amp;s, const char *suff);
bool ends_with(const std::string &amp;s, const std::string &amp;suff);
bool ends_with(const std::string &amp;s, const char *suff, size_t suff_len);
#endif

bool ends_with(const char *s, size_t s_len, char suff);
bool ends_with(const char *s, size_t s_len, const char *suff, size_t suff_len);
</pre>

<p>Returns <tt>true</tt> if string <tt>s</tt> ends with the specified
suffix.</p>






<h2 id="tchar.h">
<span class="h2_num">2.28</span><tt>__vic/tchar.h</tt>
</h2>


<p>Generic functions to manipulate C-strings regardless of the underlying
char-type, like <tt>std::char_traits&lt;&gt;</tt>. All the functions are located
within <tt>__vic::tchar</tt> namespace.</p>

<p>Most of the functions are just generic redirectors to calls like
<tt>strcpy</tt>, <tt>wcscpy</tt>, et al. Searching functions have more
intelligible names that ones in the C-library and unified parameters: they
always take pointers and never indices. Also the set of the functions is
complemented with "logically symmetrical" ones missed in the standard library.
Searching functions return <tt>nullptr</tt> in case of failure.</p>

<div class="section">Example</div>
<pre class="code">
template&lt;class charT&gt;
charT *generic_dup(const charT *st)
{
    namespace tchar = __vic::tchar;

    charT *st_copy = new charT[tchar::length(st) + 1];
    tchar::copy(st_copy, st);
    return st_copy;
}
</pre>



<h3 id="tchar--length">
<span class="h3_num">2.28.1</span><tt>tchar::length()</tt>
</h3>


<pre class="code">
template&lt;class charT&gt;
size_t tchar::length(const charT *str);
</pre>

<p>String length in elements. Generic <tt>strlen</tt> / <tt>wcslen</tt>.</p>




<h3 id="tchar--empty">
<span class="h3_num">2.28.2</span><tt>tchar::empty()</tt>
</h3>


<pre class="code">
template&lt;class charT&gt;
bool tchar::empty(const charT *str);
</pre>

<p>Checks if <tt>str</tt> is <tt>nullptr</tt> or has no characters.</p>




<h3 id="tchar--end">
<span class="h3_num">2.28.3</span><tt>tchar::end()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT&gt;
const charT *end(const charT *str);

template&lt;class charT&gt;
charT *end(charT *str);

}
</pre>

<p>Pointer to the NULL-terminator. Generic <tt>strchr(str, '\0')</tt> /
<tt>wcschr(str, L'\0')</tt>.</p>

<div>
<u><b>Note</b></u>: Some buggy implementations of <tt>std::strchr()</tt> like MinGW return
non-const <tt>char *</tt> even if the argument is <tt>const char *</tt> so
this function can be used as a workaround in the similar use case.</div>




<h3 id="tchar--compare">
<span class="h3_num">2.28.4</span><tt>tchar::compare()</tt>
</h3>


<pre class="code">
template&lt;class charT&gt;
int tchar::compare(const charT *str1, const charT *str2);
</pre>

<p>Compare two strings. Generic <tt>strcmp</tt> / <tt>wcscmp</tt>.</p>




<h3 id="tchar--equal">
<span class="h3_num">2.28.5</span><tt>tchar::equal()</tt>
</h3>


<pre class="code">
template&lt;class charT&gt;
bool tchar::equal(const charT *str1, const charT *str2);
</pre>

<p>Checks if two strings are equal.</p>

<div>
<u>Precondition</u>: <tt>str1 != nullptr &amp;&amp; str2 != nullptr</tt>
</div>




<h3 id="tchar--copy">
<span class="h3_num">2.28.6</span><tt>tchar::copy()</tt>
</h3>


<pre class="code">
template&lt;class charT&gt;
charT *tchar::copy(charT *dest, const charT *src);
</pre>

<p>Copy string. Generic <tt>strcpy</tt> / <tt>wcscpy</tt>.</p>




<h3 id="tchar--move">
<span class="h3_num">2.28.7</span><tt>tchar::move()</tt>
</h3>


<pre class="code">
template&lt;class charT&gt;
charT *tchar::move(charT *dest, const charT *src);
</pre>

<p>Move the string in memory (<tt>memmove</tt>).</p>




<h3 id="tchar--concat">
<span class="h3_num">2.28.8</span><tt>tchar::concat()</tt>
</h3>


<pre class="code">
template&lt;class charT&gt;
charT *tchar::concat(charT *dest, const charT *src);
</pre>

<p>Concatenate two strings. Generic <tt>strcat</tt> / <tt>wcscat</tt>.</p>




<h3 id="tchar--find">
<span class="h3_num">2.28.9</span><tt>tchar::find()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT&gt;
const charT *find(const charT *str, charT ch);

template&lt;class charT&gt;
charT *find(charT *str, charT ch);

template&lt;class charT&gt;
const charT *find(const charT *str, const charT *sub);

template&lt;class charT&gt;
charT *find(charT *str, const charT *sub);

}
</pre>

<p>Find the first occurrence of the character or substring. Generic
<tt>strchr</tt> / <tt>wcschr</tt> / <tt>strstr</tt> / <tt>wcsstr</tt>.</p>




<h3 id="tchar--rfind">
<span class="h3_num">2.28.10</span><tt>tchar::rfind()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT&gt;
const charT *rfind(const charT *str, charT ch);

template&lt;class charT&gt;
charT *rfind(charT *str, charT ch);

}
</pre>

<p>Find the last occurrence of the character. Generic <tt>strrchr</tt> /
<tt>wcsrchr</tt>.</p>




<h3 id="tchar--find_if">
<span class="h3_num">2.28.11</span><tt>tchar::find_if()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT, class Pred&gt;
const charT *find_if(const charT *str, Pred pred);

template&lt;class charT, class Pred&gt;
charT *find_if(charT *str, Pred pred);

}
</pre>

<p>Find the first occurrence of the character that satisfies the specified
predicate.</p>




<h3 id="tchar--find_if_not">
<span class="h3_num">2.28.12</span><tt>tchar::find_if_not()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT, class Pred&gt;
const charT *find_if_not(const charT *str, Pred pred);

template&lt;class charT, class Pred&gt;
charT *find_if_not(charT *str, Pred pred);

}
</pre>

<p>Find the first occurrence of the character that doesn't satisfy the
specified predicate.</p>




<h3 id="tchar--rfind_if">
<span class="h3_num">2.28.13</span><tt>tchar::rfind_if()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT, class Pred&gt;
const charT *rfind_if(const charT *str, Pred pred);

template&lt;class charT, class Pred&gt;
charT *rfind_if(charT *str, Pred pred);

}
</pre>

<p>Find the last occurrence of the character that satisfies the specified
predicate.</p>




<h3 id="tchar--rfind_if_not">
<span class="h3_num">2.28.14</span><tt>tchar::rfind_if_not()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT, class Pred&gt;
const charT *rfind_if_not(const charT *str, Pred pred);

template&lt;class charT, class Pred&gt;
charT *rfind_if_not(charT *str, Pred pred);

}
</pre>

<p>Find the last occurrence of the character that doesn't satisfy the specified
predicate.</p>




<h3 id="tchar--find_first_of">
<span class="h3_num">2.28.15</span><tt>tchar::find_first_of()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT&gt;
const charT *find_first_of(const charT *str, const charT *set);

template&lt;class charT&gt;
charT *find_first_of(charT *str, const charT *set);

}
</pre>

<p>Find the first occurrence of the character from the specified set. Generic
<tt>strpbrk</tt> / <tt>wcspbrk</tt>.</p>




<h3 id="tchar--find_first_not_of">
<span class="h3_num">2.28.16</span><tt>tchar::find_first_not_of()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT&gt;
const charT *find_first_not_of(const charT *str, const charT *set);

template&lt;class charT&gt;
charT *find_first_not_of(charT *str, const charT *set);

}
</pre>

<p>Find the first occurrence of the character absent in the specified set.
Generic <tt>strspn</tt> / <tt>wcsspn</tt>.</p>




<h3 id="tchar--find_last_of">
<span class="h3_num">2.28.17</span><tt>tchar::find_last_of()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT&gt;
const charT *find_last_of(const charT *str, const charT *set);

template&lt;class charT&gt;
charT *find_last_of(charT *str, const charT *set);

}
</pre>

<p>Find the last occurrence of the character from the specified set.</p>




<h3 id="tchar--find_last_not_of">
<span class="h3_num">2.28.18</span><tt>tchar::find_last_not_of()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT&gt;
const charT *find_last_not_of(const charT *str, const charT *set);

template&lt;class charT&gt;
charT *find_last_not_of(charT *str, const charT *set);

}
</pre>

<p>Find the last occurrence of the character absent in the specified set.</p>




<h3 id="tchar--skip">
<span class="h3_num">2.28.19</span><tt>tchar::skip()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT&gt;
const charT *skip(const charT *str, charT ch);

template&lt;class charT&gt;
charT *skip(charT *str, charT ch);

}
</pre>

<p>Skip all occurrences of the specified character and return the pointer.
Pointer to NULL-terminator is returned if no other characters is presented.</p>






<h2 id="thread.h">
<span class="h2_num">2.29</span><tt>__vic/thread.h</tt>
</h2>


<p>Threads support.</p>


<h3 id="thread">
<span class="h3_num">2.29.1</span><tt>thread</tt>
</h3>


<pre class="code">
class thread : private non_copyable
{
public:
    class id;
    using native_handle_type = <span class="nonterminal">&lt;implementation-defined&gt;</span>;

    thread();
    virtual ~thread();

    // BEGIN C++11
    thread(thread &amp;&amp;o) noexcept;
    thread &amp;operator=(thread &amp;&amp;o) noexcept;
    // END C++11

    void start();
    void cancel();
    void join();

    bool alive() const;
    bool joinable() const;
    void kill(int signo); // POSIX only

    id get_id() const;
    native_handle_type handle() const;
protected:
    virtual void worker() = 0;
};
</pre>

<p>Abstract base class for thread objects. Implements "Active object" pattern.
Inherit it and define <tt>worker()</tt> function which content will be executed
in the new thread after <tt>start()</tt> call. Then at some point in your
program you must call <tt>join()</tt> to free OS resources associated with the
spawned thread.</p>

<div>
<u><b>Note</b></u>: The object must always outlive the associated OS thread. Your program
will be terminated by <tt>std::terminate()</tt> call if this usage contract
is violated.</div>

<div class="section">Class members</div>

<div>
<pre class="prototype">thread()</pre>
<blockquote>

<div>
<u>Postcondition</u>: <tt>joinable() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">~thread()</pre>
<blockquote>

<p>Calls <tt>std::terminate()</tt> if precondition is not satisfied.</p>
<div>
<u>Precondition</u>: <tt>joinable() == false || alive() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">thread(thread &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Move constructor for C++11 mode.</p>
</blockquote>
</div>

<div>
<pre class="prototype">thread &amp;operator=(thread &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Move assignment for C++11 mode. Calls <tt>std::terminate()</tt> if
precondition is not satisfied.</p>
<div>
<u>Precondition</u>: <tt>joinable() == false || alive() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void start()</pre>
<blockquote>

<p>Spawns new thread and calls <tt>worker()</tt> there.</p>
<div>
<u>Precondition</u>: <tt>joinable() == false</tt>
</div>
<div>
<u>Postcondition</u>: <tt>joinable() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void cancel()</pre>
<blockquote>

<p>Cancels the thread execution.</p>
<div>
<u>Precondition</u>: <tt>joinable() == true</tt>
</div>
<div>
<u>Postcondition</u>: <tt>joinable() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void join()</pre>
<blockquote>

<p>Waits for the thread termination if running and makes
<tt>joinable() == false</tt>.</p>
<div>
<u>Precondition</u>: <tt>joinable() == true</tt>
</div>
<div>
<u>Postcondition</u>: <tt>joinable() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool alive() const</pre>
<blockquote>

<p>Returns <tt>true</tt> if the thread haven't been terminated yet
(<tt>worker()</tt> function haven't returned).</p>
<div>
<u>Precondition</u>: <tt>joinable() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool joinable() const</pre>
<blockquote>

<p>Returns <tt>true</tt> if the object has a corresponding OS object
(thread) created by the <tt>start()</tt> call and not yet destroyed by
<tt>join()</tt> call.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void kill(int signo) <span class="sign">[POSIX]</span></pre>
<blockquote>

<p>Sends the signal <tt>signo</tt> the thread.</p>
<div>
<u>Precondition</u>: <tt>joinable() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">id get_id() const</pre>
<blockquote>

<p>Returns ID of the thread.</p>
</blockquote>
</div>

<div>
<pre class="prototype">native_handle_type handle() const</pre>
<blockquote>

<p>Returns a native OS-specific handle of the thread.</p>
</blockquote>
</div>






<h3 id="thread--id">
<span class="h3_num">2.29.2</span><tt>thread::id</tt>
</h3>


<pre class="code">
class thread::id
{
public:
    id();
    explicit operator bool() const;
    native_handle_type handle() const;
};
bool operator==(thread::id a, thread::id b);
bool operator!=(thread::id a, thread::id b);
</pre>

<p>Unique thread ID. It can hold a value associated with some thread or the
special distinct value not associated with any thread.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">id()</pre>
<blockquote>

<p>Creates the special value not associated with any thread.</p>
<div>
<u>Postcondition</u>: <tt>bool(*this) == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">explicit operator bool() const</pre>
<blockquote>

<p>Returns <tt>true</tt> if the object holds ID of some thread.</p>
</blockquote>
</div>

<div>
<pre class="prototype">native_handle_type handle() const</pre>
<blockquote>

<p>Returns a native OS-specific handle of the thread.</p>
<div>
<u>Precondition</u>: <tt>bool(*this) == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool operator==(thread::id a, thread::id b)</pre>
<pre class="prototype">bool operator!=(thread::id a, thread::id b)</pre>
<blockquote>


<p>Check if <tt>a</tt> and <tt>b</tt> represent the same thread.</p>
<div>
<u>Invariant</u>: <tt>id() == id()</tt>
</div>
</blockquote>
</div>






<h3 id="this_thread">
<span class="h3_num">2.29.3</span><tt>this_thread</tt>
</h3>


<pre class="code">
namespace this_thread
{
    thread::id get_id();
    void sleep_ms(unsigned msec);
}
</pre>

<p>Set of the functions to control the current (calling) thread.</p>

<div>
<pre class="prototype">thread::id get_id()</pre>
<blockquote>

<p>Returns ID of the calling thread.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void sleep_ms(unsigned msec)</pre>
<blockquote>

<p>Suspends the execution of the calling thread until the time-out interval
specified in milliseconds elapses.</p>
</blockquote>
</div>






<h2 id="throw_errno.h">
<span class="h2_num">2.30</span><tt>__vic/throw_errno.h</tt>
</h2>


<h3 id="throw_errno">
<span class="h3_num">2.30.1</span><tt>throw_errno()</tt>
</h3>


<pre class="code">
[[noreturn]] void throw_errno(const char *prompt);
[[noreturn]] void throw_errno(const char *prompt, int err_no);
</pre>

<p>Throw an exception with global <tt>errno</tt> value or given
<tt>err_no</tt> correspondingly. Default exception type is
<a href="#libc_error"><tt>libc_error</tt></a> at the moment but can be changed at link time
by overriding this functions. For example <tt>std::system_error</tt> can be
used. Just create cpp-file with the following content in your project:</p>

<pre class="code">
#include&lt;__vic/throw_errno.h&gt;
#include&lt;system_error&gt;

//----------------------------------------------------------------------------
// Override library functions to throw std::system_error
//----------------------------------------------------------------------------
void __vic::throw_errno(const char *prompt, int err_no)
{
    throw std::system_error(err_no, std::system_category(), prompt);
}
//----------------------------------------------------------------------------
</pre>

<p>It's enough to override only one functions because the second one just calls
<tt>throw_errno(prompt, errno)</tt>.</p>

<div class="section">Example</div>
<pre class="code">
ssize_t written = ::write(fd, buf, buf_size);
if(written &lt; 0) __vic::throw_errno("write");
// ...
</pre>






<h2 id="to_text.h">
<span class="h2_num">2.31</span><tt>__vic/to_text.h</tt>
</h2>


<p>Converters of types to text representation.</p>


<h3 id="to_text_append">
<span class="h3_num">2.31.1</span><tt>to_text_append()</tt>
</h3>


<pre class="code">
void to_text_append(long long n, std::string &amp;str);
void to_text_append(long n, std::string &amp;str);
void to_text_append(int n, std::string &amp;str);
void to_text_append(short n, std::string &amp;str);
void to_text_append(signed char n, std::string &amp;str);

void to_text_append(unsigned long long n, std::string &amp;str);
void to_text_append(unsigned long n, std::string &amp;str);
void to_text_append(unsigned n, std::string &amp;str);
void to_text_append(unsigned short n, std::string &amp;str);
void to_text_append(unsigned char n, std::string &amp;str);

void to_text_append(long double n, std::string &amp;str);
void to_text_append(double n, std::string &amp;str);
void to_text_append(float n, std::string &amp;str);

void to_text_append(bool f, std::string &amp;str);

void to_text_append(const void *p, std::string &amp;str);
</pre>

<p>Converters of non-character C++ fundamental types to some text
representation. Second parameter <tt>str</tt> is an output parameter, result
is appended to it.</p>

<div>
<u><b>Note</b></u>: <tt>signed char</tt> and <tt>unsigned char</tt> types are treated as
integers not characters!</div>

<div>
<pre class="prototype">void to_text_append(long long n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(long n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(int n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(short n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(signed char n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(unsigned long long n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(unsigned long n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(unsigned n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(unsigned short n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(unsigned  char n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(long double n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(double n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(float n, std::string &amp;str)</pre>
<blockquote>













<p>Converts a number to decimal representation.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void to_text_append(bool f, std::string &amp;str)</pre>
<blockquote>

<p>Converts a boolean value to <tt>0</tt> or <tt>1</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void to_text_append(const void *p, std::string &amp;str)</pre>
<blockquote>

<p>Converts a pointer to some platform-specific representation.</p>
</blockquote>
</div>

<div class="section">Example</div>
<pre class="code">
int n = 5;
std::string st = "n = ";
__vic::to_text_append(n, st);
assert(st == "n = 5");
</pre>






<h2 id="type_traits.h">
<span class="h2_num">2.32</span><tt>__vic/type_traits.h</tt>
</h2>


<p>Template metaprogramming support.</p>
<p>All the predicate metafunctions have boolean member <tt>value</tt> and,
usually, derived from <tt>integral_constant</tt>.</p>
<p>All the type transformer metafunctions have type member <tt>type</tt>
containing the conversion result.</p>
<p>All of the template aliases are available only in C++11 mode.</p>


<h3 id="integral_constant">
<span class="h3_num">2.32.1</span><tt>integral_constant</tt>
</h3>


<pre class="code">
template&lt;class T, T Val&gt;
struct integral_constant
{
    using value_type = T;
    using type = integral_constant&lt;T, Val&gt;;

    static constexpr T value = Val;
};
</pre>

<p>The topmost base class of the most metafunctions.</p>




<h3 id="true_type">
<span class="h3_num">2.32.2</span><tt>true_type</tt>
</h3>


<pre class="code">
using true_type = integral_constant&lt;bool, true&gt;;
</pre>

<p>Base class for predicate metafunctions that have value <tt>true</tt>.</p>




<h3 id="false_type">
<span class="h3_num">2.32.3</span><tt>false_type</tt>
</h3>


<pre class="code">
using false_type = integral_constant&lt;bool, false&gt;;
</pre>

<p>Base class for predicate metafunctions that have value <tt>false</tt>.</p>




<h3 id="is_same">
<span class="h3_num">2.32.4</span><tt>is_same</tt>
</h3>


<pre class="code">
template&lt;class T1, class T2&gt; struct is_same;
</pre>

<p>A predicate. True if <tt>T1</tt> and <tt>T2</tt> are exactly the same
type.</p>




<h3 id="is_const">
<span class="h3_num">2.32.5</span><tt>is_const</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct is_const;
</pre>

<p>A predicate. True if <tt>T</tt> has <tt>const</tt> qualifier.</p>




<h3 id="is_signed_integer">
<span class="h3_num">2.32.6</span><tt>is_signed_integer</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct is_signed_integer;
</pre>

<p>A predicate. True if <tt>T</tt> is a one of the "standard signed integer
types" (see the Standard).</p>




<h3 id="is_unsigned_integer">
<span class="h3_num">2.32.7</span><tt>is_unsigned_integer</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct is_unsigned_integer;
</pre>

<p>A predicate. True if <tt>T</tt> is a one of the "standard unsigned integer
types" (see the Standard).</p>




<h3 id="remove_const">
<span class="h3_num">2.32.8</span><tt>remove_const</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct remove_const;
template&lt;class T&gt; using remove_const_t = typename remove_const&lt;T&gt;::type;
</pre>

<p>A type transformer. Removes the top-level <tt>const</tt> qualifier or just
returns <tt>T</tt> if it doesn't have such qualifier.</p>




<h3 id="remove_volatile">
<span class="h3_num">2.32.9</span><tt>remove_volatile</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct remove_volatile;
template&lt;class T&gt; using remove_volatile_t = typename remove_volatile&lt;T&gt;::type;
</pre>

<p>A type transformer. Removes the top-level <tt>volatile</tt> qualifier or just
returns <tt>T</tt> if it doesn't have such qualifier.</p>




<h3 id="remove_cv">
<span class="h3_num">2.32.10</span><tt>remove_cv</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct remove_cv;
template&lt;class T&gt; using remove_cv_t = typename remove_cv&lt;T&gt;::type;
</pre>

<p>A type transformer. Removes any top-level cv-qualifier or just returns
<tt>T</tt> if it doesn't have such qualifiers.</p>




<h3 id="remove_reference">
<span class="h3_num">2.32.11</span><tt>remove_reference</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct remove_reference;
template&lt;class T&gt; using remove_reference_t = typename remove_reference&lt;T&gt;::type;
</pre>

<p>A type transformer. Returns the type referred by <tt>T</tt> or just
<tt>T</tt> if it isn't a reference type.</p>




<h3 id="remove_cvref">
<span class="h3_num">2.32.12</span><tt>remove_cvref</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct remove_cvref;
template&lt;class T&gt; using remove_cvref_t = typename remove_cvref&lt;T&gt;::type;
</pre>

<p>A type transformer. Applies <tt>remove_reference</tt> then <tt>remove_cv</tt>
to <tt>T</tt>.</p>




<h3 id="remove_pointer">
<span class="h3_num">2.32.13</span><tt>remove_pointer</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct remove_pointer;
template&lt;class T&gt; using remove_pointer_t = typename remove_pointer&lt;T&gt;::type;
</pre>

<p>A type transformer. Returns the type pointed by <tt>T</tt> or just
<tt>T</tt> if it isn't a pointer type.</p>




<h3 id="enable_if">
<span class="h3_num">2.32.14</span><tt>enable_if</tt>, <tt>disable_if</tt>
</h3>


<pre class="code">
template&lt;bool Test, class T = void&gt;
struct enable_if
{
    using type = T;
};
template&lt;class T&gt;
struct enable_if&lt;false, T&gt; {};

template&lt;bool Test, class T = void&gt;
struct disable_if : enable_if&lt;!Test, T&gt; {};
</pre>

<p>Classical tools for SFINAE-magic.</p>




<h3 id="index_sequence">
<span class="h3_num">2.32.15</span><tt>index_sequence</tt>, <tt>make_index_sequence</tt> <span class="sign">[C++11]</span>
</h3>


<pre class="code">
template&lt;size_t... I&gt;
struct index_sequence
{
    static constexpr size_t size() { return sizeof...(I); }
};

template&lt;size_t Size&gt;
using make_index_sequence = index_sequence&lt;0, 1, ..., Size-1&gt;;
</pre>

<p>Implementation of C++14 <tt>std::index_sequence</tt> for C++11.</p>

<div>
<u><b>Note</b></u>: Unlike <tt>std::index_sequence</tt> it isn't a special case of some sort
of <tt>std::integer_sequence</tt>.</div>






<h2 id="unicode.h">
<span class="h2_num">2.33</span><tt>__vic/unicode.h</tt>
</h2>


<p><a href="https://www.unicode.org/">Unicode</a> support utilities.</p>


<h3 id="unicode_t">
<span class="h3_num">2.33.1</span><tt>unicode_t</tt>
</h3>


<pre class="code">
using unicode_t = char32_t; // since C++11
// or
using unicode_t = uint_least32_t; // C++98
</pre>

<p>Type able to store any Unicode
<a href="https://www.unicode.org/glossary/#code_point">code point</a>.</p>




<h3 id="utf_transcode">
<span class="h3_num">2.33.2</span><tt>utf_transcode()</tt>
</h3>


<pre class="code">
template&lt;class UTFReader, class UTFWriter&gt;
void utf_transcode(UTFReader r, UTFWriter w);
</pre>

<p>An algorithm that reads all code points of type <a href="#unicode_t"><tt>unicode_t</tt></a> from
<tt>UTFReader</tt> using <tt>r.read()</tt> and writes them to <tt>UTFWriter</tt>
using <tt>w.write()</tt>.</p>




<h3 id="unicode_code_point_constants">
<span class="h3_num">2.33.3</span><tt>Code point constants</tt>
</h3>


<pre class="code">
constexpr unicode_t unicode_max = 0x10FFFF;
constexpr unicode_t unicode_bom = 0xFEFF;
constexpr unicode_t unicode_replacement_char = 0xFFFD;
</pre>

<p>Named constants for some useful Unicode code points.</p>






<h2 id="utf8.status.h">
<span class="h2_num">2.34</span><tt>__vic/utf8/status.h</tt>
</h2>



<h3 id="utf8--status">
<span class="h3_num">2.34.1</span><tt>utf8::status</tt>
</h3>


<pre class="code">
enum class utf8::status
{
    ok = 0,
    eof,
    // Errors
    no_leading_byte,
    truncated_code_point,
    overlong_encoding,
    code_point_too_big
};
using utf8::status_t = utf8::status; // for C++98
</pre>

<p>Values returned by <a href="#utf8--reader"><tt>utf8::reader</tt></a> <tt>parse()</tt> function.</p>

<ul>
<li>
<tt>ok</tt> - code point successfully read</li>
<li>
<tt>eof</tt> - no more code points to read</li>
<li>
<tt>no_leading_byte</tt> - continuation byte w/o leading</li>
<li>
<tt>truncated_code_point</tt> - incomplete multibyte sequence</li>
<li>
<tt>overlong_encoding</tt> - overlong encoded code point</li>
<li>
<tt>code_point_too_big</tt> - code point value is too big</li>
</ul>




<h3 id="utf8--is_error">
<span class="h3_num">2.34.2</span><tt>utf8::is_error()</tt>
</h3>


<pre class="code">
constexpr bool utf8::is_error(utf8::status s);
</pre>

<p>Returns <tt>false</tt> for <tt>utf8::status::ok</tt> and
<tt>utf8::status::eof</tt> values. <tt>true</tt> is returned otherwise.</p>




<h3 id="utf8--throw_if_error">
<span class="h3_num">2.34.3</span><tt>utf8::throw_if_error()</tt>
</h3>


<pre class="code">
bool utf8::throw_if_error(utf8::status s);
</pre>

<p>Throws exception from <a href="#utf8.exceptions.h"><tt>__vic/utf8/exceptions.h</tt></a> if
<tt>is_error(s)</tt>. Returns <tt>true</tt> for <tt>utf8::status::ok</tt>
or <tt>false</tt> for <tt>utf8::status::eof</tt>.</p>






<h2 id="utf8.exceptions.h">
<span class="h2_num">2.35</span><tt>__vic/utf8/exceptions.h</tt>
</h2>


<pre class="code">
namespace utf8 {

class bad_encoding; // public std::exception
    class no_leading_byte;
    class truncated_code_point;
    class overlong_encoding;
    class code_point_too_big;

} // namespace
</pre>

<p>Exception classes thrown by <a href="#utf8--reader"><tt>utf8::reader</tt></a> <tt>read()</tt>
function. All exceptions are derived from abstract base class
<tt>utf8::bad_encoding</tt>. See <a href="#utf8--status"><tt>utf8::status</tt></a> for equivalent
status codes.</p>



<h2 id="utf8.reader.h">
<span class="h2_num">2.36</span><tt>__vic/utf8/reader.h</tt>
</h2>


<h3 id="utf8--reader">
<span class="h3_num">2.36.1</span><tt>utf8::reader</tt>
</h3>


<pre class="code">
template&lt;class ByteReader&gt;
class utf8::reader
{
public:
    using byte_reader_type = ByteReader;
    ByteReader &amp;get_byte_reader();
    const ByteReader &amp;get_byte_reader() const;

    template&lt;class... Args&gt;
    explicit reader(Args&amp;&amp;... args); // since C++11

    reader(); // C++98 only
    explicit reader(ByteReader r); // C++98 only

    status_t parse(unicode_t &amp;cp);
    bool read(unicode_t &amp;cp);
};

template&lt;class ByteReader&gt;
utf8::reader&lt;ByteReader&gt; utf8::make_reader(ByteReader r);
</pre>

<p>UTF-8 code points from byte sequence reader. The sequence is accessed using
<tt>ByteReader</tt> which models <tt>Reader&lt;unsigned char&gt;</tt> (see
<a href="#readers"><tt>__vic/readers/</tt></a>).</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">ByteReader &amp;get_byte_reader()</pre>
<pre class="prototype">const ByteReader &amp;get_byte_reader() const</pre>
<blockquote>


<p>Returns reference to the used byte reader.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class... Args&gt;
explicit reader(Args&amp;&amp;... args) <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Forwards all parameters to the used byte reader.</p>
</blockquote>
</div>

<div>
<pre class="prototype">reader() <span class="sign">[C++98 only]</span></pre>
<pre class="prototype">explicit reader(ByteReader r) <span class="sign">[C++98 only]</span></pre>
<blockquote>


<p>Constructors for C++98 mode.</p>
</blockquote>
</div>

<div>
<pre class="prototype">status_t parse(unicode_t &amp;cp)</pre>
<blockquote>

<p>Tries to extract the next code point from byte sequence using
<tt>ByteReader</tt>. On success <tt>utf8::status::ok</tt> is returned and the
code point is stored in <tt>cp</tt>. <tt>utf8::status::eof</tt> is returned
when no more bytes available. Other values are returned on errors, see
<a href="#utf8--status"><tt>utf8::status</tt></a> for more details. <tt>ByteReader::read()</tt> is
used to access individual bytes.</p>
<div>
<u>Note</u>: The function itself doesn't throw exceptions but exception can be
thrown by <tt>ByteReader::read()</tt>.</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool read(unicode_t &amp;cp)</pre>
<blockquote>

<p>Same as <tt>parse()</tt> but returns <tt>true</tt> on success, <tt>false</tt>
on EOF or throws an exception from <a href="#utf8.exceptions.h"><tt>__vic/utf8/exceptions.h</tt></a> otherwise.</p>
</blockquote>
</div>



<div class="section">Free functions</div>

<div>
<pre class="prototype">template&lt;class ByteReader&gt;
utf8::reader&lt;ByteReader&gt; utf8::make_reader(ByteReader r)</pre>
<blockquote>

<p>Creates UTF-8 reader using specified <tt>ByteReader</tt>.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
#include&lt;__vic/utf8/reader.h&gt;
#include&lt;__vic/readers/string.h&gt;
#include&lt;string&gt;
#include&lt;cstdint&gt;
#include&lt;iostream&gt;

// C++11
using utf8_string_reader = __vic::utf8::reader&lt;__vic::string_reader&gt;;

// C++98
struct utf8_string_reader : __vic::utf8::reader&lt;__vic::string_reader&gt;
{
    explicit utf8_string_reader(const std::string &amp;s)
        : __vic::utf8::reader&lt;__vic::string_reader&gt;(__vic::string_reader(s)) {}
};

void print_utf8_code_points(const string &amp;s)
{
    utf8_string_reader r(s);
    __vic::unicode_t cp;
    while(r.read(cp))
        std::cout &lt;&lt; uint_least32_t(cp) &lt;&lt; '\n';
}
</pre>






<h2 id="utf8.writer.h">
<span class="h2_num">2.37</span><tt>__vic/utf8/writer.h</tt>
</h2>


<h3 id="utf8--writer">
<span class="h3_num">2.37.1</span><tt>utf8::writer</tt>
</h3>


<pre class="code">
template&lt;class ByteWriter&gt;
class utf8::writer
{
public:
    using byte_writer_type = ByteWriter;
    ByteWriter &amp;get_byte_writer();
    const ByteWriter &amp;get_byte_writer() const;

    template&lt;class... Args&gt;
    explicit writer(Args&amp;&amp;... args); // since C++11

    writer(); // C++98 only
    explicit writer(ByteWriter w); // C++98 only

    void write(unicode_t cp);
};

template&lt;class ByteWriter&gt;
utf8::writer&lt;ByteWriter&gt; utf8::make_writer(ByteWriter w);
</pre>

<p>UTF-8 code points to byte sequence writer. <tt>ByteWriter</tt>
which models <tt>Writer&lt;unsigned char&gt;</tt> (see <a href="#writers"><tt>__vic/writers/</tt></a>)
is used as a byte output.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">ByteWriter &amp;get_byte_writer()</pre>
<pre class="prototype">const ByteWriter &amp;get_byte_writer() const</pre>
<blockquote>


<p>Returns reference to the used byte writer.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class... Args&gt;
explicit writer(Args&amp;&amp;... args) <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Forwards all parameters to the used byte writer.</p>
</blockquote>
</div>

<div>
<pre class="prototype">writer() <span class="sign">[C++98 only]</span></pre>
<pre class="prototype">explicit writer(ByteWriter r) <span class="sign">[C++98 only]</span></pre>
<blockquote>


<p>Constructors for C++98 mode.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void write(unicode_t cp)</pre>
<blockquote>

<p>Writes the specified code point according to UTF-8 encoding rules.
<tt>ByteWriter::write()</tt> is used to write individual bytes.</p>
</blockquote>
</div>



<div class="section">Free functions</div>

<div>
<pre class="prototype">template&lt;class ByteWriter&gt;
utf8::writer&lt;ByteWriter&gt; utf8::make_writer(ByteWriter w)</pre>
<blockquote>

<p>Creates UTF-8 writer using specified <tt>ByteWriter</tt>.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
#include&lt;__vic/utf8/writer.h&gt;
#include&lt;__vic/writers/string.h&gt;
#include&lt;string&gt;
#include&lt;vector&gt;

// C++11
using utf8_string_writer = __vic::utf8::writer&lt;__vic::string_writer&gt;;

// C++98
struct utf8_string_writer : __vic::utf8::writer&lt;__vic::string_writer&gt;
{
    explicit utf8_string_writer(std::string &amp;s)
        : __vic::utf8::writer&lt;__vic::string_writer&gt;(__vic::string_writer(s)) {}
};

std::string encode_utf8(const std::vector&lt;__vic::unicode_t&gt; &amp;code_points)
{
    std::string utf8_res;
    utf8_string_writer w(utf8_res);
    for(auto cp : code_points) w.write(cp);
    return utf8_res;
}
</pre>






<h2 id="utf16.defs.h">
<span class="h2_num">2.38</span><tt>__vic/utf16/defs.h</tt>
</h2>


<h3 id="utf16--code_unit_t">
<span class="h3_num">2.38.1</span><tt>utf16::code_unit_t</tt>
</h3>


<pre class="code">
namespace utf16 {

using code_unit_t = char16_t; // since C++11
// or
using code_unit_t = uint_least16_t; // C++98

} // namespace
</pre>

<p>UTF-16 <a href="https://unicode.org/glossary/#code_unit">code unit</a>
type.</p>





<h2 id="utf16.status.h">
<span class="h2_num">2.39</span><tt>__vic/utf16/status.h</tt>
</h2>



<h3 id="utf16--status">
<span class="h3_num">2.39.1</span><tt>utf16::status</tt>
</h3>


<pre class="code">
enum class utf16::status
{
    ok = 0,
    eof,
    // Errors
    truncated_code_unit,
    truncated_code_point,
    invalid_sequence
};
using utf16::status_t = utf16::status; // for C++98
</pre>

<p>Values returned by <a href="#utf16--reader"><tt>utf16::reader</tt></a> <tt>parse()</tt> function.</p>

<ul>
<li>
<tt>ok</tt> - code point successfully read</li>
<li>
<tt>eof</tt> - no more code points to read</li>
<li>
<tt>truncated_code_unit</tt> - incomplete code unit</li>
<li>
<tt>truncated_code_point</tt> - incomplete code point</li>
<li>
<tt>invalid_sequence</tt> - the bytes don't represent any valid
        UTF-16 code point</li>
</ul>




<h3 id="utf16--is_error">
<span class="h3_num">2.39.2</span><tt>utf16::is_error()</tt>
</h3>


<pre class="code">
constexpr bool utf16::is_error(utf16::status s);
</pre>

<p>Returns <tt>false</tt> for <tt>utf16::status::ok</tt> and
<tt>utf16::status::eof</tt> values. <tt>true</tt> is returned otherwise.</p>




<h3 id="utf16--throw_if_error">
<span class="h3_num">2.39.3</span><tt>utf16::throw_if_error()</tt>
</h3>


<pre class="code">
bool utf16::throw_if_error(utf16::status s);
</pre>

<p>Throws exception from <a href="#utf16.exceptions.h"><tt>__vic/utf16/exceptions.h</tt></a> if
<tt>is_error(s)</tt>. Returns <tt>true</tt> for <tt>utf16::status::ok</tt>
or <tt>false</tt> for <tt>utf16::status::eof</tt>.</p>






<h2 id="utf16.exceptions.h">
<span class="h2_num">2.40</span><tt>__vic/utf16/exceptions.h</tt>
</h2>


<pre class="code">
namespace utf16 {

class bad_encoding; // public std::exception
    class truncated_code_unit;
    class truncated_code_point;
    class invalid_sequence;

} // namespace
</pre>

<p>Exception classes thrown by <a href="#utf16--reader"><tt>utf16::reader</tt></a> <tt>read()</tt>
function. All exceptions are derived from abstract base class
<tt>utf16::bad_encoding</tt>. See <a href="#utf16--status"><tt>utf16::status</tt></a> for equivalent
status codes.</p>



<h2 id="utf16.reader.h">
<span class="h2_num">2.41</span><tt>__vic/utf16/reader.h</tt>
</h2>


<h3 id="utf16--reader">
<span class="h3_num">2.41.1</span><tt>utf16::reader</tt>
</h3>


<pre class="code">
template&lt;class CodeUnitReader&gt;
class utf16::reader
{
public:
    using code_unit_reader_type = CodeUnitReader;
    CodeUnitReader &amp;get_code_unit_reader();
    const CodeUnitReader &amp;get_code_unit_reader() const;

    template&lt;class... Args&gt;
    explicit reader(Args&amp;&amp;... args);  // since C++11

    reader(); // C++98 only
    explicit reader(CodeUnitReader r); // C++98 only

    status_t parse(unicode_t &amp;cp);
    bool read(unicode_t &amp;cp);
};

template&lt;class CodeUnitReader&gt;
utf16::reader&lt;CodeUnitReader&gt; utf16::make_reader(CodeUnitReader r);
</pre>

<p>UTF-16 code points from 2-byte <a href="#utf16--code_unit_t"><tt>utf16::code_unit_t</tt></a> sequence
reader. The sequence is accessed using the special reader of the following
structure:</p>

<pre class="code">
class <span class="nonterminal">CodeUnitReader</span>
{
public:
    utf16::status_t read_unit(utf16::code_unit_t &amp;u);
};
</pre>

<div>
<pre class="prototype">utf16::status_t read_unit(utf16::code_unit_t &amp;u)</pre>
<blockquote>

<p>Tries to read the next code unit. Returns <tt>utf16::status::ok</tt> on
success, <tt>utf16::status::eof</tt> if no more code units available or
<tt>utf16::status::truncated_code_unit</tt> if only partial code unit
is available.</p>
</blockquote>
</div>

<div class="section">Class members</div>

<div>
<pre class="prototype">CodeUnitReader &amp;get_code_unit_reader()</pre>
<pre class="prototype">const CodeUnitReader &amp;get_code_unit_reader() const</pre>
<blockquote>


<p>Returns reference to the used code unit reader.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class... Args&gt;
explicit reader(Args&amp;&amp;... args) <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Forwards all parameters to the used code unit reader.</p>
</blockquote>
</div>

<div>
<pre class="prototype">reader() <span class="sign">[C++98 only]</span></pre>
<pre class="prototype">explicit reader(CodeUnitReader r) <span class="sign">[C++98 only]</span></pre>
<blockquote>


<p>Constructors for C++98 mode.</p>
</blockquote>
</div>

<div>
<pre class="prototype">status_t parse(unicode_t &amp;cp)</pre>
<blockquote>

<p>Tries to extract the next code point from code unit sequence using
<tt>CodeUnitReader</tt>. On success <tt>utf16::status::ok</tt> is returned and
the code point is stored in <tt>cp</tt>. <tt>utf16::status::eof</tt> is
returned when no more code units available. Other values are returned on errors,
see <a href="#utf16--status"><tt>utf16::status</tt></a> for more details.
<tt>CodeUnitReader::read_unit()</tt> is used to access code units.</p>
<div>
<u>Note</u>: The function itself doesn't throw exceptions but exception can be
thrown by <tt>CodeUnitReader::read_unit()</tt>.</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool read(unicode_t &amp;cp)</pre>
<blockquote>

<p>Same as <tt>parse()</tt> but returns <tt>true</tt> on success, <tt>false</tt>
on EOF or throws an exception from <a href="#utf16.exceptions.h"><tt>__vic/utf16/exceptions.h</tt></a> otherwise.</p>
</blockquote>
</div>



<div class="section">Free functions</div>

<div>
<pre class="prototype">template&lt;class CodeUnitReader&gt;
utf16::reader&lt;CodeUnitReader&gt; utf16::make_reader(CodeUnitReader r)</pre>
<blockquote>

<p>Creates UTF-16 reader using specified <tt>CodeUnitReader</tt>.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
#include&lt;__vic/utf16/reader.h&gt;
#include&lt;__vic/readers/string.h&gt;
#include&lt;string&gt;
#include&lt;cstdint&gt;
#include&lt;iostream&gt;

class u16string_code_unit_reader
{
    __vic::basic_string_reader&lt;char16_t&gt; r;
public:
    explicit u16string_code_unit_reader(const std::u16string &amp;s) : r(s) {}

    __vic::utf16::status_t read_unit(__vic::utf16::code_unit_t &amp;u)
    {
        if(r.read(u)) return __vic::utf16::status::ok;
        return __vic::utf16::status::eof;
    }
};

void print_utf16_code_points(const std::u16string &amp;s)
{
    __vic::utf16::reader&lt;u16string_code_unit_reader&gt; r(s);
    __vic::unicode_t cp;
    while(r.read(cp))
        std::cout &lt;&lt; uint_least32_t(cp) &lt;&lt; '\n';
}
</pre>






<h2 id="utf16.writer.h">
<span class="h2_num">2.42</span><tt>__vic/utf16/writer.h</tt>
</h2>


<h3 id="utf16--writer">
<span class="h3_num">2.42.1</span><tt>utf16::writer</tt>
</h3>


<pre class="code">
template&lt;class CodeUnitWriter&gt;
class utf16::writer
{
public:
    using code_unit_writer_type = CodeUnitWriter;
    CodeUnitWriter &amp;get_code_unit_writer();
    const CodeUnitWriter &amp;get_code_unit_writer() const;

    template&lt;class... Args&gt;
    explicit writer(Args&amp;&amp;... args); // since C++11

    writer(); // C++98 only
    explicit writer(CodeUnitWriter w); // C++98 only

    void write(unicode_t cp);
};

template&lt;class CodeUnitWriter&gt;
utf16::writer&lt;CodeUnitWriter&gt; utf16::make_writer(CodeUnitWriter w);
</pre>

<p>UTF-16 code points to 2-byte <a href="#utf16--code_unit_t"><tt>utf16::code_unit_t</tt></a> sequence writer.
<tt>CodeUnitWriter</tt> which models <tt>Writer&lt;utf16::code_unit_t&gt;</tt>
(see <a href="#writers"><tt>__vic/writers/</tt></a>) is used as a code units output.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">CodeUnitWriter &amp;get_code_unit_writer()</pre>
<pre class="prototype">const CodeUnitWriter &amp;get_code_unit_writer() const</pre>
<blockquote>


<p>Returns reference to the used code unit writer.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class... Args&gt;
explicit writer(Args&amp;&amp;... args) <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Forwards all parameters to the used code unit writer.</p>
</blockquote>
</div>

<div>
<pre class="prototype">writer() <span class="sign">[C++98 only]</span></pre>
<pre class="prototype">explicit writer(CodeUnitWriter r) <span class="sign">[C++98 only]</span></pre>
<blockquote>


<p>Constructors for C++98 mode.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void write(unicode_t cp)</pre>
<blockquote>

<p>Writes the specified code point according to UTF-16 encoding rules.
<tt>CodeUnitWriter::write()</tt> is used to write individual code units.</p>
</blockquote>
</div>



<div class="section">Free functions</div>

<div>
<pre class="prototype">template&lt;class CodeUnitWriter&gt;
utf16::writer&lt;CodeUnitWriter&gt; utf16::make_writer(CodeUnitWriter w)</pre>
<blockquote>

<p>Creates UTF-16 writer using specified <tt>CodeUnitWriter</tt>.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
#include&lt;__vic/utf16/writer.h&gt;
#include&lt;__vic/writers/string.h&gt;
#include&lt;string&gt;
#include&lt;vector&gt;

std::u16string encode_utf16(const std::vector&lt;__vic::unicode_t&gt; &amp;code_points)
{
    std::u16string utf16_res;
    __vic::utf16::writer&lt;__vic::basic_string_writer&lt;char16_t&gt;&gt; w(utf16_res);
    for(auto cp : code_points) w.write(cp);
    return utf16_res;
}
</pre>






<h2 id="waitable_event.h">
<span class="h2_num">2.43</span><tt>__vic/waitable_event.h</tt>
</h2>


<h3 id="waitable_event">
<span class="h3_num">2.43.1</span><tt>waitable_event</tt>
</h3>


<pre class="code">
class waitable_event : private non_copyable
{
public:
    explicit waitable_event(bool signaled = false);
    ~waitable_event();

    void set();
    void reset();
    bool signaled() const;

    void wait();
    bool wait_ms(unsigned msec);

    // BEGIN C++11
    template&lt;class Rep, class Period&gt;
    bool wait_for(const std::chrono::duration&lt;Rep,Period&gt; &amp;d);
    template&lt;class Clock, class Duration&gt;
    bool wait_until(const std::chrono::time_point&lt;Clock,Duration&gt; &amp;t);
    // END C++11
};

</pre>

<p>A synchronization object like Event Object in Windows. Can be in ether of
two states: signaled or nonsignaled. A thread can effectively wait for the
signaled state using one of the available wait-functions (with minimal system
resources consumption).</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">explicit waitable_event(bool signaled = false)</pre>
<blockquote>

<div>
<u>Postcondition</u>: <tt>signaled() == signaled</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool signaled() const</pre>
<blockquote>

<p>Returns <tt>true</tt> if the object is in signaled state.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void set()</pre>
<blockquote>

<p>Sets the signaled state.</p>
<div>
<u>Postcondition</u>: <tt>signaled() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void reset()</pre>
<blockquote>

<p>Sets the nonsignaled state.</p>
<div>
<u>Postcondition</u>: <tt>signaled() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void wait()</pre>
<blockquote>

<p>Waits for the signaled state with no timeout.</p>
<div>
<u>Postcondition</u>: <tt>signaled() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool wait_ms(unsigned msec)</pre>
<blockquote>

<p>Waits for the signaled state no longer than the specified amount of
milliseconds. Returns <tt>signaled()</tt>.</p>
<div>
<u>Note</u>: <tt>wait_for()</tt> should be used in C++11 mode instead.</div>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class Rep, class Period&gt;
bool wait_for(const std::chrono::duration&lt;Rep,Period&gt; &amp;d) <span class="sign">[C++11]</span></pre>
<pre class="prototype">template&lt;class Clock, class Duration&gt;
bool wait_until(const std::chrono::time_point&lt;Clock,Duration&gt; &amp;t) <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Waits for the signaled state no longer than the specified timeout. Returns
<tt>signaled()</tt>.</p>
</blockquote>
</div>







<h2 id="writers">
<span class="h2_num">2.44</span><tt>__vic/writers/</tt>
</h2>



<h3 id="writer-concept">
<span class="h3_num">2.44.1</span><tt>Writer</tt> concept</h3>


<pre class="code">
template&lt;class ElementT&gt;
class <span class="nonterminal">Writer</span>
{
public:
    Writer(Writer &amp;&amp;o); or Writer(const Writer &amp;o);
    void write(ElementT v); // throws on errors
};
</pre>

<p>A concept used by the library algorithms to write logical sequence of elements
of type <tt>ElementT</tt> element by element. It is a generalization and rework
of the <tt>OutputIterator</tt> concept. In particular it handles streams
and other output sequences where <tt>end</tt>-iterator is meaningless or
expensive to obtain better. At the same time, a traditional output iterators
are just a particular case and fully and well handled by
<tt>__vic::iterator_writer</tt> adapter.</p>

<p>When the particular class meets the requirements of this concept for some
<tt>ElementT = T</tt> it is said <b>to model</b> the <tt>Writer&lt;T&gt;</tt>
concept.</p>

<p>Each instance of the class has to be move- or copy-constructible.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">void write(ElementT v)</pre>
<blockquote>

<p>Writes the element or throws an exception on error.</p>
</blockquote>
</div>






<h3 id="null_writer">
<span class="h3_num">2.44.2</span><tt>null_writer</tt>
</h3>


<pre class="code">
#include&lt;__vic/writers/null.h&gt;

class null_writer
{
public:
    template&lt;class T&gt; void write(T v) {}
};

null_writer make_null_writer();
</pre>

<p>Fake writer that accepts any value and does nothing with it (like UNIX
<tt>/dev/null</tt>).</p>




<h3 id="push_back_writer">
<span class="h3_num">2.44.3</span><tt>push_back_writer</tt>
</h3>


<pre class="code">
#include&lt;__vic/writers/push_back.h&gt;

template&lt;class Cont, class T = typename Cont::value_type&gt;
class push_back_writer
{
public:
    explicit push_back_writer(Cont &amp;c);
    void write(T v) { c-&gt;push_back(v); }
};

template&lt;class Cont&gt;
push_back_writer&lt;Cont&gt; make_push_back_writer(Cont &amp;c);

template&lt;class T, class Cont&gt;
push_back_writer&lt;Cont,T&gt; make_push_back_writer_for(Cont &amp;c);
</pre>

<p>An adapter. Uses <tt>push_back()</tt> member function to write elements.
Can be created using constructor or one of <tt>make_...</tt> functions.</p>




<h3 id="iterator_writer">
<span class="h3_num">2.44.4</span><tt>iterator_writer</tt>
</h3>


<pre class="code">
#include&lt;__vic/writers/iterator.h&gt;

template&lt;class OutputIterator,
         class T = typename std::iterator_traits&lt;OutputIterator&gt;::value_type&gt;
class iterator_writer
{
public:
    explicit iterator_writer(OutputIterator it);
    void write(T v);
};

template&lt;class OutputIterator&gt;
iterator_writer&lt;OutputIterator&gt; make_iterator_writer(OutputIterator it);

template&lt;class T, class OutputIterator&gt;
iterator_writer&lt;OutputIterator,T&gt; make_iterator_writer_for(OutputIterator it);
</pre>

<p>Output iterator writer. Can be created using constructor or one of
<tt>make_...</tt> functions.</p>




<h3 id="string_writer">
<span class="h3_num">2.44.5</span><tt>string_writer</tt>
</h3>


<pre class="code">
#include&lt;__vic/writers/string.h&gt;

template&lt;
    class charT,
    class Tr = std::char_traits&lt;charT&gt;,
    class Al = std::allocator&lt;charT&gt;
&gt;
class basic_string_writer
{
public:
    explicit basic_string_writer(std::basic_string&lt;charT,Tr,Al&gt; &amp;s);
    void write(charT ch);
};

using string_writer = basic_string_writer&lt;char&gt;;

template&lt;class charT, class Tr, class Al&gt;
basic_string_writer&lt;charT,Tr,Al&gt;
    make_string_writer(std::basic_string&lt;charT,Tr,Al&gt; &amp;s);
</pre>

<p>An adapter for <tt>std::basic_string</tt>. Can be created using constructor
or <tt>make_...</tt> function.</p>




<h3 id="cstream_writer">
<span class="h3_num">2.44.6</span><tt>cstream_writer</tt>
</h3>


<pre class="code">
#include&lt;__vic/writers/cstream.h&gt;

class cstream_writer
{
public:
    explicit cstream_writer(std::FILE *fp);
    void write(char ch) { __vic::write(fp, ch); }
};

cstream_writer make_cstream_writer(std::FILE *fp);
</pre>

<p>Models <tt>Writer&lt;char&gt;</tt> for <tt>std::FILE</tt>. Can be created using
constructor or <tt>make_...</tt> function.</p>






<h2 id="posix.cond_variable.h">
<span class="h2_num">2.45</span><tt>__vic/posix/cond_variable.h</tt>
</h2>


<h3 id="posix--cond_variable">
<span class="h3_num">2.45.1</span><tt>posix::cond_variable</tt>
</h3>


<pre class="code">
class posix::cond_variable
{
public:
    constexpr cond_variable() noexcept;
    ~cond_variable();

    cond_variable(const cond_variable &amp; ) = delete;
    cond_variable &amp;operator=(const cond_variable &amp; ) = delete;

    void wait(::pthread_mutex_t &amp;m);
    void wait(posix::mutex &amp;m);

    bool wait_until(::pthread_mutex_t &amp;m, const ::timespec &amp;abstime);
    bool wait_until(posix::mutex &amp;m, const ::timespec &amp;abstime);

    void signal();
    void broadcast();

    // C++11-compatible synonyms
    void notify_one() { signal(); }
    void notify_all() { broadcast(); }
};
</pre>

<p>POSIX condition variable.</p>

<div>
<u><b>Note</b></u>: In Ð¡++11 mode <tt>std::condition_variable</tt> can be a better
alternative.</div>

<div class="section">Class members</div>

<div>
<pre class="prototype">cond_variable()</pre>
<blockquote>

<p>Creates the object.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~cond_variable()</pre>
<blockquote>

<p>Destroys the object.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void wait(::pthread_mutex_t &amp;m)</pre>
<pre class="prototype">void wait(posix::mutex &amp;m)</pre>
<blockquote>


<p>Block the calling thread and waits for notification.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool wait_until(::pthread_mutex_t &amp;m, const ::timespec &amp;abstime)</pre>
<pre class="prototype">bool wait_until(posix::mutex &amp;m, const ::timespec &amp;abstime)</pre>
<blockquote>


<p>As <tt>wait()</tt> but waiting time is restricted by the timeout. Returns
<tt>true</tt> if notifcation was received and <tt>false</tt> if timeout was
expired.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void signal()</pre>
<pre class="prototype">void notify_one()</pre>
<blockquote>


<p>Notifies one of the waiting threads.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void broadcast()</pre>
<pre class="prototype">void notify_all()</pre>
<blockquote>


<p>Notifies all waiting threads.</p>
</blockquote>
</div>







<h2 id="posix.daemon_control.h">
<span class="h2_num">2.46</span><tt>__vic/posix/daemon_control.h</tt>
</h2>


<h3 id="posix--daemon_control">
<span class="h3_num">2.46.1</span><tt>posix::daemon_control</tt>
</h3>


<pre class="code">
class posix::daemon_control : private non_copyable
{
public:
    class already_running; // public std::exception

    explicit daemon_control(std::string pid_file_name);
    ~daemon_control();

    void daemonize();

    static int control(const char *cmd, const char *pid_file_name);
    static void stop_and_wait(const char *pid_file_name);
};
</pre>

<p>A class that implements start, stop, restart, status check and protection
against multiple daemon-process instances launch. It is recommended to
private-inherit this class by some sort of <tt>application</tt> class in
your application.</p>

<div>
<u><b>Note</b></u>: PID-file is used to find the process instance. It is created in CWD
during process launch. If one removes this file all functions will assume
that the process is not running despite the actual status! Therefore only
read access to the PID-file by another tools is safe. It can be removed
only if it is known for sure that the process is not running at the moment.
</div>

<div class="section">Class members</div>

<div>
<pre class="prototype">class already_running</pre>
<blockquote>

<p>An exception thrown by the constructor if the daemon already running at
the moment.</p>
</blockquote>
</div>

<div>
<pre class="prototype">explicit daemon_control(std::string pid_file_name)</pre>
<blockquote>

<p>Starts the application and creates PID-file named <tt>pid_file_name</tt>
in CWD. <tt>already_running</tt> is thrown if the process is already running.
</p>
</blockquote>
</div>

<div>
<pre class="prototype">~daemon_control()</pre>
<blockquote>

<p>Deletes PID-file created by the constructor.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void daemonize()</pre>
<blockquote>

<p>Makes the calling process a daemon and updates PID in the PID-file.</p>
</blockquote>
</div>

<div>
<pre class="prototype">static int control(const char *cmd, const char *pid_file_name)</pre>
<blockquote>

<p>Executes one of the commands specified by the first parameter and returns
a status:</p>
<ul>
<li>
        <tt>stop</tt> - send <tt>SIGTERM</tt> to the running process and
        return a success/unsuccess status (<tt>0</tt>/<tt>1</tt>),
    </li>
<li>
        <tt>kill</tt> - kill the process with <tt>SIGKILL</tt> signal and
        return a success/unsuccess status (<tt>0</tt>/<tt>1</tt>),
    </li>
<li>
        <tt>status</tt> - check the current process status:
        <ul>
<li>print "Running" to <tt>stdout</tt> and return <tt>0</tt>
                if the process is running,</li>
<li>print "Not running" and return <tt>1</tt> if not,</li>
<li>print error message to <tt>stderr</tt> and return status
                <tt>&gt;1</tt> on failure.</li>
</ul>
    </li>
</ul>
<p>If any other command is passed exception is thrown. The second parameter
is the PID-file name passed to the constructor on start.</p>
</blockquote>
</div>

<div>
<pre class="prototype">static void stop_and_wait(const char *pid_file_name)</pre>
<blockquote>

<p>Sends <tt>SIGTERM</tt> and waits while process is running. If the process
is not running at the moment just returns. This function is used to restart
the application, after the call new instance of <tt>daemon_control</tt> can be
created and the application can start its work.</p>
</blockquote>
</div>







<h2 id="posix.dir_entries.h">
<span class="h2_num">2.47</span><tt>__vic/posix/dir_entries.h</tt>
</h2>


<h3 id="posix--dir_entries">
<span class="h3_num">2.47.1</span><tt>posix::dir_entries</tt>
</h3>


<pre class="code">
class posix::dir_entries : private non_copyable
{
public:
    dir_entries();
    explicit dir_entries(const char *dir);
    ~dir_entries();

    // BEGIN C++11
    dir_entries(dir_entries &amp;&amp;o) noexcept;
    dir_entries &amp;operator=(dir_entries &amp;&amp;o) noexcept;
    // END C++11

    bool reopen(const char *dir);
    void close();
    bool is_open() const;

    const char *next();
#ifdef _DIRENT_HAVE_D_TYPE
    unsigned char type() const;
#endif
    void rewind();
};
</pre>

<p>Using this class one can iterate over content of the specified directory.
Special links <tt>.</tt> and <tt>..</tt> are newer included in the resulting
set.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">dir_entries()</pre>
<blockquote>

<p>Creates the closed object.</p>
<div>
<u>Postcondition</u>: <tt>is_open() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">explicit dir_entries(const char *dir)</pre>
<blockquote>

<p>Tries to open <tt>dir</tt> directory for listing. The result should be
checked using subsequent <tt>is_open()</tt> call!. On error <tt>errno</tt> is
set appropriately.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~dir_entries()</pre>
<blockquote>

<p>Calls <tt>close()</tt> if <tt>is_open() == true</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">dir_entries(dir_entries &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<pre class="prototype">dir_entries &amp;operator=(dir_entries &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Move operations for C++11 mode.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool reopen(const char *dir)</pre>
<blockquote>

<p>Initializes new listing. Calls <tt>close()</tt> before as needed. Returns
<tt>true</tt> on success. On error <tt>errno</tt> is set appropriately.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void close()</pre>
<blockquote>

<p>Frees the resources. Throws on errors.</p>
<div>
<u>Precondition</u>: <tt>is_open() == true</tt>
</div>
<div>
<u>Postcondition</u>: <tt>is_open() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool is_open() const</pre>
<blockquote>

<p>Returns <tt>true</tt> if <tt>next()</tt> can be called.</p>
</blockquote>
</div>

<div>
<pre class="prototype">const char *next()</pre>
<blockquote>

<p>Returns the next entry or <tt>nullptr</tt> if the end of the list was
reached.</p>
<div>
<u>Precondition</u>: <tt>is_open() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">unsigned char type() const</pre>
<blockquote>

<p>Returns the type of the entry: <tt>DT_REG</tt>, <tt>DT_DIR</tt>, et al (see
the <tt>dirent</tt> doc for your system). The member is available only if
<tt>_DIRENT_HAVE_D_TYPE</tt> macro is defined. But anyway, in some situations
the file type could not be determined and the value <tt>DT_UNKNOWN</tt> is
returned. All applications must properly handle such situations falling back
to the <tt>stat()</tt> call!</p>
</blockquote>
</div>

<div>
<pre class="prototype">void rewind()</pre>
<blockquote>

<p>Rewinds the cursor of the listing to the beginning.</p>
<div>
<u>Precondition</u>: <tt>is_open() == true</tt>
</div>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
// Prints the listing of the current directory
__vic::posix::dir_entries list(".");
if(!list.is_open())
    __vic::throw_errno("Can't open directory for listing");
while(const char *entry = list.next())
    std::cout &lt;&lt; entry &lt;&lt; '\n';
</pre>






<h2 id="posix.dir_files.h">
<span class="h2_num">2.48</span><tt>__vic/posix/dir_files.h</tt>
</h2>


<h3 id="posix--dir_files">
<span class="h3_num">2.48.1</span><tt>posix::dir_files</tt>
</h3>


<pre class="code">
class posix::dir_files : private non_copyable
{
public:
    dir_files();
    explicit dir_files(const char *dir, const char *pattern = nullptr);
    ~dir_files();

    // BEGIN C++11
    dir_files(dir_files &amp;&amp;o) noexcept;
    dir_files &amp;operator=(dir_files &amp;&amp;o) noexcept;
    // END C++11

    bool reopen(const char *dir, const char *pattern = nullptr);
    void close();
    bool is_open() const;

    const char *next();
    void rewind();
};
</pre>

<p>The class is similar to <tt>dir_entries</tt> but ignores all directory
entries that are not a regular files. Additionally, one can specify the file
mask using <tt>pattern</tt> parameter.</p>

<div class="section">Example</div>
<pre class="code">
// Prints the listing of the cpp-files in the current directory
__vic::posix::dir_files files(".", "*.cpp");
if(!files.is_open())
    __vic::throw_errno("Can't open directory for listing");
while(const char *file = files.next())
    std::cout &lt;&lt; file &lt;&lt; '\n';
</pre>






<h2 id="posix.error.h">
<span class="h2_num">2.49</span><tt>__vic/posix/error.h</tt>
</h2>


<p>POSIX-specific error handling tools.</p>

<h3 id="posix--is_EAGAIN">
<span class="h3_num">2.49.1</span><tt>posix::is_EAGAIN()</tt>, <tt>posix::is_ENOENT()</tt>
</h3>


<pre class="code">
namespace posix {

bool is_EAGAIN(int err_no);
bool is_ENOENT(int err_no);

#define __VIC_CASE_EAGAIN <span class="nonterminal">case &lt;val1&gt;: case &lt;val2&gt;: ...</span>
#define __VIC_CASE_ENOENT <span class="nonterminal">case &lt;val1&gt;: case &lt;val2&gt;: ...</span>

}
</pre>

<p>The first function checks if the code is either <tt>EAGAIN</tt> or
<tt>EWOULDBLOCK</tt>. It works regardless of these codes have the same numeric
value or not on the current platform.</p>

<p>The second function checks if the error code is <tt>ENOENT</tt>,
<tt>ESTALE</tt> or any other error code that means "file not found".</p>

<p>The macros are meant to be used inside <tt>switch</tt>. They are expanded
either to the single <tt>case</tt> with colon or to the set of <tt>case</tt>s,
and have the same meaning as the corresponding functions.</p>

<div class="section">Example</div>
<pre class="code">
switch(errno)
{
    __VIC_CASE_ENOENT
        std::cout &lt;&lt; "No file found!\n"; break;
    case EPERM:
       ...
}
</pre>






<h2 id="posix.file.h">
<span class="h2_num">2.50</span><tt>__vic/posix/file.h</tt>
</h2>


<h3 id="posix--file">
<span class="h3_num">2.50.1</span><tt>posix::file</tt>
</h3>


<pre class="code">
class posix::file : private non_copyable
{
public:
    explicit constexpr file(int fd = -1);
    file(const char *name, int flags, ::mode_t mode = 0666);
    ~file();

    // BEGIN C++11
    file(file &amp;&amp;o) noexcept;
    file &amp;operator=(file &amp;&amp;o) noexcept;
    // END C++11

    bool open(const char *name, int flags, ::mode_t mode = 0666);
    bool is_open() const;
    void close();
    bool close_nt() noexcept;

    void swap(file &amp;o) noexcept;
    int detach_handle() noexcept;
    int attach_handle(int fd) noexcept;
    int handle() const;
    int descriptor() const { return handle(); }

    size_t read_max(void *buf, size_t n)
        { return read_max(handle(), buf, n); }
    size_t read_some(void *buf, size_t n)
        { return read_some(handle(), buf, n); }
    void write_all(const void *buf, size_t n)
        { write_all(handle(), buf, n); }
    size_t write_all_nt(const void *buf, size_t n) noexcept
        { return write_all_nt(handle(), buf, n); }

    static size_t read_max(int fd, void *buf, size_t n);
    static size_t read_some(int fd, void *buf, size_t n);
    static void write_all(int fd, const void *buf, size_t n);
    static size_t write_all_nt(int fd, const void *buf, size_t n) noexcept;
    static void close_reset(int &amp;fd);
    static bool close_nt(int fd) noexcept;
};
</pre>

<p>RAII-wrapper for POSIX file descriptors and wrappers for <tt>::read()</tt>
and <tt>::write()</tt> system calls.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">explicit constexpr file(int fd = -1)</pre>
<blockquote>

<p>Wraps already existing descriptor.</p>
<div>
<u>Precondition</u>: <tt>fd</tt> is either an open descriptor or <tt>-1</tt>.</div>
</blockquote>
</div>

<div>
<pre class="prototype">file(const char *name, int flags, ::mode_t mode = 0666)</pre>
<blockquote>

<p>Calls <tt>open()</tt>. The result should be checked using subsequent
<tt>is_open()</tt> call.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~file()</pre>
<blockquote>

<p>Calls <tt>::close()</tt> if <tt>is_open() == true</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">file(file &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<pre class="prototype">file &amp;operator=(file &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Move operations for C++11 mode.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool open(const char *name, int flags, ::mode_t mode = 0666)</pre>
<blockquote>

<p>Calls <tt>::open()</tt> with the specified parameters. Returns
<tt>is_open()</tt>. <tt>errno</tt> contains the error code in case of failure.
</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool is_open() const</pre>
<blockquote>

<p>Returns <tt>true</tt> if the file is open.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void close()</pre>
<blockquote>

<p>Unconditionally calls <tt>::close()</tt>. No preliminary checks whether the
file is open are performed! Correctly handles interruptions by signals. Throws
in case of error. The postcondition is always satisfied, even if the function
throws.</p>
<div>
<u>Precondition</u>: <tt>is_open() == true</tt>
</div>
<div>
<u>Postcondition</u>: <tt>is_open() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">static void close_reset(int &amp;fd)</pre>
<blockquote>

<p>Unconditionally calls <tt>::close()</tt> with the specified descriptor and
assigns <tt>-1</tt> to it. No preliminary checks are performed! Correctly
handles interruptions by signals. Throws in case of error. The postcondition
is always satisfied, even if the function throws.</p>
<div>
<u>Precondition</u>: <tt>fd &gt;= 0</tt>
</div>
<div>
<u>Postcondition</u>: <tt>fd == -1</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool close_nt() noexcept</pre>
<pre class="prototype">static bool close_nt(int fd) noexcept</pre>
<blockquote>


<p>Counterpart of <tt>close()</tt> but newer throws. <tt>false</tt> is returned
in case of error, and <tt>errno</tt> contains error code.</p>
</blockquote>
</div>

<div>
<pre class="prototype">int detach_handle() noexcept</pre>
<blockquote>

<p>Releases the descriptor out of the object's control and returns it.</p>
<div>
<u>Postcondition</u>: <tt>is_open() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">int attach_handle(int fd) noexcept</pre>
<blockquote>

<p>Takes <tt>fd</tt> under control and returns the previous handle value.</p>
<div>
<u>Precondition</u>: <tt>fd</tt> is ether an open descriptor or <tt>-1</tt>.</div>
<div>
<u>Postcondition</u>: <tt>handle() == fd</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void swap(file &amp;o) noexcept</pre>
<blockquote>

<p>Swaps the value with <tt>o</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">int handle() const</pre>
<pre class="prototype">int descriptor() const { return handle(); }</pre>
<blockquote>


<p>Returns the wrapped descriptor.</p>
</blockquote>
</div>

<div>
<pre class="prototype">static size_t read_max(int fd, void *buf, size_t n)</pre>
<pre class="prototype">size_t read_max(void *buf, size_t n) { return read_max(handle(), buf, n); }</pre>
<blockquote>


<p>Tries to read <tt>n</tt> bytes to the specified buffer. Returns number of
bytes read. Returned value can be less than requested only when end of file
was reached. Accumulates received chunks until the buffer becomes full. Is not
interrupted by signals. Calls <a href="#throw_errno"><tt>throw_errno()</tt></a> on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">static size_t read_some(int fd, void *buf, size_t n)</pre>
<pre class="prototype">size_t read_some(void *buf, size_t n) { return read_some(handle(), buf, n); }</pre>
<blockquote>


<p>Reads no more than <tt>n</tt> bytes to the specified buffer. Returns number
of bytes read or <tt>0</tt> in case of end-of-file. The function returns after
first chunk of any size was successfully received. Is not interrupted by
signals. Calls <a href="#throw_errno"><tt>throw_errno()</tt></a> on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">static void write_all(int fd, const void *buf, size_t n);</pre>
<pre class="prototype">void write_all(const void *buf, size_t n) { write_all(handle(), buf, n); }</pre>
<blockquote>


<p>Writes the whole buffer to the descriptor. Is not interrupted by signals.
Calls <a href="#throw_errno"><tt>throw_errno()</tt></a> on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">static size_t write_all_nt(int fd, const void *buf, size_t n) noexcept</pre>
<pre class="prototype">size_t write_all_nt(const void *buf, size_t n) noexcept</pre>
<blockquote>


<p>Counterpart of <tt>write_all()</tt> but never throws, returns value less
than <tt>n</tt> instead and <tt>errno</tt> contains error code.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
__vic::posix::file file("path/file", O_WRONLY | O_CREAT);
if(!file.is_open()) __vic::throw_errno("Cannot create file");
const char msg[] = "Hello";
file.write_all(msg, sizeof msg - 1); // write without null-terminator
file.close();
</pre>






<h2 id="posix.file_stat.h">
<span class="h2_num">2.51</span><tt>__vic/posix/file_stat.h</tt>
</h2>


<h3 id="posix--file_stat">
<span class="h3_num">2.51.1</span><tt>posix::file_stat</tt>
</h3>


<pre class="code">
namespace posix {

struct file_stat : public ::stat
{
    enum for_link_t { for_link };

    file_stat() = default;
    file_stat(const struct ::stat &amp;s);
    explicit file_stat(int fd);
    explicit file_stat(const char *path);
    explicit file_stat(const std::string &amp;path);
    file_stat(const char *path, for_link_t);
    file_stat(const std::string &amp;path, for_link_t);

    void get(int fd);
    void get(const char *path);
    void get(const std::string &amp;path);
    void get_for_link(const char *path);
    void get_for_link(const std::string &amp;path);

    bool try_get(int fd);
    bool try_get(const char *path);
    bool try_get(const std::string &amp;path);
    bool try_get_for_link(const char *path);
    bool try_get_for_link(const std::string &amp;path);

    bool get_if_exists(const char *path);
    bool get_if_exists(const std::string &amp;path);

    // POSIX-defined attributes
    dev_t   dev() const { return this-&gt;st_dev; }
    ino_t   ino() const { return this-&gt;st_ino; }
    mode_t  mode() const { return this-&gt;st_mode; }
    nlink_t nlink() const { return this-&gt;st_nlink; }
    uid_t   uid() const { return this-&gt;st_uid; }
    gid_t   gid() const { return this-&gt;st_gid; }
    off_t   size() const { return this-&gt;st_size; }
    time_t  atime() const { return this-&gt;st_atime; }
    time_t  mtime() const { return this-&gt;st_mtime; }
    time_t  ctime() const { return this-&gt;st_ctime; }

    bool is_block() const { return S_ISBLK(mode()); }
    bool is_char() const { return S_ISCHR(mode()); }
    bool is_dir() const { return S_ISDIR(mode()); }
    bool is_fifo() const { return S_ISFIFO(mode()); }
    bool is_regular() const { return S_ISREG(mode()); }
    bool is_link() const { return S_ISLNK(mode()); }
    bool is_socket() const { return S_ISSOCK(mode()); }
};
inline bool is_block(const struct ::stat &amp;s) { return S_ISBLK(s.st_mode); }
inline bool is_char(const struct ::stat &amp;s) { return S_ISCHR(s.st_mode); }
inline bool is_dir(const struct ::stat &amp;s) { return S_ISDIR(s.st_mode); }
inline bool is_fifo(const struct ::stat &amp;s) { return S_ISFIFO(s.st_mode); }
inline bool is_regular(const struct ::stat &amp;s) { return S_ISREG(s.st_mode); }
inline bool is_link(const struct ::stat &amp;s) { return S_ISLNK(s.st_mode); }
inline bool is_socket(const struct ::stat &amp;s) { return S_ISSOCK(s.st_mode); }

bool is_same_file(const struct ::stat &amp;s1, const struct ::stat &amp;s2);

}
</pre>

<p>C++ wrapper for the system structure <tt>stat</tt>. Constructors and
functions <tt>get()</tt> call <a href="#throw_errno"><tt>throw_errno()</tt></a> in case of error.
Functions <tt>try_get()</tt> return <tt>false</tt> instead in such cases,
error code is placed to <tt>errno</tt>.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">enum for_link_t { for_link }</pre>
<blockquote>

<p>Constructor tag.</p>
</blockquote>
</div>

<div>
<pre class="prototype">file_stat()</pre>
<blockquote>

<p>Creates uninitialized structure.</p>
</blockquote>
</div>

<div>
<pre class="prototype">file_stat(const struct ::stat &amp;s)</pre>
<blockquote>

<p>Copies <tt>s</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">explicit file_stat(int fd)</pre>
<pre class="prototype">void get(int fd)</pre>
<blockquote>


<p>Obtains the stat for the file descriptor <tt>fd</tt> (system call
<tt>fstat()</tt>).</p>
</blockquote>
</div>

<div>
<pre class="prototype">explicit file_stat(const char *path)</pre>
<pre class="prototype">explicit file_stat(const std::string &amp;path)</pre>
<pre class="prototype">void get(const char *path)</pre>
<pre class="prototype">void get(const std::string &amp;path)</pre>
<blockquote>




<p>Obtains the stat by the file path (system call <tt>stat()</tt>).</p>
</blockquote>
</div>

<div>
<pre class="prototype">file_stat(const char *path, for_link_t)</pre>
<pre class="prototype">file_stat(const std::string &amp;path, for_link_t)</pre>
<pre class="prototype">void get_for_link(const char *path)</pre>
<pre class="prototype">void get_for_link(const std::string &amp;path)</pre>
<blockquote>




<p>Obtains the stat for the symbolic link (system call <tt>lstat()</tt>).</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool try_get(int fd)</pre>
<pre class="prototype">bool try_get(const char *path)</pre>
<pre class="prototype">bool try_get(const std::string &amp;path)</pre>
<pre class="prototype">bool try_get_for_link(const char *path)</pre>
<pre class="prototype">bool try_get_for_link(const std::string &amp;path)</pre>
<blockquote>





<p>Counterparts of <tt>get()</tt> and <tt>get_for_link()</tt> but return
<tt>false</tt> instead of throwing exceptions.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool get_if_exists(const char *path)</pre>
<pre class="prototype">bool get_if_exists(const std::string &amp;path)</pre>
<blockquote>


<p>Counterpart of <tt>get()</tt> but returns <tt>false</tt> in case of the
file is not found instead of throwing. Throws on other errors.</p>
</blockquote>
</div>

<div>
<pre class="prototype">dev_t   dev() const</pre>
<pre class="prototype">ino_t   ino() const</pre>
<pre class="prototype">mode_t  mode() const</pre>
<pre class="prototype">nlink_t nlink() const</pre>
<pre class="prototype">uid_t   uid() const</pre>
<pre class="prototype">gid_t   gid() const</pre>
<pre class="prototype">off_t   size() const</pre>
<pre class="prototype">time_t  atime() const</pre>
<pre class="prototype">time_t  mtime() const</pre>
<pre class="prototype">time_t  ctime() const</pre>
<blockquote>










<p>Attributes of the <tt>stat</tt> structure defined by POSIX standard.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool is_block() const</pre>
<pre class="prototype">bool is_char() const</pre>
<pre class="prototype">bool is_dir() const</pre>
<pre class="prototype">bool is_fifo() const</pre>
<pre class="prototype">bool is_regular() const</pre>
<pre class="prototype">bool is_link() const</pre>
<pre class="prototype">bool is_socket() const</pre>
<blockquote>







<p>Wrappers for the standard macros.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool is_same_file(const struct ::stat &amp;s1, const struct ::stat &amp;s2)</pre>
<blockquote>

<p>Determines whether both structures refer to the same file.</p>
</blockquote>
</div>







<h2 id="posix.fs.h">
<span class="h2_num">2.52</span><tt>__vic/posix/fs.h</tt>
</h2>


<p>Tools to handle files and paths within POSIX-compliant filesystem.</p>


<h3 id="posix--basename">
<span class="h3_num">2.52.1</span><tt>posix::basename()</tt>, <tt>posix::dirname()</tt>
</h3>


<pre class="code">
namespace posix {

std::string basename(const std::string &amp;path);
std::string dirname(const std::string &amp;path);
void basename(const std::string &amp;path, std::string &amp;res);
void dirname(const std::string &amp;path, std::string &amp;res);
void append_basename(const std::string &amp;path, std::string &amp;res);
void append_dirname(const std::string &amp;path, std::string &amp;res);

}
</pre>

<p>The functions are counterparts of the standard shell-commands. Extract
the name of the file or the directory from the given path. There are 3
variations of each function:</p>
<ul>
<li>The result is returned using standard way,</li>
<li>The result is returned using an output argument and</li>
<li>The result is appended to the output argument.</li>
</ul>

<div class="section">Example</div>
<pre class="code">
std::cout &lt;&lt; __vic::posix::dirname("/usr/lib") &lt;&lt; '\n';   // "/usr"
std::cout &lt;&lt; __vic::posix::basename("/usr/lib") &lt;&lt; '\n';  // "lib"
std::cout &lt;&lt; __vic::posix::dirname("/usr/lib/") &lt;&lt; '\n';  // "/usr"
std::cout &lt;&lt; __vic::posix::basename("/usr/lib/") &lt;&lt; '\n'; // "lib"
std::cout &lt;&lt; __vic::posix::dirname("lib") &lt;&lt; '\n';        // "."
std::cout &lt;&lt; __vic::posix::basename("lib") &lt;&lt; '\n';       // "lib"
std::cout &lt;&lt; __vic::posix::dirname("/") &lt;&lt; '\n';          // "/"
std::cout &lt;&lt; __vic::posix::basename("/") &lt;&lt; '\n';         // "/"
std::cout &lt;&lt; __vic::posix::dirname("") &lt;&lt; '\n';           // "."
std::cout &lt;&lt; __vic::posix::basename("") &lt;&lt; '\n';          // ""
</pre>





<h3 id="posix--add_trailing_slash">
<span class="h3_num">2.52.2</span><tt>posix::add_trailing_slash()</tt>,
    <tt>posix::with_trailing_slash()</tt>
</h3>


<pre class="code">
namespace posix {

std::string &amp;add_trailing_slash(std::string &amp;path);
std::string with_trailing_slash(const std::string &amp;s);
std::string with_trailing_slash(const char *s);

}
</pre>

<p>Add trailing slash to the path if absent. <tt>add_trailing_slash()</tt>
modifies the argument and returns a reference to it, while
<tt>with_trailing_slash()</tt> always creates new object and returns it.</p>

<div class="section">Example</div>
<pre class="code">
std::string path = get_directory();
__vic::posix::add_trailing_slash(path) += "file.name"; // dir/file.name
create_file(path);
</pre>







<h2 id="posix.iov.h">
<span class="h2_num">2.53</span><tt>__vic/posix/iov.h</tt>
</h2>


<p>Vectored I/O tools.</p>


<h3 id="posix--ovectors">
<span class="h3_num">2.53.1</span><tt>posix::ovectors</tt>
</h3>


<pre class="code">
template&lt;unsigned N&gt;
class posix::ovectors
{
public:
    ovectors();

    void push_back(const void *buf, size_t buf_len);
    void pop_back();

    ::iovec *ptr();
    const ::iovec *ptr() const;
    unsigned size() const;

    bool full() const;
    bool empty() const;
    void clear();

    static constexpr unsigned max_size() { return N; }
    size_t total_bytes() const;
};
</pre>

<p>Wrapper for array of system structs <tt>iovec</tt> that serves
gathered output from the set of buffers. Template argument is the maximun
number of the buffers.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">ovectors()</pre>
<blockquote>

<div>
<u>Postcondition</u>: <tt>empty() &amp;&amp; total_bytes() == 0</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void push_back(const void *buf, size_t buf_len)</pre>
<blockquote>

<p>Adds the specified buffer to the set.</p>
<div>
<u>Precondition</u>: <tt>!full()</tt>
</div>
<div>
<u>Postcondition</u>: <tt>size()</tt> is increased by <tt>1</tt>,
<tt>total_bytes()</tt> is increased by <tt>buf_len</tt>.</div>
</blockquote>
</div>

<div>
<pre class="prototype">void pop_back()</pre>
<blockquote>

<p>Removes the last added buffer from the set.</p>
<div>
<u>Precondition</u>: <tt>!empty()</tt>
</div>
<div>
<u>Postcondition</u>: <tt>size()</tt> is decreased by <tt>1</tt>,
<tt>total_bytes()</tt> is decreased by <tt>iov_len</tt> of the removed buffer.</div>
</blockquote>
</div>

<div>
<pre class="prototype">::iovec *ptr()</pre>
<pre class="prototype">const ::iovec *ptr() const</pre>
<blockquote>


<p>Returns the pointer to the array of the output vectors.</p>
</blockquote>
</div>

<div>
<pre class="prototype">unsigned size() const</pre>
<blockquote>

<p>Returns current number of the vectors in the array.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool full() const</pre>
<blockquote>

<p>Returns <tt>size() == max_size()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool empty() const</pre>
<blockquote>

<p>Returns <tt>size() == 0</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void clear()</pre>
<blockquote>

<p>Removes all buffers from the set.</p>
<div>
<u>Postcondition</u>: <tt>empty() &amp;&amp; total_bytes() == 0</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">static constexpr unsigned max_size()</pre>
<blockquote>

<p>Returns <tt>N</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">size_t total_bytes() const</pre>
<blockquote>

<p>Returns total amount of bytes in all buffers of the array.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
__vic::posix::ovectors&lt;3&gt; v;
v.push_back("ovectors", 8);
v.push_back(" in work", 8);
const char nl = '\n';
v.push_back(&amp;nl, 1);

// Prints:
// ovectors in work
__vic::posix::writev_all(1, v); // ::writev(1, v.ptr(), v.size());
</pre>





<h3 id="posix--total-iovec">
<span class="h3_num">2.53.2</span><tt>posix::total(iovec[])</tt>
</h3>


<pre class="code">
namespace posix {

size_t total(const ::iovec vec[], unsigned vec_len);
template&lt;unsigned vsize&gt; size_t total(const ::iovec (&amp;vec)[vsize]);

}
</pre>

<p>Calculates total size of the buffers in the array <tt>vec</tt>.</p>




<h3 id="posix--cut_prefix-iovec">
<span class="h3_num">2.53.3</span><tt>posix::cut_prefix(iovec[])</tt>
</h3>


<pre class="code">
void posix::cut_prefix(::iovec *&amp;vec, unsigned &amp;vec_len, size_t n);
</pre>

<p>Removes first <tt>n</tt> bytes from the set of vectors <tt>vec</tt>. Returns
the pointer to the modified set and the new length of the set. If <tt>n</tt> is
greater than total size of the all buffers, <tt>vec_len</tt> becomes
<tt>0</tt> and the value of <tt>vec</tt> is undefined.</p>

<p>The function is useful to retry the interrrupted by signal system call when
only part of data was written.</p>




<h3 id="posix--writev_all">
<span class="h3_num">2.53.4</span><tt>posix::writev_all()</tt>
</h3>


<pre class="code">
namespace posix {

void writev_all(int fd, ::iovec vec[], unsigned vec_len, size_t total);

template&lt;unsigned vsize&gt;
void writev_all(int fd, ovectors&lt;vsize&gt; &amp;vec);

}
</pre>

<p>The functions write contents of the all buffers in the set <tt>vec</tt> to
the descriptor <tt>fd</tt>. The parameter <tt>total</tt> must contain the total
size of the all buffers (can be calculated using <tt>__vic::posix::total(vec,
vec_len)</tt> or <tt>__vic::posix::total(vec)</tt>). The functions are not
interrupted by signals. Exceptions are thrown on errors.</p>






<h2 id="posix.mutex.h">
<span class="h2_num">2.54</span><tt>__vic/posix/mutex.h</tt>
</h2>



<h3 id="posix--mutex">
<span class="h3_num">2.54.1</span><tt>posix::mutex</tt>
</h3>


<pre class="code">
class posix::mutex
{
public:
    constexpr mutex() noexcept;
    ~mutex();

    mutex(const mutex &amp; ) = delete;
    mutex &amp;operator=(const mutex &amp; ) = delete;

    void lock();
    bool try_lock();
    bool unlock() noexcept;

    // System-specific handle
    ::pthread_mutex_t *handle();
    const ::pthread_mutex_t *handle() const;
};
</pre>

<p>Wrapper for plain non-recursive <tt>pthread_mutex_t</tt>. See
<a href="#mutex"><tt>mutex</tt></a> for usage notes.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">constexpr mutex() noexcept</pre>
<blockquote>

<p>Creates unlocked mutex.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~mutex()</pre>
<blockquote>

<p>Destroys the mutex.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void lock()</pre>
<blockquote>

<p>Acquires the mutex. Waits until released if acquired by other
thread at the moment.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool try_lock()</pre>
<blockquote>

<p>Tries to acquire the mutex. Immediately returns <tt>false</tt> if it's
already acquired by another thread, without waiting.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool unlock() noexcept</pre>
<blockquote>

<p>Releases the mutex acquired before. In some cases can return <tt>false</tt>
in case of error, but in general error detection is not guaranteed.</p>
</blockquote>
</div>

<div>
<pre class="prototype">::pthread_mutex_t *handle()</pre>
<pre class="prototype">const ::pthread_mutex_t *handle() const</pre>
<blockquote>


<p>Returns the native handle of the mutex.</p>
</blockquote>
</div>



<div class="section">Example</div>
<p>See <a href="#posix--mutex_lock"><tt>posix::mutex_lock</tt></a>.</p>





<h3 id="posix--mutex_lock">
<span class="h3_num">2.54.2</span><tt>posix::mutex_lock</tt>
</h3>


<pre class="code">
class posix::mutex_lock : private non_copyable, private non_heap_allocatable
{
public:
    enum adopt_t { adopt };

    explicit mutex_lock(posix::mutex &amp;mtx);
    mutex_lock(posix::mutex &amp;mtx, adopt_t);

    explicit mutex_lock(::pthread_mutex_t &amp;mtx);
    mutex_lock(::pthread_mutex_t &amp;mtx, adopt_t);

    ~mutex_lock() noexcept(false);
};
</pre>

<p>Class manages the lock on a mutex. The lock exists while the object is
alive. Can handle <tt>posix::mutex</tt> class objects as well as system
<tt>pthread_mutex_t</tt>.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">adopt</pre>
<blockquote>

<p>Constructor tag, suppresses the lock acquisition.</p>
</blockquote>
</div>

<div>
<pre class="prototype">explicit mutex_lock(posix::mutex &amp;mtx)</pre>
<pre class="prototype">explicit mutex_lock(::pthread_mutex_t &amp;mtx)</pre>
<blockquote>


<p>Acquires <tt>mtx</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~mutex_lock() noexcept(false)</pre>
<blockquote>

<p>Releases <tt>mtx</tt>. Can throw exception in case of error and when there
is no other active exception!</p>
</blockquote>
</div>

<div>
<pre class="prototype">mutex_lock(posix::mutex &amp;mtx, adopt_t)</pre>
<pre class="prototype">mutex_lock(::pthread_mutex_t &amp;mtx, adopt_t)</pre>
<blockquote>


<p>Adopts already acquired <tt>mtx</tt>. See the example.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
// Typical usage
void reentrant_function()
{
    static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
    __vic::posix::mutex_lock lock(mtx);
    // Critical section code until the end of the block
    ...
}

// Usage of non-acquiring constructor
__vic::posix::mutex mtx;
if(mtx.try_lock()) // Try to acquire the mutex
{
    // The mutex has been successfully acquired
    using __vic::posix::mutex_lock;
    mutex_lock lock(mtx, mutex_lock::adopt);
    // Critical section code until the end of the block
    ...
}
else
{
    // The mutex is acquired by another thread
    ...
}
</pre>







<h2 id="posix.pidfile.h">
<span class="h2_num">2.55</span><tt>__vic/posix/pidfile.h</tt>
</h2>


<h3 id="posix--pidfile">
<span class="h3_num">2.55.1</span><tt>posix::pidfile</tt>
</h3>


<pre class="code">
class posix::pidfile : private non_copyable
{
public:
    class already_exists; // : public std::exception

    explicit pidfile(std::string file_name);
    ~pidfile();

    void create();
    void prepare_to_daemon();
    void rewrite_pid();
};
</pre>

<p>A class to operate PID-files, i.e. files contain a PID of a process
(usually daemon-process). Used to stop the daemon and to protect against
running multiple simultaneous daemon instances.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">class already_exists</pre>
<blockquote>

<p>An exception. See <tt>create()</tt> description.</p>
</blockquote>
</div>

<div>
<pre class="prototype">explicit pidfile(std::string file_name)</pre>
<blockquote>

<p>Sets PID-file name.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~pidfile()</pre>
<blockquote>

<p>Deletes PID-file.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void create()</pre>
<blockquote>

<p>Creates PID-file with a name specified in the constructor. Throws
<tt>already_exists</tt> if such PID-file is already created by another
process instance.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void prepare_to_daemon()</pre>
<blockquote>

<p>This function must be called before <tt>daemon()</tt> syscall.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void rewrite_pid()</pre>
<blockquote>

<p>Updates PID in the PID-file. PID is changed after <tt>daemon()</tt> syscall.
</p>
</blockquote>
</div>







<h2 id="posix.process.h">
<span class="h2_num">2.56</span><tt>__vic/posix/process.h</tt>
</h2>


<p>OS processes-related tools.</p>


<h3 id="posix--daemon">
<span class="h3_num">2.56.1</span><tt>posix::daemon()</tt>
</h3>


<pre class="code">
void posix::daemon(bool nochdir, bool noclose = false);
</pre>

<p>Makes the calling process a UNIX daemon. The function is just a redirector
to the system call if the OS implements it, like *BSD, Linux, QNX. The function
throws on errors.</p>




<h3 id="posix--ignore_signals">
<span class="h3_num">2.56.2</span><tt>posix::ignore_signals()</tt>
</h3>


<pre class="code">
namespace posix {

void ignore_signals(const int sigs[], size_t sigs_len);
template&lt;size_t Size&gt; void ignore_signals(const int (&amp;sigs)[Size]);
// BEGIN C++11
void ignore_signals(std::initializer_list&lt;int&gt; sigs);
// END C++11

}
</pre>

<p>Ignore the specified signals (<tt>sigaction()</tt> call is used).</p>

<div class="section">Example</div>
<pre class="code">
int sigs[] = { SIGINT, SIGQUIT, SIGTERM };
__vic::posix::ignore_signals(sigs);

// or since C++11 just
__vic::posix::ignore_signals({SIGINT, SIGQUIT, SIGTERM});
</pre>





<h3 id="posix--process_alive">
<span class="h3_num">2.56.3</span><tt>posix::process_alive()</tt>
</h3>


<pre class="code">
bool posix::process_alive(pid_t pid);
</pre>

<p>Returns <tt>true</tt> if process associated with the PID exists and not a
zombie.</p>






<h2 id="posix.sigset.h">
<span class="h2_num">2.57</span><tt>__vic/posix/sigset.h</tt>
</h2>


<h3 id="posix--sigset">
<span class="h3_num">2.57.1</span><tt>posix::sigset</tt>
</h3>


<pre class="code">
class posix::sigset
{
public:
    sigset() = default;
    sigset(const ::sigset_t &amp;set);
    template&lt;size_t Size&gt; sigset(const int (&amp;sigs)[Size]);
    // BEGIN C++11
    sigset(std::initializer_list&lt;int&gt; sigs);
    sigset &amp;operator=(std::initializer_list&lt;int&gt; sigs)
    // END C++11

    sigset &amp;assign(const int *sigs, size_t n);
    template&lt;size_t Size&gt;
    sigset &amp;operator=(const int (&amp;sigs)[Size]);

    sigset &amp;add(int signo);
    sigset &amp;del(int signo);
    sigset &amp;operator+=(int signo);
    sigset &amp;operator-=(int signo);
    sigset &amp;operator&lt;&lt;(int signo);
    sigset &amp;operator&gt;&gt;(int signo);

    sigset &amp;fill();
    sigset &amp;clear();

    static sigset full();
    static sigset empty();

    bool is_member(int signo) const;
    bool contains(int signo) const;

    operator ::sigset_t &amp;();
    operator const ::sigset_t &amp;() const;

    ::sigset_t *operator&amp;();
    const ::sigset_t *operator&amp;() const;
};
</pre>

<p>Handy C++ wrapper for the system type <tt>sigset_t</tt>. Set operations are
defined as C++-operators and member-functions.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">sigset()</pre>
<blockquote>

<p>Creates the uninitialized object.</p>
</blockquote>
</div>

<div>
<pre class="prototype">sigset(const ::sigset_t &amp;set)</pre>
<blockquote>

<p>Creates the copy of <tt>set</tt>. Implicit converter from the
<tt>sigset_t</tt> type.</p>
</blockquote>
</div>

<div>
<pre class="prototype">sigset(std::initializer_list&lt;int&gt; sigs) <span class="sign">[C++11]</span></pre>
<pre class="prototype">template&lt;size_t Size&gt; sigset(const int (&amp;sigs)[Size])</pre>
<blockquote>


<p>Creates the set filled with signals from <tt>sigs</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">sigset &amp;operator=(std::initializer_list&lt;int&gt; sigs) <span class="sign">[C++11]</span></pre>
<pre class="prototype">template&lt;size_t Size&gt; sigset &amp;operator=(const int (&amp;sigs)[Size])</pre>
<pre class="prototype">sigset &amp;assign(const int *sigs, size_t n)</pre>
<blockquote>



<p>Calls <tt>clear()</tt> and fills the set with signals from <tt>sigs</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">sigset &amp;add(int signo)</pre>
<pre class="prototype">sigset &amp;operator+=(int signo)</pre>
<pre class="prototype">sigset &amp;operator&lt;&lt;(int signo)</pre>
<blockquote>



<p>Adds the signal to the set.</p>
</blockquote>
</div>

<div>
<pre class="prototype">sigset &amp;del(int signo)</pre>
<pre class="prototype">sigset &amp;operator-=(int signo)</pre>
<pre class="prototype">sigset &amp;operator&gt;&gt;(int signo)</pre>
<blockquote>



<p>Removes the signal from the set.</p>
</blockquote>
</div>

<div>
<pre class="prototype">sigset &amp;fill()</pre>
<blockquote>

<p>Fills the set with all signals (<tt>sigfillset()</tt>).</p>
</blockquote>
</div>

<div>
<pre class="prototype">sigset &amp;clear()</pre>
<blockquote>

<p>Clears the set - removes all signals from the set (<tt>sigemptyset()</tt>).
</p>
</blockquote>
</div>

<div>
<pre class="prototype">static sigset full()</pre>
<blockquote>

<p>Creates the set filled with all signals.</p>
</blockquote>
</div>

<div>
<pre class="prototype">static sigset empty()</pre>
<blockquote>

<p>Creates the empty set of signals.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool is_member(int signo)</pre>
<pre class="prototype">bool contains(int signo)</pre>
<blockquote>


<p>Checks if the set contains <tt>signo</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">operator ::sigset_t &amp;()</pre>
<pre class="prototype">operator const ::sigset_t &amp;() const</pre>
<blockquote>


<p>Implicit conversion to the <tt>sigset_t</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">::sigset_t *operator&amp;()</pre>
<pre class="prototype">const ::sigset_t *operator&amp;() const</pre>
<blockquote>


<p>Overloaded address operator.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
using __vic::posix::sigset;
namespace this_thread = __vic::posix::this_thread;

// Waiting for all but SIGTERM and SIGQUIT
int sig = this_thread::sigwait( sigset::full() &gt;&gt; SIGTERM &gt;&gt; SIGQUIT );

// Waiting for Ctrl+C
this_thread::sigwait( sigset::empty() &lt;&lt; SIGINT );
// or for C++11
this_thread::sigwait( sigset{ SIGINT } );
</pre>






<h2 id="posix.thread.h">
<span class="h2_num">2.58</span><tt>__vic/posix/thread.h</tt>
</h2>


<p>C++ wrappers for Pthreads.</p>


<h3 id="posix--this_thread">
<span class="h3_num">2.58.1</span><tt>posix::this_thread</tt>
</h3>


<pre class="code">
namespace posix::this_thread { ... }
</pre>

<p>Set of the functions to control the current thread.</p>




<h3 id="posix--this_thread--sigwait">
<span class="h3_num">2.58.2</span><tt>posix::this_thread::sigwait()</tt>,
       <tt>posix::this_thread::sigwait_at_most()</tt>
</h3>


<pre class="code">
namespace posix::this_thread
{
    int sigwait(const ::sigset_t &amp;set);

    int sigwait_at_most(const ::sigset_t &amp;set, const ::timespec &amp;timeout);
}
</pre>

<p><tt>sigwait()</tt> suspends the current thread until the signal from
<tt>set</tt> is received. Received signal is returned as a result.</p>

<p><tt>sigwait_at_most()</tt> is the same but waits no longer than the specified
timeout. Returns <tt>0</tt> on timeout or when interrupted by signal other than
one of those in set.</p>




<h3 id="posix--this_thread--sigwaitinfo">
<span class="h3_num">2.58.3</span><tt>posix::this_thread::sigwaitinfo()</tt>,
       <tt>posix::this_thread::sigwaitinfo_at_most()</tt>
</h3>


<pre class="code">
namespace posix::this_thread
{
    ::siginfo_t sigwaitinfo(const ::sigset_t &amp;set);

    bool sigwaitinfo_at_most(const ::sigset_t &amp;set,
        const ::timespec &amp;timeout, ::siginfo_t &amp;res);
}
</pre>

<p><tt>sigwaitinfo()</tt> is a counterpart of <tt>sigwait()</tt> but returns
an additional information about the received signal. The signal is returned in
<tt>si_signo</tt> field.</p>
<div>
<u><b>Note</b></u>: The function is not interrupted by signal handlers as opposed to the
system call of the same name.</div>

<p><tt>sigwaitinfo_at_most()</tt> is the same but waits no longer than the
specified timeout. Returns <tt>false</tt> on timeout or when interrupted by
signal other than one of those in set. If <tt>true</tt> is returned <tt>res</tt>
contains filled <tt>siginfo_t</tt>.</p>

<div>
<u><b>Note</b></u>: <tt>::sigaction()</tt> with <tt>sa_flags</tt> containing
<tt>SA_SIGINFO</tt> has to be called for each signal from <tt>set</tt> before
usage of any of these functions! Otherwise the returned <tt>siginfo_t</tt>
value will contain garbage!</div>




<h3 id="posix--this_thread--block_signals">
<span class="h3_num">2.58.4</span><tt>posix::this_thread::block_signals()</tt>,
       <tt>posix::this_thread::unblock_signals()</tt>,
       <tt>posix::this_thread::set_sigmask()</tt>
</h3>


<pre class="code">
namespace posix::this_thread
{
    void block_signals(const ::sigset_t &amp;mask,
                                ::sigset_t *oldmask = nullptr);
    void unblock_signals(const ::sigset_t &amp;mask,
                                ::sigset_t *oldmask = nullptr);
    void set_sigmask(const ::sigset_t &amp;mask, ::sigset_t *oldmask = nullptr);
}
</pre>

<p><tt>block_signals()</tt> adds signals from the set to the blocked ones in
the calling thread.</p>

<p><tt>unblock_signals()</tt> removes the signals from the set from the blocked
ones in the calling thread.</p>

<p><tt>set_sigmask()</tt> sets the mask of blocked signals for the calling
thread. All signals from the set are blocked, others - aren't.</p>






<h2 id="posix.time.h">
<span class="h2_num">2.59</span><tt>__vic/posix/time.h</tt>
</h2>


<p>POSIX time-related utilities.</p>


<h3 id="posix--time_spec">
<span class="h3_num">2.59.1</span><tt>posix::time_spec</tt>
</h3>


<pre class="code">
struct posix::time_spec : ::timespec
{
    // Unit tags
    enum sec_units { sec };
    enum msec_units { msec };
    enum usec_units { usec };
    enum nsec_units { nsec };

    time_spec() = default;
    time_spec(time_t secs, long nsecs);

    time_spec(time_t secs, sec_units);
    time_spec(time_t msecs, msec_units);
    time_spec(time_t usecs, usec_units);
    time_spec(time_t nsecs, nsec_units);

    // BEGIN C++11
    template&lt;class Rep, class Period&gt;
    time_spec(std::chrono::duration&lt;Rep,Period&gt; d);

    operator std::chrono::nanoseconds() const;

    template&lt;class Rep, class Period&gt;
    time_spec &amp;operator+=(std::chrono::duration&lt;Rep,Period&gt; t2);
    template&lt;class Rep, class Period&gt;
    time_spec &amp;operator-=(std::chrono::duration&lt;Rep,Period&gt; t2);
    // END C++11

    time_spec &amp;operator+=(time_spec t2);
    time_spec &amp;operator-=(time_spec t2);
};

bool operator==(time_spec t1, time_spec t2);
bool operator!=(time_spec t1, time_spec t2);
bool operator&lt; (time_spec t1, time_spec t2);
bool operator&gt; (time_spec t1, time_spec t2);
bool operator&lt;=(time_spec t1, time_spec t2);
bool operator&gt;=(time_spec t1, time_spec t2);

time_spec operator+(time_spec t1, time_spec t2);
time_spec operator-(time_spec t1, time_spec t2);
</pre>

<p>Handy C++ wrapper for the system type <tt>timespec</tt>. Allows to specify
time using various units as well as sum up, subtract and compare the values
using C++ operators.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">enum sec_units { sec }</pre>
<pre class="prototype">enum msec_units { msec }</pre>
<pre class="prototype">enum usec_units { usec }</pre>
<pre class="prototype">enum nsec_units { nsec }</pre>
<blockquote>




<p>Constructor tags to specify units.</p>
</blockquote>
</div>

<div>
<pre class="prototype">time_spec()</pre>
<blockquote>

<p>Creates uninitialized object.</p>
</blockquote>
</div>

<div>
<pre class="prototype">time_spec(time_t secs, long nsecs)</pre>
<blockquote>

<p>Fills the fields of the structure with the specified values.</p>
</blockquote>
</div>

<div>
<pre class="prototype">time_spec(time_t secs, sec_units)</pre>
<pre class="prototype">time_spec(time_t msecs, msec_units)</pre>
<pre class="prototype">time_spec(time_t usecs, usec_units)</pre>
<pre class="prototype">time_spec(time_t nsecs, nsec_units)</pre>
<blockquote>




<p>Specifies time in seconds, milliseconds, microseconds and nanoseconds,
respectively.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class Rep, class Period&gt;
time_spec(std::chrono::duration&lt;Rep,Period&gt; d) <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Creates <tt>time_spec</tt> from <tt>std::chrono::duration</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">operator std::chrono::nanoseconds() const <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Converts the value to nanoseconds.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class Rep, class Period&gt;
time_spec &amp;operator+=(std::chrono::duration&lt;Rep,Period&gt; t2) <span class="sign">[C++11]</span></pre>
<pre class="prototype">time_spec &amp;operator+=(time_spec t2)</pre>
<pre class="prototype">time_spec operator+(time_spec t1, time_spec t2)</pre>
<blockquote>



<p>Sums up two values.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class Rep, class Period&gt;
time_spec &amp;operator-=(std::chrono::duration&lt;Rep,Period&gt; t2) <span class="sign">[C++11]</span></pre>
<pre class="prototype">time_spec &amp;operator-=(time_spec t2)</pre>
<pre class="prototype">time_spec operator-(time_spec t1, time_spec t2)</pre>
<blockquote>



<p>Calculates the difference between two values.</p>
<div>
<u>Precondition</u>: <tt>t2 &lt;= t1</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool operator==(time_spec t1, time_spec t2)</pre>
<pre class="prototype">bool operator!=(time_spec t1, time_spec t2)</pre>
<pre class="prototype">bool operator&lt; (time_spec t1, time_spec t2)</pre>
<pre class="prototype">bool operator&gt; (time_spec t1, time_spec t2)</pre>
<pre class="prototype">bool operator&lt;=(time_spec t1, time_spec t2)</pre>
<pre class="prototype">bool operator&gt;=(time_spec t1, time_spec t2)</pre>
<blockquote>






<p>Comparison operators.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
__vic::posix::time_spec t(5, __vic::posix::time_spec::sec);
::nanosleep(&amp;t, nullptr); // sleep for 5 sec
</pre>





<h3 id="posix--nanoseconds_since_epoch">
<span class="h3_num">2.59.2</span><tt>posix::nanoseconds_since_epoch()</tt>
</h3>


<pre class="code">
posix::time_spec posix::nanoseconds_since_epoch();
</pre>

<p>Returns the current number of seconds and nanoseconds since the Epoch
(UNIX-time). Uses <tt>posix::realtime_clock::get_time()</tt> to obtain the
result when available. The actual precision depends on the used platform.</p>




<h3 id="posix--realtime_clock">
<span class="h3_num">2.59.3</span><tt>posix::realtime_clock</tt>, <tt>posix::monotonic_clock</tt>
</h3>


<pre class="code">
#if _POSIX_TIMERS &gt; 0

class posix::realtime_clock
{
public:
    static constexpr clockid_t id = CLOCK_REALTIME;
    static constexpr bool is_steady = false;
    // BEGIN C++11
    using duration   = std::chrono::nanoseconds;
    using period     = duration::period;
    using rep        = duration::rep;
    using time_point = std::chrono::time_point&lt;realtime_clock, duration&gt;;

    static time_point now();
    // END C++11

    static posix::time_spec get_time();
};
#ifdef _POSIX_MONOTONIC_CLOCK
class posix::monotonic_clock
{
public:
    static constexpr clockid_t id = CLOCK_MONOTONIC;
    static constexpr bool is_steady = true;
    // BEGIN C++11
    using duration   = std::chrono::nanoseconds;
    using period     = duration::period;
    using rep        = duration::rep;
    using time_point = std::chrono::time_point&lt;monotonic_clock, duration&gt;;

    static time_point now();
    // END C++11

    static posix::time_spec get_time();
};
#endif

#endif
</pre>

<p>POSIX system clocks (<tt>clock_gettime()</tt>) with
<tt>&lt;chrono&gt;</tt>-clock interface. Absent in system not supporting them
(check <tt>_POSIX_TIMERS</tt> macro). Additionally <tt>monotonic_clock</tt>
is available only if <tt>_POSIX_MONOTONIC_CLOCK</tt> macro is defined.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">static constexpr clockid_t id</pre>
<blockquote>

<p>System ID of the clock.</p>
</blockquote>
</div>

<div>
<pre class="prototype">static time_spec get_time()</pre>
<blockquote>

<p>Returns the current time as <tt>posix::time_spec</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">static time_point now() <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Returns the current time as <tt>time_point</tt>.</p>
</blockquote>
</div>










<h1 id="build">
<span class="h1_num">3</span>Build and install</h1>

<p>To build the library you need one of supported C++ compilers and
<a href="https://www.gnu.org/software/make">GNU Make</a> utility version
3.82 or higher available in your command line environment (shell).</p>

<p>Currently supported compilers are:</p>
<ul>
<li>GNU C++ v 4.7+ [<tt>gcc</tt>]</li>
<li>Clang v 3.4+ [<tt>clang</tt>]</li>
</ul>

<p>Go to <tt>src</tt> subdirectory and write:</p>
<pre class="code">
$ gmake
</pre>
<p>The library file will be built for you.</p>

<p>C++17 is used by default but you can choose another language standard
version using <tt>std</tt> option. E.g. to build the library in C++98 mode
write:</p>
<pre class="code">
$ gmake std=98
</pre>

<p>Available values include: 98, 11, 14, 17, 20 and 23.</p>

<p>Also you can choose the used compiler manually:</p>
<pre class="code">
$ gmake compiler=gcc
</pre>

<p>To generate position-independent code (PIC) suitable for use in a shared
library write:</p>
<pre class="code">
$ gmake pic=1
</pre>

<p>Alternatively <a href="https://www.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1">
bmake</a> utility can be used on FreeBSD 10+ instead of gmake:</p>
<pre class="code">
$ make -f Makefile.freebsd
</pre>

<p>Finally, to use the library you just need to copy the library file and
contents of <tt>include</tt> subdirectory to some place where compiler/linker
can find it, e.g to <tt>/usr/local/include</tt> and <tt>/usr/local/lib</tt>.</p>



</div></body>
</html>
