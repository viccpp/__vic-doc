<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="ru">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>__vic's C++ library (POSIX)</title>
<style type="text/css">
body {
	font-family: verdana, sans-serif;
	font-size: 10pt;
	background-color: #777777;
	margin: 0;
}
div.page-wrap {
	background-color: white;
	width: 210mm; /* A4 */
	margin: 0 auto;
	padding: 2mm 5mm;
}
p, div {
	margin-top: 6pt;
	margin-bottom: 0;
}
h1, h2, h3, h4, h5, h6 {
	font-weight: bold;
	margin-top: 9pt;
	margin-bottom: 12pt;
	margin-left: 0;
}
h1 { font-size: 16pt; }
h2 { font-size: 13pt; }
h3 { font-size: 11pt; }
h4 { font-size: 11pt; }
span.h1_num, span.h2_num {
	margin-right: 2em;
	font-family: sans-serif;
}
span.h3_num, span.h4_num {
	margin-right: 2em;
	font-weight: normal;
	font-size: smaller;
}
h1.main-title {
	font-size: 2em;
	font-weight: bold;
}
caption.toc {
	text-align: left;
	font-weight: bold;
	font-size: 13pt;
	margin-top: 9pt;
	margin-bottom: 12pt;
	margin-left: 0;
}
td.toc-chapter-no {
	padding-right: 1ex;
	vertical-align: top;
}
a { text-decoration: none; }
a:hover { text-decoration: underline; }
pre.code {
	background-color: #EEE;
	border: 1px solid #CCCCCC;
	padding-top: 6pt;
	padding-bottom: 6pt;
	padding-left: 2pt;
	font-family: monospace;
	font-size: 10pt;
	width: 17.3cm; /* 80ch */
}
pre.prototype {
	font-family: monospace;
	margin-top: 0;
	margin-bottom: 0;
}
div.section {
	font-weight: bold;
}
div.todo {
	color: red;
	font-weight: bold;
}
span.ver {
	font-size: smaller;
	color: #C0C0C0;
}
span.nonterminal {
	font-family: monospace;
	font-style: italic;
}
span.sign {
	color: #C0C0C0;
	font-family: monospace;
	font-size: 9pt;
	font-weight: bold;
}
blockquote {
	margin-top: 6pt;
	margin-bottom: 0;
	margin-right: 0;
}
blockquote * {
	margin-top: 0;
	margin-bottom: 0;
}
</style>
</head>
<body><div class="page-wrap">
<h1 class="main-title">__vic's C++ library (POSIX)<span class="ver"> v1.0 [Draft]</span>
</h1>
<table style="font-size:10pt;" cellspacing="0" cellpadding="0">
<caption class="toc">Содержание</caption>
<tr>
<td class="toc-chapter-no">1</td>
<td><a href="#intro">Введение</a></td>
</tr>
<tr>
<td class="toc-chapter-no">1.1</td>
<td><a href="#why">Зачем эта библиотека была создана?</a></td>
</tr>
<tr>
<td class="toc-chapter-no">1.2</td>
<td><a href="#general-structure">Общая структура и использование</a></td>
</tr>
<tr><td colspan="2" style="font-size:5pt;"> </td></tr>
<tr>
<td class="toc-chapter-no">2</td>
<td><a href="#components-reference">Описание компонентов библиотеки</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1</td>
<td><a href="#defs.h"><tt>__vic/defs.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1.1</td>
<td style="padding-left:4ex"><a href="#nullptr"><tt>nullptr</tt> <span class="sign">[C++98 only]</span></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1.2</td>
<td style="padding-left:4ex"><a href="#noexcept"><tt>noexcept</tt> <span class="sign">[C++98 only]</span></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1.3</td>
<td style="padding-left:4ex"><a href="#array_size"><tt>array_size()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1.4</td>
<td style="padding-left:4ex"><a href="#non_copyable"><tt>non_copyable</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1.5</td>
<td style="padding-left:4ex"><a href="#non_heap_allocatable"><tt>non_heap_allocatable</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1.6</td>
<td style="padding-left:4ex"><a href="#std--move"><tt>std::move()</tt>, <tt>std::forward()</tt>, <tt>std::swap()</tt>
<span class="sign">[C++11]</span></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1.7</td>
<td style="padding-left:4ex"><a href="#VIC_SWAP_HEADER"><tt>__VIC_SWAP_HEADER</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1.8</td>
<td style="padding-left:4ex"><a href="#platform-dependent-macros">Системно-зависимые макроопределения</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.2</td>
<td><a href="#algorithm.h"><tt>__vic/algorithm.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.2.1</td>
<td style="padding-left:4ex"><a href="#skip_if_front"><tt>skip_if_front()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.2.2</td>
<td style="padding-left:4ex"><a href="#skip_if_back"><tt>skip_if_back()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.3</td>
<td><a href="#ascii.h"><tt>__vic/ascii.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.3.1</td>
<td style="padding-left:4ex"><a href="#ascii--is-functions"><tt>ascii::is</tt>-функции</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.3.2</td>
<td style="padding-left:4ex"><a href="#ascii--todigit"><tt>ascii::todigit()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.3.3</td>
<td style="padding-left:4ex"><a href="#ascii--toxdigit"><tt>ascii::toxdigit_upper()</tt>, <tt>ascii::toxdigit_lower()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.3.4</td>
<td style="padding-left:4ex"><a href="#ascii--digit_to_number"><tt>ascii::digit_to_number()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.3.5</td>
<td style="padding-left:4ex"><a href="#ascii--xdigit_to_number"><tt>ascii::xdigit_to_number()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.3.6</td>
<td style="padding-left:4ex"><a href="#ascii--tolower-char"><tt>ascii::tolower(char)</tt>, <tt>ascii::toupper(char)</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.3.7</td>
<td style="padding-left:4ex"><a href="#ascii--equal_icase-char"><tt>ascii::equal_icase(char,char)</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.4</td>
<td><a href="#ascii_string.h"><tt>__vic/ascii_string.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.4.1</td>
<td style="padding-left:4ex"><a href="#ascii--tolower-str"><tt>ascii::tolower()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.4.2</td>
<td style="padding-left:4ex"><a href="#ascii--toupper-str"><tt>ascii::toupper()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.4.3</td>
<td style="padding-left:4ex"><a href="#ascii--equal_icase-str"><tt>ascii::equal_icase()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5</td>
<td><a href="#base16.h"><tt>__vic/base16.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.1</td>
<td style="padding-left:4ex"><a href="#base16"><tt>base16</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.2</td>
<td style="padding-left:4ex"><a href="#base16--bad_format"><tt>base16::bad_format</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.3</td>
<td style="padding-left:4ex"><a href="#base16--bad_digit"><tt>base16::bad_digit</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.4</td>
<td style="padding-left:4ex"><a href="#base16--bad_length"><tt>base16::bad_length</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.5</td>
<td style="padding-left:4ex"><a href="#base16--status"><tt>base16::status</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.6</td>
<td style="padding-left:4ex"><a href="#base16--encode_upper"><tt>base16::encode_upper()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.7</td>
<td style="padding-left:4ex"><a href="#base16--encode_lower"><tt>base16::encode_lower()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.8</td>
<td style="padding-left:4ex"><a href="#base16--encode_byte_lower"><tt>base16::encode_byte_lower()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.9</td>
<td style="padding-left:4ex"><a href="#base16--encode_byte_upper"><tt>base16::encode_byte_upper()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.10</td>
<td style="padding-left:4ex"><a href="#base16--decode"><tt>base16::decode()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.11</td>
<td style="padding-left:4ex"><a href="#base16--try_decode"><tt>base16::try_decode()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6</td>
<td><a href="#base64.h"><tt>__vic/base64.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.1</td>
<td style="padding-left:4ex"><a href="#base64"><tt>base64</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.2</td>
<td style="padding-left:4ex"><a href="#base64--bad_format"><tt>base64::bad_format</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.3</td>
<td style="padding-left:4ex"><a href="#base64--bad_digit"><tt>base64::bad_digit</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.4</td>
<td style="padding-left:4ex"><a href="#base64--bad_length"><tt>base64::bad_length</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.5</td>
<td style="padding-left:4ex"><a href="#base64--status"><tt>base64::status</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.6</td>
<td style="padding-left:4ex"><a href="#base64--encode"><tt>base64::encode()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.7</td>
<td style="padding-left:4ex"><a href="#base64--decode"><tt>base64::decode()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.8</td>
<td style="padding-left:4ex"><a href="#base64--try_decode"><tt>base64::try_decode()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.9</td>
<td style="padding-left:4ex"><a href="#base64--encoded_length"><tt>base64::encoded_length()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.10</td>
<td style="padding-left:4ex"><a href="#base64--max_decoded_length"><tt>base64::max_decoded_length()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.7</td>
<td><a href="#bin_file.h"><tt>__vic/bin_file.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.7.1</td>
<td style="padding-left:4ex"><a href="#bin_file"><tt>bin_file</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8</td>
<td><a href="#bits.h"><tt>__vic/bits.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.1</td>
<td style="padding-left:4ex"><a href="#lo_nibble"><tt>lo_nibble()</tt>, <tt>hi_nibble()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.2</td>
<td style="padding-left:4ex"><a href="#msb_ones"><tt>msb_ones()</tt>, <tt>lsb_ones()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.3</td>
<td style="padding-left:4ex"><a href="#get_lsbs"><tt>get_lsbs()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.4</td>
<td style="padding-left:4ex"><a href="#ord"><tt>ord()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.5</td>
<td style="padding-left:4ex"><a href="#popcount"><tt>popcount()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.6</td>
<td style="padding-left:4ex"><a href="#msb_position"><tt>msb_position()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.7</td>
<td style="padding-left:4ex"><a href="#ispow2"><tt>ispow2()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.8</td>
<td style="padding-left:4ex"><a href="#ceil2"><tt>ceil2()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.9</td>
<td style="padding-left:4ex"><a href="#floor2"><tt>floor2()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.10</td>
<td style="padding-left:4ex"><a href="#ceil_log2"><tt>ceil_log2()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.11</td>
<td style="padding-left:4ex"><a href="#floor_log2"><tt>floor_log2()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.12</td>
<td style="padding-left:4ex"><a href="#rotl"><tt>rotl()</tt>, <tt>rotr()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.13</td>
<td style="padding-left:4ex"><a href="#swapped_nibbles"><tt>swapped_nibbles()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.9</td>
<td><a href="#bounded_vector.h"><tt>__vic/bounded_vector.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.9.1</td>
<td style="padding-left:4ex"><a href="#bounded_vector"><tt>bounded_vector</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.10</td>
<td><a href="#date_time.h"><tt>__vic/date_time.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.10.1</td>
<td style="padding-left:4ex"><a href="#is_leap_year"><tt>is_leap_year()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.10.2</td>
<td style="padding-left:4ex"><a href="#days_in_month"><tt>days_in_month()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.10.3</td>
<td style="padding-left:4ex"><a href="#days_between_years"><tt>days_between_years()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.10.4</td>
<td style="padding-left:4ex"><a href="#invalid_date"><tt>invalid_date</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.10.5</td>
<td style="padding-left:4ex"><a href="#validate_date_time"><tt>validate_date()</tt>, <tt>validate_time()</tt>,
<tt>validate_date_time()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.11</td>
<td><a href="#endian.h"><tt>__vic/endian.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.11.1</td>
<td style="padding-left:4ex"><a href="#endianness"><tt>endianness</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.11.2</td>
<td style="padding-left:4ex"><a href="#endian--from"><tt>endian::from_...()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.11.3</td>
<td style="padding-left:4ex"><a href="#endian--to"><tt>endian::to_...()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.11.4</td>
<td style="padding-left:4ex"><a href="#swab"><tt>swab16()</tt>, <tt>swab32()</tt>, <tt>swab64()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.12</td>
<td><a href="#error.h"><tt>__vic/error.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.12.1</td>
<td style="padding-left:4ex"><a href="#exception"><tt>exception</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.12.2</td>
<td style="padding-left:4ex"><a href="#libc_error"><tt>libc_error</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13</td>
<td><a href="#fs.h"><tt>__vic/fs.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.1</td>
<td style="padding-left:4ex"><a href="#path_exists"><tt>path_exists()</tt>, <tt>file_exists()</tt>, <tt>dir_exists()</tt>
</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.2</td>
<td style="padding-left:4ex"><a href="#mkdir"><tt>mkdir()</tt>, <tt>mkdir_if_absent()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.3</td>
<td style="padding-left:4ex"><a href="#rmdir"><tt>rmdir()</tt>, <tt>rmdir_if_exists()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.4</td>
<td style="padding-left:4ex"><a href="#get_current_dir"><tt>get_current_dir()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.5</td>
<td style="padding-left:4ex"><a href="#remove_file"><tt>remove_file()</tt>, <tt>remove_file_if_exists()</tt>,
<tt>remove_file_nt()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.6</td>
<td style="padding-left:4ex"><a href="#copy_file"><tt>copy_file()</tt>, <tt>copy_file_if_exists()</tt>,
<tt>copy_file_replace()</tt>, <tt>copy_file_replace_if_exists()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.7</td>
<td style="padding-left:4ex"><a href="#move_file"><tt>move_file()</tt>, <tt>move_file_if_exists()</tt>,
<tt>move_file_replace()</tt>, <tt>move_file_replace_if_exists()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.8</td>
<td style="padding-left:4ex"><a href="#rename_file"><tt>rename_file()</tt>, <tt>rename_file_if_exists()</tt>,
    <tt>rename_file_replace()</tt>, <tt>rename_file_replace_if_exists()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.9</td>
<td style="padding-left:4ex"><a href="#file_size"><tt>file_size()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.14</td>
<td><a href="#iterator.h"><tt>__vic/iterator.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.14.1</td>
<td style="padding-left:4ex"><a href="#begin-array"><tt>begin(T[])</tt>, <tt>end(T[])</tt>, <tt>cbegin(T[])</tt>,
<tt>cend(T[])</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.14.2</td>
<td style="padding-left:4ex"><a href="#advance"><tt>advance()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.14.3</td>
<td style="padding-left:4ex"><a href="#next"><tt>next()</tt>, <tt>prev()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.15</td>
<td><a href="#logger.h"><tt>__vic/logger.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.15.1</td>
<td style="padding-left:4ex"><a href="#logger"><tt>logger</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.16</td>
<td><a href="#memory.h"><tt>__vic/memory.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.16.1</td>
<td style="padding-left:4ex"><a href="#load_unaligned"><tt>load_unaligned()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.16.2</td>
<td style="padding-left:4ex"><a href="#store_unaligned"><tt>store_unaligned()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.17</td>
<td><a href="#mutex.h"><tt>__vic/mutex.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.17.1</td>
<td style="padding-left:4ex"><a href="#mutex"><tt>mutex</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.17.2</td>
<td style="padding-left:4ex"><a href="#mutex_lock"><tt>mutex_lock</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.18</td>
<td><a href="#packon.h"><tt>__vic/packon.h</tt> &amp; <tt>__vic/packoff.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.19</td>
<td><a href="#readers"><tt>__vic/readers/</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.19.1</td>
<td style="padding-left:4ex"><a href="#reader-concept"><tt>Reader</tt> concept</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.19.2</td>
<td style="padding-left:4ex"><a href="#iterator_reader"><tt>iterator_reader</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.19.3</td>
<td style="padding-left:4ex"><a href="#iterator_reader_n"><tt>iterator_reader_n</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.19.4</td>
<td style="padding-left:4ex"><a href="#container_reader"><tt>container_reader</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.19.5</td>
<td style="padding-left:4ex"><a href="#cstring_reader"><tt>cstring_reader</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.19.6</td>
<td style="padding-left:4ex"><a href="#string_reader"><tt>string_reader</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.19.7</td>
<td style="padding-left:4ex"><a href="#cstream_reader"><tt>cstream_reader</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.20</td>
<td><a href="#readonly_cstring.h"><tt>__vic/readonly_cstring.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.20.1</td>
<td style="padding-left:4ex"><a href="#readonly_cstring"><tt>readonly_cstring</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.21</td>
<td><a href="#set_of_chars.h"><tt>__vic/set_of_chars.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.21.1</td>
<td style="padding-left:4ex"><a href="#set_of_chars"><tt>set_of_chars</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.22</td>
<td><a href="#stdint.h"><tt>__vic/stdint.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.22.1</td>
<td style="padding-left:4ex"><a href="#intN_t">Целые с точной длиной</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.22.2</td>
<td style="padding-left:4ex"><a href="#int_leastN_t">Целые с минимальной длиной</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.22.3</td>
<td style="padding-left:4ex"><a href="#int_fastN_t">Быстрейшие целые с минимальной длиной</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.22.4</td>
<td style="padding-left:4ex"><a href="#intmax_t">Целые наибольшего размера</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.22.5</td>
<td style="padding-left:4ex"><a href="#intptr_t">Целые, вмещающие указатели на объекты</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.22.6</td>
<td style="padding-left:4ex"><a href="#int_exactly_bytes"><tt>int_exactly_bytes&lt;&gt;</tt>, <tt>uint_exactly_bytes&lt;&gt;</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.23</td>
<td><a href="#stdio_file.h"><tt>__vic/stdio_file.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.23.1</td>
<td style="padding-left:4ex"><a href="#stdio_file"><tt>stdio_file</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.23.2</td>
<td style="padding-left:4ex"><a href="#read-FILE-char"><tt>read(std::FILE, char&amp;)</tt>,
    <tt>read(std::FILE, unsigned char&amp;)</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.23.3</td>
<td style="padding-left:4ex"><a href="#write-FILE-char"><tt>write(std::FILE, char)</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.23.4</td>
<td style="padding-left:4ex"><a href="#getline-FILE"><tt>getline(std::FILE)</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.24</td>
<td><a href="#str2num.h"><tt>__vic/str2num.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.24.1</td>
<td style="padding-left:4ex"><a href="#decimal_to_number"><tt>decimal_to_number()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.24.2</td>
<td style="padding-left:4ex"><a href="#decimal_to_number_range"><tt>decimal_to_number_range()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.24.3</td>
<td style="padding-left:4ex"><a href="#decimal_parser"><tt>decimal_parser</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.24.4</td>
<td style="padding-left:4ex"><a href="#number_parse_status"><tt>number_parse_status</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.25</td>
<td><a href="#string_buffer.h"><tt>__vic/string_buffer.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.25.1</td>
<td style="padding-left:4ex"><a href="#string_buffer"><tt>string_buffer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.26</td>
<td><a href="#string_ref.h"><tt>__vic/string_ref.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.26.1</td>
<td style="padding-left:4ex"><a href="#string_ref"><tt>string_ref</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.27</td>
<td><a href="#string_utils.h"><tt>__vic/string_utils.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.27.1</td>
<td style="padding-left:4ex"><a href="#trim">Набор функций <tt>trim</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.27.2</td>
<td style="padding-left:4ex"><a href="#sift"><tt>sift()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.27.3</td>
<td style="padding-left:4ex"><a href="#sift_if"><tt>sift_if()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.27.4</td>
<td style="padding-left:4ex"><a href="#pad_front"><tt>pad_front()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.27.5</td>
<td style="padding-left:4ex"><a href="#pad_back"><tt>pad_back()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.27.6</td>
<td style="padding-left:4ex"><a href="#starts_with"><tt>starts_with()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.27.7</td>
<td style="padding-left:4ex"><a href="#ends_with"><tt>ends_with()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28</td>
<td><a href="#tchar.h"><tt>__vic/tchar.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.1</td>
<td style="padding-left:4ex"><a href="#tchar--length"><tt>tchar::length()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.2</td>
<td style="padding-left:4ex"><a href="#tchar--empty"><tt>tchar::empty()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.3</td>
<td style="padding-left:4ex"><a href="#tchar--end"><tt>tchar::end()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.4</td>
<td style="padding-left:4ex"><a href="#tchar--compare"><tt>tchar::compare()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.5</td>
<td style="padding-left:4ex"><a href="#tchar--equal"><tt>tchar::equal()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.6</td>
<td style="padding-left:4ex"><a href="#tchar--copy"><tt>tchar::copy()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.7</td>
<td style="padding-left:4ex"><a href="#tchar--move"><tt>tchar::move()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.8</td>
<td style="padding-left:4ex"><a href="#tchar--concat"><tt>tchar::concat()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.9</td>
<td style="padding-left:4ex"><a href="#tchar--find"><tt>tchar::find()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.10</td>
<td style="padding-left:4ex"><a href="#tchar--rfind"><tt>tchar::rfind()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.11</td>
<td style="padding-left:4ex"><a href="#tchar--find_if"><tt>tchar::find_if()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.12</td>
<td style="padding-left:4ex"><a href="#tchar--find_if_not"><tt>tchar::find_if_not()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.13</td>
<td style="padding-left:4ex"><a href="#tchar--rfind_if"><tt>tchar::rfind_if()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.14</td>
<td style="padding-left:4ex"><a href="#tchar--rfind_if_not"><tt>tchar::rfind_if_not()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.15</td>
<td style="padding-left:4ex"><a href="#tchar--find_first_of"><tt>tchar::find_first_of()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.16</td>
<td style="padding-left:4ex"><a href="#tchar--find_first_not_of"><tt>tchar::find_first_not_of()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.17</td>
<td style="padding-left:4ex"><a href="#tchar--find_last_of"><tt>tchar::find_last_of()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.18</td>
<td style="padding-left:4ex"><a href="#tchar--find_last_not_of"><tt>tchar::find_last_not_of()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.19</td>
<td style="padding-left:4ex"><a href="#tchar--skip"><tt>tchar::skip()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.29</td>
<td><a href="#thread.h"><tt>__vic/thread.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.29.1</td>
<td style="padding-left:4ex"><a href="#thread"><tt>thread</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.29.2</td>
<td style="padding-left:4ex"><a href="#thread--id"><tt>thread::id</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.29.3</td>
<td style="padding-left:4ex"><a href="#this_thread"><tt>this_thread</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.30</td>
<td><a href="#throw_errno.h"><tt>__vic/throw_errno.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.30.1</td>
<td style="padding-left:4ex"><a href="#throw_errno"><tt>throw_errno()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.31</td>
<td><a href="#to_text.h"><tt>__vic/to_text.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.31.1</td>
<td style="padding-left:4ex"><a href="#to_text_append"><tt>to_text_append()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32</td>
<td><a href="#type_traits.h"><tt>__vic/type_traits.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.1</td>
<td style="padding-left:4ex"><a href="#integral_constant"><tt>integral_constant</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.2</td>
<td style="padding-left:4ex"><a href="#true_type"><tt>true_type</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.3</td>
<td style="padding-left:4ex"><a href="#false_type"><tt>false_type</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.4</td>
<td style="padding-left:4ex"><a href="#is_same"><tt>is_same</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.5</td>
<td style="padding-left:4ex"><a href="#is_const"><tt>is_const</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.6</td>
<td style="padding-left:4ex"><a href="#is_signed_integer"><tt>is_signed_integer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.7</td>
<td style="padding-left:4ex"><a href="#is_unsigned_integer"><tt>is_unsigned_integer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.8</td>
<td style="padding-left:4ex"><a href="#conjunction"><tt>conjunction</tt> <span class="sign">[C++11]</span></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.9</td>
<td style="padding-left:4ex"><a href="#disjunction"><tt>disjunction</tt> <span class="sign">[C++11]</span></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.10</td>
<td style="padding-left:4ex"><a href="#negation"><tt>negation</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.11</td>
<td style="padding-left:4ex"><a href="#remove_const"><tt>remove_const</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.12</td>
<td style="padding-left:4ex"><a href="#remove_volatile"><tt>remove_volatile</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.13</td>
<td style="padding-left:4ex"><a href="#remove_cv"><tt>remove_cv</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.14</td>
<td style="padding-left:4ex"><a href="#remove_reference"><tt>remove_reference</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.15</td>
<td style="padding-left:4ex"><a href="#remove_cvref"><tt>remove_cvref</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.16</td>
<td style="padding-left:4ex"><a href="#remove_pointer"><tt>remove_pointer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.17</td>
<td style="padding-left:4ex"><a href="#conditional"><tt>conditional</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.18</td>
<td style="padding-left:4ex"><a href="#enable_if"><tt>enable_if</tt>, <tt>disable_if</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.19</td>
<td style="padding-left:4ex"><a href="#index_sequence"><tt>index_sequence</tt>, <tt>make_index_sequence</tt> <span class="sign">[C++11]</span></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.33</td>
<td><a href="#unicode.h"><tt>__vic/unicode.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.33.1</td>
<td style="padding-left:4ex"><a href="#unicode_t"><tt>unicode_t</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.33.2</td>
<td style="padding-left:4ex"><a href="#utf_transcode"><tt>utf_transcode()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.33.3</td>
<td style="padding-left:4ex"><a href="#unicode_code_point_constants"><tt>Code point constants</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.34</td>
<td><a href="#utf8.status.h"><tt>__vic/utf8/status.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.34.1</td>
<td style="padding-left:4ex"><a href="#utf8--status"><tt>utf8::status</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.34.2</td>
<td style="padding-left:4ex"><a href="#utf8--is_error"><tt>utf8::is_error()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.34.3</td>
<td style="padding-left:4ex"><a href="#utf8--throw_if_error"><tt>utf8::throw_if_error()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.35</td>
<td><a href="#utf8.exceptions.h"><tt>__vic/utf8/exceptions.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.36</td>
<td><a href="#utf8.reader.h"><tt>__vic/utf8/reader.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.36.1</td>
<td style="padding-left:4ex"><a href="#utf8--reader"><tt>utf8::reader</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.37</td>
<td><a href="#utf8.writer.h"><tt>__vic/utf8/writer.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.37.1</td>
<td style="padding-left:4ex"><a href="#utf8--writer"><tt>utf8::writer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.38</td>
<td><a href="#utf16.defs.h"><tt>__vic/utf16/defs.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.38.1</td>
<td style="padding-left:4ex"><a href="#utf16--code_unit_t"><tt>utf16::code_unit_t</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.39</td>
<td><a href="#utf16.status.h"><tt>__vic/utf16/status.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.39.1</td>
<td style="padding-left:4ex"><a href="#utf16--status"><tt>utf16::status</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.39.2</td>
<td style="padding-left:4ex"><a href="#utf16--is_error"><tt>utf16::is_error()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.39.3</td>
<td style="padding-left:4ex"><a href="#utf16--throw_if_error"><tt>utf16::throw_if_error()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.40</td>
<td><a href="#utf16.exceptions.h"><tt>__vic/utf16/exceptions.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.41</td>
<td><a href="#utf16.reader.h"><tt>__vic/utf16/reader.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.41.1</td>
<td style="padding-left:4ex"><a href="#utf16--reader"><tt>utf16::reader</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.42</td>
<td><a href="#utf16.writer.h"><tt>__vic/utf16/writer.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.42.1</td>
<td style="padding-left:4ex"><a href="#utf16--writer"><tt>utf16::writer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.43</td>
<td><a href="#waitable_event.h"><tt>__vic/waitable_event.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.43.1</td>
<td style="padding-left:4ex"><a href="#waitable_event"><tt>waitable_event</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.44</td>
<td><a href="#writers"><tt>__vic/writers/</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.44.1</td>
<td style="padding-left:4ex"><a href="#writer-concept"><tt>Writer</tt> concept</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.44.2</td>
<td style="padding-left:4ex"><a href="#null_writer"><tt>null_writer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.44.3</td>
<td style="padding-left:4ex"><a href="#push_back_writer"><tt>push_back_writer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.44.4</td>
<td style="padding-left:4ex"><a href="#iterator_writer"><tt>iterator_writer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.44.5</td>
<td style="padding-left:4ex"><a href="#string_writer"><tt>string_writer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.44.6</td>
<td style="padding-left:4ex"><a href="#cstream_writer"><tt>cstream_writer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.45</td>
<td><a href="#posix.cond_variable.h"><tt>__vic/posix/cond_variable.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.45.1</td>
<td style="padding-left:4ex"><a href="#posix--cond_variable"><tt>posix::cond_variable</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.46</td>
<td><a href="#posix.daemon_control.h"><tt>__vic/posix/daemon_control.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.46.1</td>
<td style="padding-left:4ex"><a href="#posix--daemon_control"><tt>posix::daemon_control</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.47</td>
<td><a href="#posix.dir_entries.h"><tt>__vic/posix/dir_entries.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.47.1</td>
<td style="padding-left:4ex"><a href="#posix--dir_entries"><tt>posix::dir_entries</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.48</td>
<td><a href="#posix.dir_files.h"><tt>__vic/posix/dir_files.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.48.1</td>
<td style="padding-left:4ex"><a href="#posix--dir_files"><tt>posix::dir_files</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.49</td>
<td><a href="#posix.error.h"><tt>__vic/posix/error.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.49.1</td>
<td style="padding-left:4ex"><a href="#posix--is_EAGAIN"><tt>posix::is_EAGAIN()</tt>, <tt>posix::is_ENOENT()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.50</td>
<td><a href="#posix.file.h"><tt>__vic/posix/file.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.50.1</td>
<td style="padding-left:4ex"><a href="#posix--file"><tt>posix::file</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.51</td>
<td><a href="#posix.file_stat.h"><tt>__vic/posix/file_stat.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.51.1</td>
<td style="padding-left:4ex"><a href="#posix--file_stat"><tt>posix::file_stat</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.52</td>
<td><a href="#posix.fs.h"><tt>__vic/posix/fs.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.52.1</td>
<td style="padding-left:4ex"><a href="#posix--basename"><tt>posix::basename()</tt>, <tt>posix::dirname()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.52.2</td>
<td style="padding-left:4ex"><a href="#posix--add_trailing_slash"><tt>posix::add_trailing_slash()</tt>,
    <tt>posix::with_trailing_slash()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.53</td>
<td><a href="#posix.iov.h"><tt>__vic/posix/iov.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.53.1</td>
<td style="padding-left:4ex"><a href="#posix--ovectors"><tt>posix::ovectors</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.53.2</td>
<td style="padding-left:4ex"><a href="#posix--total-iovec"><tt>posix::total(iovec[])</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.53.3</td>
<td style="padding-left:4ex"><a href="#posix--cut_prefix-iovec"><tt>posix::cut_prefix(iovec[])</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.53.4</td>
<td style="padding-left:4ex"><a href="#posix--writev_all"><tt>posix::writev_all()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.54</td>
<td><a href="#posix.mutex.h"><tt>__vic/posix/mutex.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.54.1</td>
<td style="padding-left:4ex"><a href="#posix--mutex"><tt>posix::mutex</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.54.2</td>
<td style="padding-left:4ex"><a href="#posix--mutex_lock"><tt>posix::mutex_lock</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.55</td>
<td><a href="#posix.pidfile.h"><tt>__vic/posix/pidfile.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.55.1</td>
<td style="padding-left:4ex"><a href="#posix--pidfile"><tt>posix::pidfile</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.56</td>
<td><a href="#posix.process.h"><tt>__vic/posix/process.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.56.1</td>
<td style="padding-left:4ex"><a href="#posix--daemon"><tt>posix::daemon()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.56.2</td>
<td style="padding-left:4ex"><a href="#posix--ignore_signals"><tt>posix::ignore_signals()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.56.3</td>
<td style="padding-left:4ex"><a href="#posix--process_alive"><tt>posix::process_alive()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.57</td>
<td><a href="#posix.sigset.h"><tt>__vic/posix/sigset.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.57.1</td>
<td style="padding-left:4ex"><a href="#posix--sigset"><tt>posix::sigset</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.58</td>
<td><a href="#posix.thread.h"><tt>__vic/posix/thread.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.58.1</td>
<td style="padding-left:4ex"><a href="#posix--this_thread"><tt>posix::this_thread</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.58.2</td>
<td style="padding-left:4ex"><a href="#posix--this_thread--sigwait"><tt>posix::this_thread::sigwait()</tt>,
       <tt>posix::this_thread::sigwait_at_most()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.58.3</td>
<td style="padding-left:4ex"><a href="#posix--this_thread--sigwaitinfo"><tt>posix::this_thread::sigwaitinfo()</tt>,
       <tt>posix::this_thread::sigwaitinfo_at_most()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.58.4</td>
<td style="padding-left:4ex"><a href="#posix--this_thread--block_signals"><tt>posix::this_thread::block_signals()</tt>,
       <tt>posix::this_thread::unblock_signals()</tt>,
       <tt>posix::this_thread::set_sigmask()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.59</td>
<td><a href="#posix.time.h"><tt>__vic/posix/time.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.59.1</td>
<td style="padding-left:4ex"><a href="#posix--time_spec"><tt>posix::time_spec</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.59.2</td>
<td style="padding-left:4ex"><a href="#posix--nanoseconds_since_epoch"><tt>posix::nanoseconds_since_epoch()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.59.3</td>
<td style="padding-left:4ex"><a href="#posix--realtime_clock"><tt>posix::realtime_clock</tt>, <tt>posix::monotonic_clock</tt></a></td>
</tr>
<tr><td colspan="2" style="font-size:5pt;"> </td></tr>
<tr>
<td class="toc-chapter-no">3</td>
<td><a href="#build">Сборка и установка</a></td>
</tr>
<tr><td colspan="2" style="font-size:5pt;"> </td></tr>
</table>




<h1 id="intro">
<span class="h1_num">1</span>Введение</h1>

<h2 id="why">
<span class="h2_num">1.1</span>Зачем эта библиотека была создана?</h2>


<p>Данная библиотека содержит компоненты, которых мне не хватает в
Стандартной библиотеке C++. Это, своего рода, мой личный
<a href="http://www.boost.org/">Boost</a>.</p>

<p>Дополнительно, это уровень абстракции, который скрывает детали реализации,
ошибки и причуды различных ОС, компиляторов и реализаций Стандартной
библиотеки.</p>



<h2 id="general-structure">
<span class="h2_num">1.2</span>Общая структура и использование</h2>


<p>Структурными единицами самого верхнего уровня в библиотеке являются
заголовочные файлы и файл библиотеки (или архив) - <tt>lib__vic.a</tt> или
<tt>__vic.lib</tt>. Обычно файл библиотеки имеет дополнительный суффикс,
вроде <tt>lib__vic14.a</tt>. Все заголовочные файлы располагаются в подкаталоге
<tt>__vic/</tt>. Включать их следует следующим образом:</p>

<pre class="code">
#include &lt;__vic/<span class="nonterminal">header.h</span>&gt;
</pre>

<p>Где <tt><span class="nonterminal">header.h</span></tt> - это имя нужного заголовочного файла.</p>

<p>Практически весь код находится внутри пространства имён <tt>__vic</tt>,
включая другие пространства имён.</p>

<p>При компоновке программы, нужно подсунуть компоновщику файл библиотеки.
Например:</p>

<pre class="code">
$ g++ -std=c++14 prog.cpp -l__vic14
</pre>

<p>Библиотека может быть собрана с использованием одного из стандартов ISO C++:
C++98, C++11, C++14, C++17, C++20 или C++23. Суффикс стандарта используется в
качестве суффикса файла библиотеки (архива).</p>

<p>Некоторые компоненты библиотеки требуют какую-то минимальную версию
стандарта, например многие требуют использования как минимум C++11. Такие
компоненты помечаются значком <span class="sign">[C++11]</span>, который означает «C++11 или
более старшие версии».</p>

<p>Некоторые компоненты библиотеки доступны только для какой-то конкретной
версии стандарта и не доступны для других. Такие компоненты помечаются значком
<span class="sign">[C++98 only]</span>.</p>

<p>Детальное описание компонентов библиотеки приведено в последующих главах.
Описание сгруппировано по заголовочным файлам. В основном используется синтаксис
C++23, как более богатый и выразительный.</p>





<h1 id="components-reference">
<span class="h1_num">2</span>Описание компонентов библиотеки</h1>

<h2 id="defs.h">
<span class="h2_num">2.1</span><tt>__vic/defs.h</tt>
</h2>

<p>Различные фундаментальные определения.</p>


<h3 id="nullptr">
<span class="h3_num">2.1.1</span><tt>nullptr</tt> <span class="sign">[C++98 only]</span>
</h3>


<p>Литерал для пустого указателя. Может использоваться вместо <tt>NULL</tt> или
<tt>0</tt>. В режиме ISO C++ 98 определён как</p>

<pre class="code">
const int nullptr = 0;
</pre>

<p>Данное определение позволяет писать код в стиле C++11 при использовании
стандарта C++98.</p>

<p>Это одно из немногих глобальных определений библиотеки. Определение можно
предотвратить, определив макрос <tt>__VIC_NO_NULLPTR_DEF</tt> перед включением.
</p>

<div class="section">Пример</div>
<pre class="code">
int *p = nullptr;
pthread_create(&amp;tid, nullptr, thread_func, nullptr);
</pre>





<h3 id="noexcept">
<span class="h3_num">2.1.2</span><tt>noexcept</tt> <span class="sign">[C++98 only]</span>
</h3>


<p>В режиме C++98 - макроопределение, синоним <tt>throw()</tt>. В режимах
остальных стандартов данное определение отсутсвует.</p>




<h3 id="array_size">
<span class="h3_num">2.1.3</span><tt>array_size()</tt>
</h3>


<pre class="code">
template&lt;class T, size_t N&gt;
constexpr size_t array_size(T (&amp;array)[N]);
</pre>

<p>Возвращает количество элементов массива. Может вычисляться во время
компиляции.</p>

<div class="section">Пример</div>
<pre class="code">
int m[] = { 1, 2, 3, 5, 7 };

size_t n = __vic::array_size(m); // n == 5

int *dup = new int[n];
</pre>





<h3 id="non_copyable">
<span class="h3_num">2.1.4</span><tt>non_copyable</tt>
</h3>


<pre class="code">
class non_copyable
{
    non_copyable(const non_copyable &amp;) = delete;
    non_copyable &amp;operator=(const non_copyable &amp;) = delete;
protected:
    non_copyable() = default;
};
</pre>

<p>Наследование данного класса подавляет генерацию копирующих конструктора
и присваивания. Аналог <tt>boost::noncopyable</tt>.</p>

<div class="section">Пример</div>
<pre class="code">
class C : private __vic::non_copyable
{
};

C c1;
C c2 = c1; // Error! Non-copyable object
</pre>





<h3 id="non_heap_allocatable">
<span class="h3_num">2.1.5</span><tt>non_heap_allocatable</tt>
</h3>


<pre class="code">
class non_heap_allocatable
{
    void *operator new(std::size_t ) = delete;
    void *operator new(std::size_t , const std::nothrow_t &amp; ) = delete;
    void *operator new[](std::size_t ) = delete;
    void *operator new[](std::size_t , const std::nothrow_t &amp; ) = delete;
protected:
    non_heap_allocatable() = default;
};
</pre>

<p>Наследование данного класса предотвращает размещение объекта в куче с
использованием оператора <tt>new</tt>.</p>

<div class="section">Пример</div>
<pre class="code">
class C : private __vic::non_heap_allocatable
{
};

C c; // Ok. Allocation on stack
C *p = new C; // Error! Attempt to allocate on heap
</pre>





<h3 id="std--move">
<span class="h3_num">2.1.6</span><tt>std::move()</tt>, <tt>std::forward()</tt>, <tt>std::swap()</tt>
<span class="sign">[C++11]</span>
</h3>


<p>Данный заголовочный файл всегда включает эти утилиты в режиме C++11.</p>




<h3 id="VIC_SWAP_HEADER">
<span class="h3_num">2.1.7</span><tt>__VIC_SWAP_HEADER</tt>
</h3>


<p>Макроопределение для <tt>#include</tt>. Раскрывается в имя заголовочного
файла, который содержит определение <tt>std::swap()</tt>, в зависимости от
используемого стандарта языка.</p>

<div class="section">Пример</div>
<pre class="code">
#include __VIC_SWAP_HEADER
</pre>





<h3 id="platform-dependent-macros">
<span class="h3_num">2.1.8</span>Системно-зависимые макроопределения</h3>


<p>Библиотека предоставляет набор макроопределений, позволяющий программе
определить, для какой целевой платформы она собирается. Подобные определения
предоставляются компиляторами, но везде под разными именами. Использование
макроопределений библиотеки позволяет не зависеть от компилятора.</p>

<p>Список аппаратных платформ (процессоров):</p>
<ul>
<li>
<tt>__VIC_X86__</tt> - Intel x86 (IA32)</li>
<li>
<tt>__VIC_X64__</tt> - x64 aka AMD 64</li>
<li>
<tt>__VIC_IA64__</tt> - Intel IA64</li>
<li>
<tt>__VIC_POWERPC__</tt> - PowerPC</li>
</ul>

<p>Другие макроопределения:</p>
<ul><li>
<tt>__VIC_STRICT_RAM_ALIGNMENT__</tt> - попытка вычитать из памяти
        невыровненные данные приведёт к ошибке шины</li></ul>






<h2 id="algorithm.h">
<span class="h2_num">2.2</span><tt>__vic/algorithm.h</tt>
</h2>


<p>Обобщённые алгоритмы.</p>


<h3 id="skip_if_front">
<span class="h3_num">2.2.1</span><tt>skip_if_front()</tt>
</h3>


<pre class="code">
template&lt;
    std::forward_iterator Iter,
    std::predicate&lt;std::iter_value_t&lt;Iter&gt;&gt; Pred
&gt;
Iter skip_if_front(Iter begin, Iter end, Pred pred);
</pre>

<p>Пропускает все элементы в начале последовательности, удовлетворяющие данному
предикату, и возвращает начало получившейся последовательности.</p>




<h3 id="skip_if_back">
<span class="h3_num">2.2.2</span><tt>skip_if_back()</tt>
</h3>


<pre class="code">
template&lt;
    std::bidirectional_iterator Iter,
    std::predicate&lt;std::iter_value_t&lt;Iter&gt;&gt; Pred
&gt;
Iter skip_if_back(Iter begin, Iter end, Pred pred);
</pre>

<p>Пропускает все элементы в конце последовательности, удовлетворяющие данному
предикату, и возвращает конец получившейся последовательности.</p>






<h2 id="ascii.h">
<span class="h2_num">2.3</span><tt>__vic/ascii.h</tt>
</h2>


<p>Быстрые, компактные и независимые от locale инструменты для обработки
ASCII-символов. Все инструменты находятся в пространстве имён
<tt>__vic::ascii</tt>.</p>


<h3 id="ascii--is-functions">
<span class="h3_num">2.3.1</span><tt>ascii::is</tt>-функции</h3>


<pre class="code">
namespace ascii {

constexpr bool isdigit(char c);
constexpr bool isxdigit(char c);
constexpr bool islower(char c);
constexpr bool isupper(char c);
constexpr bool isalpha(char c);
constexpr bool isalnum(char c);
constexpr bool isspace(char c);
constexpr bool isblank(char c);
constexpr bool isprint(char c);
constexpr bool isgraph(char c);
constexpr bool ispunct(char c);
constexpr bool iscntrl(char c);
constexpr bool isascii(char c);

}
</pre>

<p>Аналоги соответствующих функций из <tt>&lt;cctype&gt;</tt>.</p>




<h3 id="ascii--todigit">
<span class="h3_num">2.3.2</span><tt>ascii::todigit()</tt>
</h3>


<pre class="code">
constexpr char ascii::todigit(int d);
</pre>

<p>Преобразует целое значение от 0 до 9 в десятичную цифру. Результат
неопределён, если входное значение не попадает в указанный диапазон.</p>
<div>
<u>Предусловие</u>: <tt>0 &lt;= d &amp;&amp; d &lt;= 9</tt>
</div>




<h3 id="ascii--toxdigit">
<span class="h3_num">2.3.3</span><tt>ascii::toxdigit_upper()</tt>, <tt>ascii::toxdigit_lower()</tt>
</h3>


<pre class="code">
namespace ascii {

constexpr char toxdigit_upper(int d);
constexpr char toxdigit_lower(int d);

}
</pre>

<p>Преобразует целое значение от 0 до 15 в шестнадцатеричную цифру. Первая
функция использует верхний регистр для <tt>A</tt>-<tt>F</tt>, вторая - нижний.
Результат неопределён, если входное значение не попадает в указанный диапазон.
</p>
<div>
<u>Предусловие</u>: <tt>0 &lt;= d &amp;&amp; d &lt;= 15</tt>
</div>




<h3 id="ascii--digit_to_number">
<span class="h3_num">2.3.4</span><tt>ascii::digit_to_number()</tt>
</h3>


<pre class="code">
constexpr int ascii::digit_to_number(char d);
</pre>

<p>Преобразует десятичную цифру в число, если <tt>ascii::isdigit(d)</tt>.
В противном случае возвращается <tt>-1</tt>.</p>




<h3 id="ascii--xdigit_to_number">
<span class="h3_num">2.3.5</span><tt>ascii::xdigit_to_number()</tt>
</h3>


<pre class="code">
constexpr int ascii::xdigit_to_number(char d);
</pre>

<p>Преобразует шестнадцатеричную цифру в число, если
<tt>ascii::isxdigit(d)</tt>. В противном случае возвращается <tt>-1</tt>.</p>




<h3 id="ascii--tolower-char">
<span class="h3_num">2.3.6</span><tt>ascii::tolower(char)</tt>, <tt>ascii::toupper(char)</tt>
</h3>


<pre class="code">
namespace ascii {

constexpr char tolower(char c);
constexpr char toupper(char c);
constexpr char upper_to_lower(char upper);
constexpr char lower_to_upper(char lower);

}
</pre>

<div>
<pre class="prototype">constexpr char tolower(char c)</pre>
<pre class="prototype">constexpr char toupper(char c)</pre>
<blockquote>


<p>Аналоги соответствующих функций из <tt>&lt;cctype&gt;</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">constexpr char upper_to_lower(char upper)</pre>
<blockquote>

<p>Более ограниченный аналог <tt>tolower()</tt>. Результат неопределён, если
аргумент не является заглавной буквой ASCII.</p>
<div>
<u>Предусловие</u>: <tt>ascii::isupper(upper)</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">constexpr char lower_to_upper(char lower)</pre>
<blockquote>

<p>Более ограниченный аналог <tt>toupper()</tt>. Результат неопределён, если
аргумент не является строчной буквой ASCII.</p>
<div>
<u>Предусловие</u>: <tt>ascii::islower(lower)</tt>
</div>
</blockquote>
</div>




<h3 id="ascii--equal_icase-char">
<span class="h3_num">2.3.7</span><tt>ascii::equal_icase(char,char)</tt>
</h3>


<pre class="code">
constexpr bool ascii::equal_icase(char ch1, char ch2);
</pre>

<p>Проверяет два ASCII-символа на равенство без учета регистра букв.</p>






<h2 id="ascii_string.h">
<span class="h2_num">2.4</span><tt>__vic/ascii_string.h</tt>
</h2>


<p>Инструменты обработки ASCII-строк.</p>


<h3 id="ascii--tolower-str">
<span class="h3_num">2.4.1</span><tt>ascii::tolower()</tt>
</h3>


<pre class="code">
namespace ascii {

char *tolower(char *str);
std::string &amp;tolower(std::string &amp;str);

}
</pre>

<p>Переводит все заглавные латинские буквы <tt>str</tt> в строчные. Возвращает
<tt>str</tt>. Указатель на C-строку не должен быть <tt>nullptr</tt>!</p>




<h3 id="ascii--toupper-str">
<span class="h3_num">2.4.2</span><tt>ascii::toupper()</tt>
</h3>


<pre class="code">
namespace ascii {

char *toupper(char *str);
std::string &amp;toupper(std::string &amp;str);

}
</pre>

<p>Переводит все строчные латинские буквы <tt>str</tt> в заглавные. Возвращает
<tt>str</tt>. Указатель на C-строку не должен быть <tt>nullptr</tt>!</p>




<h3 id="ascii--equal_icase-str">
<span class="h3_num">2.4.3</span><tt>ascii::equal_icase()</tt>
</h3>


<pre class="code">
namespace ascii {

bool equal_icase(const char *s1, const char *s2);
bool equal_icase(const char *s1, size_t s1_len,
                 const char *s2, size_t s2_len);

#if __cpp_lib_string_view // C++17

bool equal_icase(std::string_view s1, std::string_view s2);

#else // until C++17

bool equal_icase(const std::string &amp;s1, const std::string &amp;s2);
bool equal_icase(const std::string &amp;s1, const char *s2);
bool equal_icase(const char *s1, const std::string &amp;s2);

#endif
}
</pre>

<p>Проверяет две ASCII-строки на равенство без учета регистра букв. Указатели
на строки не должны быть <tt>nullptr</tt>!</p>






<h2 id="base16.h">
<span class="h2_num">2.5</span><tt>__vic/base16.h</tt>
</h2>


<p>Кодировщик и декодировщик Base16.</p>


<h3 id="base16">
<span class="h3_num">2.5.1</span><tt>base16</tt>
</h3>


<p>Класс, используемый как пространство имён. Содержит только типы, константы
и статические функции. Создание объектов данного класса не предполагается.</p>




<h3 id="base16--bad_format">
<span class="h3_num">2.5.2</span><tt>base16::bad_format</tt>
</h3>


<pre class="code">
struct base16::bad_format : public std::exception {};
</pre>

<p>Абстрактный базовый класс исключений.</p>




<h3 id="base16--bad_digit">
<span class="h3_num">2.5.3</span><tt>base16::bad_digit</tt>
</h3>


<pre class="code">
struct base16::bad_digit : public base16::bad_format
{
    const char *what() const noexcept;
};
</pre>

<p>Класс исключений, бросаемый <a href="#base16--decode"><tt>base16::decode()</tt></a> если входная
последовательность содержит символ, не являющийся шестнадцатеричной цифрой.</p>




<h3 id="base16--bad_length">
<span class="h3_num">2.5.4</span><tt>base16::bad_length</tt>
</h3>


<pre class="code">
struct base16::bad_length : public base16::bad_format
{
    const char *what() const noexcept;
};
</pre>

<p>Класс исключений, бросаемый <a href="#base16--decode"><tt>base16::decode()</tt></a> если входная
последовательность состоит из нечётного количества символов.</p>




<h3 id="base16--status">
<span class="h3_num">2.5.5</span><tt>base16::status</tt>
</h3>


<pre class="code">
enum class base16::status
{
    ok,
    invalid_length,
    invalid_digit
};
using base16::status_t = base16::status; // for C++98
</pre>

<p>Коды статусов разбора входной последовательности, возвращаемые
<a href="#base16--try_decode"><tt>base16::try_decode()</tt></a>.</p>




<h3 id="base16--encode_upper">
<span class="h3_num">2.5.6</span><tt>base16::encode_upper()</tt>
</h3>


<pre class="code">
// Bytes -&gt; Text
template&lt;class ByteReader, class CharWriter&gt;
void base16::encode_upper(ByteReader reader, CharWriter writer);
</pre>

<p>Кодирует байты из <tt>reader</tt> и записывает результирующие символы во
<tt>writer</tt>. Для шестнадцатеричных цифр используется верхний регистр.</p>

<p><tt>ByteReader</tt> должен моделировать concept
<tt>Reader&lt;unsigned char&gt;</tt>. См. <a href="#readers"><tt>__vic/readers/</tt></a>.</p>

<p><tt>CharWriter</tt> должен моделировать concept <tt>Writer&lt;char&gt;</tt>.
См. <a href="#writers"><tt>__vic/writers/</tt></a>.</p>


<div class="section">Пример</div>
<pre class="code">
#include&lt;__vic/readers/string.h&gt;
#include&lt;__vic/writers/string.h&gt;

using bytes = std::string;
using bytes_reader = __vic::string_reader;

std::string encode_base16(const bytes &amp;s)
{
    std::string res;
    res.reserve(s.length() * 2);
    __vic::base16::encode_upper(bytes_reader(s), __vic::string_writer(res));
    return res;
}
</pre>





<h3 id="base16--encode_lower">
<span class="h3_num">2.5.7</span><tt>base16::encode_lower()</tt>
</h3>


<pre class="code">
// Bytes -&gt; Text
template&lt;class ByteReader, class CharWriter&gt;
void base16::encode_lower(ByteReader reader, CharWriter writer);
</pre>

<p>То же самое, что <a href="#base16--encode_upper"><tt>base16::encode_upper()</tt></a>, но использует нижний
регистр для шестнадцатеричных цифр.</p>




<h3 id="base16--encode_byte_lower">
<span class="h3_num">2.5.8</span><tt>base16::encode_byte_lower()</tt>
</h3>


<pre class="code">
// Byte -&gt; Text
template&lt;class CharWriter&gt;
void base16::encode_byte_lower(unsigned char byte, CharWriter writer);
</pre>

<p>То же самое, что <a href="#base16--encode_lower"><tt>base16::encode_lower()</tt></a>, но кодирует
единственный байт.</p>




<h3 id="base16--encode_byte_upper">
<span class="h3_num">2.5.9</span><tt>base16::encode_byte_upper()</tt>
</h3>


<pre class="code">
// Byte -&gt; Text
template&lt;class CharWriter&gt;
void base16::encode_byte_upper(unsigned char byte, CharWriter writer);
</pre>

<p>То же самое, что <a href="#base16--encode_upper"><tt>base16::encode_upper()</tt></a>, но кодирует
единственный байт.</p>




<h3 id="base16--decode">
<span class="h3_num">2.5.10</span><tt>base16::decode()</tt>
</h3>


<pre class="code">
// Text -&gt; Bytes
template&lt;class CharReader, class ByteWriter&gt;
void base16::decode(CharReader reader, ByteWriter writer);
</pre>

<p>Декодирует символы из <tt>reader</tt> и записывает результирующие байты во
<tt>writer</tt>. Если входная последовательность имеет неправильный Base16
формат, бросается исключение наследник <a href="#base16--bad_format"><tt>base16::bad_format</tt></a>.</p>

<p><tt>CharReader</tt> должен моделировать concept <tt>Reader&lt;char&gt;</tt>.
См. <a href="#readers"><tt>__vic/readers/</tt></a>.</p>

<p><tt>ByteWriter</tt> должен моделировать concept
<tt>Writer&lt;unsigned char&gt;</tt>. См. <a href="#writers"><tt>__vic/writers/</tt></a>.</p>

<div class="section">Пример</div>
<pre class="code">
#include&lt;__vic/readers/string.h&gt;
#include&lt;__vic/writers/string.h&gt;

using bytes = std::string;
using bytes_writer = __vic::string_writer;

bytes decode_base16(const std::string &amp;s)
{
    bytes res;
    res.reserve(s.length() / 2);
    __vic::base16::decode(__vic::string_reader(s), bytes_writer(res));
    return res;
}
</pre>





<h3 id="base16--try_decode">
<span class="h3_num">2.5.11</span><tt>base16::try_decode()</tt>
</h3>


<pre class="code">
// Text -&gt; Bytes
template&lt;class CharReader, class ByteWriter&gt;
base16::status_t base16::try_decode(CharReader reader, ByteWriter writer);
</pre>

<p>То же самое, что <a href="#base16--decode"><tt>base16::decode()</tt></a>, но возвращает
<a href="#base16--status"><tt>base16::status</tt></a> отличный от <tt>base16::status::ok</tt> в случае
неправильного формата входной последовательности вместо бросания исключений.</p>






<h2 id="base64.h">
<span class="h2_num">2.6</span><tt>__vic/base64.h</tt>
</h2>


<p>Кодировщик и декодировщик Base64.</p>


<h3 id="base64">
<span class="h3_num">2.6.1</span><tt>base64</tt>
</h3>


<p>Класс, используемый как пространство имён. Содержит только типы, константы
и статические функции. Создание объектов данного класса не предполагается.</p>




<h3 id="base64--bad_format">
<span class="h3_num">2.6.2</span><tt>base64::bad_format</tt>
</h3>


<pre class="code">
struct base64::bad_format : public std::exception {};
</pre>

<p>Абстрактный базовый класс исключений.</p>




<h3 id="base64--bad_digit">
<span class="h3_num">2.6.3</span><tt>base64::bad_digit</tt>
</h3>


<pre class="code">
struct base64::bad_digit : public base64::bad_format
{
    const char *what() const noexcept;
};
</pre>

<p>Класс исключений, бросаемый <a href="#base64--decode"><tt>base64::decode()</tt></a> если входная
последовательность содержит символ, не являющийся цифрой Base64.</p>




<h3 id="base64--bad_length">
<span class="h3_num">2.6.4</span><tt>base64::bad_length</tt>
</h3>


<pre class="code">
struct base64::bad_length : public base64::bad_format
{
    const char *what() const noexcept;
};
</pre>

<p>Класс исключений, бросаемый <a href="#base64--decode"><tt>base64::decode()</tt></a> если входная
последовательность состоит из количества символов не кратного 4.</p>




<h3 id="base64--status">
<span class="h3_num">2.6.5</span><tt>base64::status</tt>
</h3>


<pre class="code">
enum class base64::status
{
    ok,
    invalid_length,
    invalid_digit
};
using base64::status_t = base64::status; // for C++98
</pre>

<p>Коды статусов разбора входной последовательности, возвращаемые
<a href="#base64--try_decode"><tt>base64::try_decode()</tt></a>.</p>




<h3 id="base64--encode">
<span class="h3_num">2.6.6</span><tt>base64::encode()</tt>
</h3>


<pre class="code">
// Bytes -&gt; Text
template&lt;class ByteReader, class CharWriter&gt;
void base64::encode(ByteReader reader, CharWriter writer);
</pre>

<p>Кодирует байты из <tt>reader</tt> и записывает результирующие символы во
<tt>writer</tt>.</p>

<p><tt>ByteReader</tt> должен моделировать concept
<tt>Reader&lt;unsigned char&gt;</tt>. См. <a href="#readers"><tt>__vic/readers/</tt></a>.</p>

<p><tt>CharWriter</tt> должен моделировать concept <tt>Writer&lt;char&gt;</tt>.
См. <a href="#writers"><tt>__vic/writers/</tt></a>.</p>

<div class="section">Пример</div>
<pre class="code">
#include&lt;__vic/readers/string.h&gt;
#include&lt;__vic/writers/string.h&gt;

using bytes = std::string;
using bytes_reader = __vic::string_reader;

std::string encode_base64(const bytes &amp;s)
{
    std::string res;
    res.reserve(__vic::base64::encoded_length(s.length()));
    __vic::base64::encode(bytes_reader(s), __vic::string_writer(res));
    return res;
}
</pre>





<h3 id="base64--decode">
<span class="h3_num">2.6.7</span><tt>base64::decode()</tt>
</h3>


<pre class="code">
// Text -&gt; Bytes
template&lt;class CharReader, class ByteWriter&gt;
void base64::decode(CharReader reader, ByteWriter writer);
</pre>

<p>Декодирует символы из <tt>reader</tt> и записывает результирующие байты во
<tt>writer</tt>. Если входная последовательность имеет неправильный Base64
формат, бросается исключение наследник <a href="#base64--bad_format"><tt>base64::bad_format</tt></a>.</p>

<p><tt>CharReader</tt> должен моделировать concept <tt>Reader&lt;char&gt;</tt>.
См. <a href="#readers"><tt>__vic/readers/</tt></a>.</p>

<p><tt>ByteWriter</tt> должен моделировать concept
<tt>Writer&lt;unsigned char&gt;</tt>. См. <a href="#writers"><tt>__vic/writers/</tt></a>.</p>

<div class="section">Пример</div>
<pre class="code">
#include&lt;__vic/readers/string.h&gt;
#include&lt;__vic/writers/string.h&gt;

using bytes = std::string;
using bytes_writer = __vic::string_writer;

bytes decode_base64(const std::string &amp;s)
{
    bytes res;
    res.reserve(__vic::base64::max_decoded_length(s.length()));
    __vic::base64::decode(__vic::string_reader(s), bytes_writer(res));
    return res;
}
</pre>





<h3 id="base64--try_decode">
<span class="h3_num">2.6.8</span><tt>base64::try_decode()</tt>
</h3>


<pre class="code">
// Text -&gt; Bytes
template&lt;class CharReader, class ByteWriter&gt;
base64::status_t base64::try_decode(CharReader reader, ByteWriter writer);
</pre>

<p>То же самое, что <a href="#base64--decode"><tt>base64::decode()</tt></a>, но возвращает
<a href="#base64--status"><tt>base64::status</tt></a> отличный от <tt>base64::status::ok</tt> в случае
неправильного формата входной последовательности вместо бросания исключений.</p>




<h3 id="base64--encoded_length">
<span class="h3_num">2.6.9</span><tt>base64::encoded_length()</tt>
</h3>


<pre class="code">
constexpr size_t base64::encoded_length(size_t orig_len);
</pre>

<p>Высчитывает длину закодированной последовательности символов на основе длины
входной последовательности в байтах.</p>




<h3 id="base64--max_decoded_length">
<span class="h3_num">2.6.10</span><tt>base64::max_decoded_length()</tt>
</h3>


<pre class="code">
constexpr size_t base64::max_decoded_length(size_t orig_len);
</pre>

<p>Оценивает максимальную длину декодированной последовательности байтов на
основе длины входной последовательности символов. Точная длина зависит от
символов <tt>'='</tt> на конце закодированной последовательности.</p>






<h2 id="bin_file.h">
<span class="h2_num">2.7</span><tt>__vic/bin_file.h</tt>
</h2>


<h3 id="bin_file">
<span class="h3_num">2.7.1</span><tt>bin_file</tt>
</h3>


<pre class="code">
class bin_file : private non_copyable
{
public:
    enum in_t { in };
    enum out_t { out };
    enum append_t { append };

    bin_file();
    bin_file(const char *fname, in_t);
    bin_file(const char *fname, out_t);
    bin_file(const char *fname, append_t);
    ~bin_file();

    // BEGIN C++11
    bin_file(bin_file &amp;&amp;o) noexcept;
    bin_file &amp;operator=(bin_file &amp;&amp;o) noexcept;
    // END C++11

    bool open_in(const char *fname);
    bool open_out(const char *fname);
    bool open_append(const char *fname);

    size_t read_max(void *buf, size_t n);
    size_t read_some(void *buf, size_t n);

    void write_all(const void *buf, size_t n);

    bool is_open() const;
    void close();
    bool close_nt() noexcept;

    void swap(bin_file &amp;o) noexcept;

    [[noreturn]] void throw_last_error(const char *msg);
    void throw_if_closed(const char *msg);
};
</pre>

<p>Небуферизированный двоичный файл. Независимая от ОС обёртка низкоуровневого
системного API.</p>

<p>Доступны следующие режимы открытия:</p>
<ul>
<li>
<tt>in</tt> - открыть существующий файл для чтения;</li>
<li>
<tt>out</tt> - создать новый файл для записи, перетереть старый,
        если уже существует;</li>
<li>
<tt>append</tt> - открыть существующий файл для добавления (запись в
        конец файла), создать новый, если не существует.</li>
</ul>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">enum in_t { in }</pre>
<pre class="prototype">enum out_t { out }</pre>
<pre class="prototype">enum append_t { append }</pre>
<blockquote>



<p>Тэги конструкторов.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bin_file()</pre>
<blockquote>

<div>
<u>Постусловие</u>: <tt>is_open() == false()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bin_file(const char *fname, in_t)</pre>
<pre class="prototype">bin_file(const char *fname, out_t)</pre>
<pre class="prototype">bin_file(const char *fname, append_t)</pre>
<blockquote>



<p>Вызывают <tt>open_in(fname)</tt>, <tt>open_out(fname)</tt> или
<tt>open_append(fname)</tt>, соответственно. <tt>is_open()</tt> или
<tt>throw_if_closed()</tt> должен быть вызван после для проверки результата.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~bin_file()</pre>
<blockquote>

<p>Закрывает файл, если <tt>is_open() == true</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bin_file(bin_file &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<pre class="prototype">bin_file &amp;operator=(bin_file &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Операции перемещения для режима C++11.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool open_in(const char *fname)</pre>
<pre class="prototype">bool open_out(const char *fname)</pre>
<pre class="prototype">bool open_append(const char *fname)</pre>
<blockquote>



<p>Открыть файл для чтения, записи или добавления, соответственно. Возвращает
<tt>is_open()</tt>.</p>
<div>
<u>Предусловие</u>: <tt>is_open() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool is_open() const</pre>
<blockquote>

<p>Возвращает <tt>true</tt> если файл открыт.</p>
</blockquote>
</div>

<div>
<pre class="prototype">size_t read_max(void *buf, size_t n)</pre>
<blockquote>

<p>Пытается прочитать <tt>n</tt> байтов в указанный буфер. Возвращает количество
байтов, которое удалось прочитать. Возвращённое значение может быть меньше
запрошенного только в случае, если достигнут конец файла. При ошибках бросает
исключения.</p>
<div>
<u>Предусловие</u>: <tt>is_open() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">size_t read_some(void *buf, size_t n)</pre>
<blockquote>

<p>Читает не более <tt>n</tt> байтов в указанный буфер. Возвращает количество
прочитанных байтов или <tt>0</tt> при достижении конца файлов. Функция
сразу возвращает управление, как только прочитан блок байтов любого размера.
При ошибках бросает исключения.</p>
<div>
<u>Предусловие</u>: <tt>is_open() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void write_all(const void *buf, size_t n)</pre>
<blockquote>

<p>Записывает весь переданный буфер в файл. При ошибках бросает исключения.</p>
<div>
<u>Предусловие</u>: <tt>is_open() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void close()</pre>
<blockquote>

<p>Закрывает открытый файл. При ошибках бросает исключения.</p>
<div>
<u>Предусловие</u>: <tt>is_open() == true</tt>
</div>
<div>
<u>Постусловие</u>: <tt>is_open() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool close_nt() noexcept</pre>
<blockquote>

<p>Аналог <tt>close()</tt>, но никогда не бросает исключений. Вместо этого
возвращает <tt>false</tt> при ошибках.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void swap(bin_file &amp;o) noexcept</pre>
<blockquote>

<p>Обменивается значением с <tt>o</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">[[noreturn]] void throw_last_error(const char *msg)</pre>
<blockquote>

<p>Бросает исключение с описанием последней ошибки, если оно доступно. В любом
случае <tt>what()</tt> будет содержать <tt>msg</tt> в виде подстроки.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void throw_if_closed(const char *msg)</pre>
<blockquote>

<p>Вызывает <tt>throw_last_error(msg)</tt>, если <tt>!is_open()</tt>.</p>
</blockquote>
</div>



<div class="section">Пример</div>
<pre class="code">
// Copy file
__vic::bin_file in("file", __vic::bin_file::in);
in.throw_if_closed("Cannot open file")
__vic::bin_file out("file.copy", __vic::bin_file::out);
out.throw_if_closed("Cannot create file")

char buf[512];
while(size_t n = in.read_some(buf, sizeof buf))
    out.write_all(buf, n);

out.close();
// in will be closed by destructor
</pre>






<h2 id="bits.h">
<span class="h2_num">2.8</span><tt>__vic/bits.h</tt>
</h2>


<p>Инструменты для манипуляции битами и байтами.</p>


<h3 id="lo_nibble">
<span class="h3_num">2.8.1</span><tt>lo_nibble()</tt>, <tt>hi_nibble()</tt>
</h3>


<pre class="code">
constexpr uint8_t lo_nibble(uint8_t byte);
constexpr uint8_t hi_nibble(uint8_t byte);
</pre>

<p>Возвращают значение младшего/старшего полубайта (тетрады), соответственно.
</p>




<h3 id="msb_ones">
<span class="h3_num">2.8.2</span><tt>msb_ones()</tt>, <tt>lsb_ones()</tt>
</h3>


<pre class="code">
template&lt;class T&gt; constexpr T lsb_ones(unsigned bits_num);
template&lt;class T&gt; constexpr T msb_ones(unsigned bits_num);
</pre>

<p>Возвращают значение типа <tt>T</tt> со всеми младшими/старшими
<tt>bits_num</tt> битами заполненными <tt>1</tt>, соответственно. Все остальные
биты установлены в <tt>0</tt>.</p>




<h3 id="get_lsbs">
<span class="h3_num">2.8.3</span><tt>get_lsbs()</tt>
</h3>


<pre class="code">
template&lt;class T&gt; constexpr T get_lsbs(T v, unsigned bits_num);
</pre>

<p>Возвращает <tt>bits_num</tt> младших битов значения <tt>v</tt>. Другими
словами, заполняет нулями все, кроме младших <tt>bits_num</tt> битов.</p>




<h3 id="ord">
<span class="h3_num">2.8.4</span><tt>ord()</tt>
</h3>


<pre class="code">
constexpr int ord(char ch);
</pre>

<p>Возвращает код символа от 0 до 255.</p>
<div>
<u>Постусловие</u>: ord(ch) &gt;= 0</div>




<h3 id="popcount">
<span class="h3_num">2.8.5</span><tt>popcount()</tt>
</h3>


<pre class="code">
unsigned popcount(unsigned v);
unsigned popcount(unsigned long v);
unsigned popcount(unsigned long long v);
unsigned popcount(unsigned short v);
unsigned popcount(unsigned char v);
</pre>

<p>Возвращает количество единичных битов в данном значении.</p>




<h3 id="msb_position">
<span class="h3_num">2.8.6</span><tt>msb_position()</tt>
</h3>


<pre class="code">
unsigned msb_position(unsigned v)
unsigned msb_position(unsigned long v);
unsigned msb_position(unsigned long long v);
unsigned msb_position(unsigned short v);
unsigned msb_position(unsigned char v);
</pre>

<div>
<u>Предусловие</u>: <tt>v != 0</tt>
</div>

<p>Возвращает позицию самого значимого единичного бита. Результат неопределён,
если <tt>v == 0</tt>.</p>




<h3 id="ispow2">
<span class="h3_num">2.8.7</span><tt>ispow2()</tt>
</h3>


<pre class="code">
template&lt;class UInt&gt;
bool ispow2(UInt n);
</pre>

<div>
<u>Предусловие</u>: <tt>UInt</tt> - беззнаковый целый тип</div>

<p>Возвращает <tt>true</tt>, если <tt>n</tt> является целой степенью 2.</p>




<h3 id="ceil2">
<span class="h3_num">2.8.8</span><tt>ceil2()</tt>
</h3>


<pre class="code">
template&lt;class UInt&gt;
UInt ceil2(UInt n);
</pre>

<div>
<u>Предусловие</u>: <tt>UInt</tt> - беззнаковый целый тип</div>

<p>Возвращает минимальное значение <tt>m</tt>, такое что <tt>ispow(m) &amp;&amp;
m &gt;= n</tt>. Если <tt>m</tt> непредставимо типом <tt>UInt</tt>, результат
неопределён.</p>




<h3 id="floor2">
<span class="h3_num">2.8.9</span><tt>floor2()</tt>
</h3>


<pre class="code">
template&lt;class UInt&gt;
UInt floor2(UInt n);
</pre>

<div>
<u>Предусловие</u>: <tt>UInt</tt> - беззнаковый целый тип</div>

<p>Если <tt>n != 0</tt>, возвращает максимальное значение <tt>m</tt>, такое что
<tt>ispow2(m) &amp;&amp; m &lt;= n</tt>. В противном случае возвращается
<tt>0</tt>.</p>




<h3 id="ceil_log2">
<span class="h3_num">2.8.10</span><tt>ceil_log2()</tt>
</h3>


<pre class="code">
template&lt;class UInt&gt;
unsigned ceil_log2(UInt n);
</pre>

<div>
<u>Предусловие</u>: <tt>UInt</tt> - беззнаковый целый тип</div>

<p>Возвращает <tt>ceil(log2(n))</tt>, если <tt>n != 0</tt>, или 0 в
противном случае.</p>




<h3 id="floor_log2">
<span class="h3_num">2.8.11</span><tt>floor_log2()</tt>
</h3>


<pre class="code">
template&lt;class UInt&gt;
unsigned floor_log2(UInt n);
</pre>

<div>
<u>Предусловие</u>: <tt>UInt</tt> - беззнаковый целый тип</div>

<p>Возвращает <tt>floor(log2(n))</tt>, если <tt>n != 0</tt>, или 0 в
противном случае.</p>




<h3 id="rotl">
<span class="h3_num">2.8.12</span><tt>rotl()</tt>, <tt>rotr()</tt>
</h3>


<pre class="code">
unsigned long long rotl(unsigned long long v, int shift);
unsigned long      rotl(unsigned long v, int shift);
unsigned           rotl(unsigned v, int shift);
unsigned short     rotl(unsigned short v, int shift);
unsigned char      rotl(unsigned char v, int shift);

unsigned long long rotr(unsigned long long v, int shift);
unsigned long      rotr(unsigned long v, int shift);
unsigned           rotr(unsigned v, int shift);
unsigned short     rotr(unsigned short v, int shift);
unsigned char      rotr(unsigned char v, int shift);
</pre>

<p>Функции выполняют циклический побитовый сдвиг (rotation) влево
(<tt>rotl</tt>) или вправо (<tt>rotr</tt>).</p>
<div>
<u>Предусловие</u>: <tt>0 &lt;= shift &amp;&amp; shift &lt; sizeof(v)*CHAR_BIT</tt>
</div>




<h3 id="swapped_nibbles">
<span class="h3_num">2.8.13</span><tt>swapped_nibbles()</tt>
</h3>


<pre class="code">
constexpr uint8_t swapped_nibbles(uint8_t b);
</pre>

<p>Меняет местами младший и старший полубайт значения и возвращает его.</p>






<h2 id="bounded_vector.h">
<span class="h2_num">2.9</span><tt>__vic/bounded_vector.h</tt>
</h2>


<h3 id="bounded_vector">
<span class="h3_num">2.9.1</span><tt>bounded_vector</tt>
</h3>

<pre class="code">
template&lt;class T&gt;
class bounded_vector : private non_copyable
{
public:
    using value_type     = T;
    using iterator       = <span class="nonterminal">&lt;implementation-defined&gt;</span>;
    using const_iterator = <span class="nonterminal">&lt;implementation-defined&gt;</span>;

    bounded_vector();
    explicit bounded_vector(size_t max_size);
    ~bounded_vector();

    // BEGIN C++11
    bounded_vector(bounded_vector &amp;&amp;o) noexcept;
    bounded_vector &amp;operator=(bounded_vector &amp;&amp;o) noexcept;
    template&lt;class... Args&gt; T &amp;emplace_back(Args &amp;&amp;... args)
    // END C++11

    // size in objects
    size_t size() const;
    size_t capacity() const;
    bool full() const;
    bool empty() const;

    void recreate(size_t new_max_size, bool size_exact = false);
    void *alloc(); // returns pointer to memory for object allocation
    void push_allocated(); // adds last allocated object to the container
    void pop_back();
    void clear();
    void swap(bounded_vector &amp;o) noexcept;

    // element access
    T &amp;operator[](size_t i);
    iterator begin();
    iterator end();
    T &amp;front();
    T &amp;back();

    const T &amp;operator[](size_t i) const;
    const_iterator begin() const;
    const_iterator end() const;
    const_iterator cbegin() const;
    const_iterator cend() const;
    const T &amp;front() const;
    const T &amp;back() const;
};
template&lt;class T&gt;
void swap(bounded_vector&lt;T&gt; &amp;o1, bounded_vector&lt;T&gt; &amp;o2) noexcept;
</pre>

<p>Стандартные контейнеры в C++98 не позволяют хранить в себе объекты, которые
нельзя копировать (недоступны копирующий конструктор и копирующее присваивание).
Даже в C++11 элементы контейнера, вроде <tt>std::vector</tt>, должны быть как
минимум noexcept-перемещаемыми. Данный класс решает эту проблему и представляет
собой массив некопируемых объектов, или <tt>std::vector</tt>,
<tt>capacity()</tt> которого не растёт автоматически.</p>

<p>Без использования <tt>emplace_back()</tt> невозможно создать произвольный
новый объект непосредственно в памяти контейнера. В C++98 forwarding ссылки
вообще отсутствуют, делая почти невозможным передачу произвольных параметров в
конструктор элемента. В <tt>bounded_vector</tt> это ограничение обходится с
использованием следующего механизма. Создание элемента происходит в несколько
фаз:</p>
<ol>
<li>Запрос в контейнере блока памяти, достаточного для размешения
        объекта - <tt>alloc()</tt>,</li>
<li>Создание объекта в полученной памяти с помощью placement new -
        <tt>new(ptr) type(...)</tt>,</li>
<li>Фиксация успешно созданного объекта в контейнере -
        <tt>push_allocated()</tt>.</li>
</ol>
<p>Пример кода смотрите в конце статьи.</p>

<p>При создании задаётся максимальная ёмкость контейнера. Изменить в будущем
её можно, но только разрушив содержащиеся в нём объекты, то есть пересоздав
контейнер (функция <tt>recreate()</tt>).</p>

<p>Всегда следует использовать функцию <tt>emplace_back()</tt> для создания
элементов, когда она доступна. Если же нет, то использовать небезопасный
интерфейс, описанный выше, с большой осторожностью. Он достаточно страшный и
подверженный ошибкам, но выполняет свою функцию. После того, как элемент
размещён в контейнере, работать с ним также удобно, как и с любым другим
копируемым объектом в стандартных контейнерах. В любом случае, в целом это
гораздо удобнее и эффективнее использования альтернатив, таких как создание
объектов в куче с последующим хранением в контейнере указателей на них, даже
если нам доступен <tt>std::unique_ptr</tt> для управления временем жизни
объектов.</p>

<p>Принципиальные отличия от <tt>std::vector</tt>:</p>
<ol>
<li>Элементы могут быть некопируемыми и неперемещаемыми
        (<tt>std::vector</tt> требует как минимум noexcept-перемещаемости);</li>
<li>Адреса элементов стабильны при добавлении новых;</li>
<li>
<tt>emplace_back()</tt> имеет предусловие (<tt>!full()</tt>).</li>
</ol>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">typename value_type</pre>
<blockquote>

<p>Тип элементов.</p>
</blockquote>
</div>

<div>
<pre class="prototype">typename iterator</pre>
<pre class="prototype">typename const_iterator</pre>
<blockquote>


<p>Итераторы.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bounded_vector()</pre>
<blockquote>

<p>Создаёт объект без выделения памяти под элементы.</p>
<div>
<u>Постусловие</u>: <tt>capacity() == 0</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">explicit bounded_vector(size_t max_size)</pre>
<blockquote>

<p>Создаёт контейнер ёмкости <tt>max_size</tt> элементов.</p>
<div>
<u>Постусловие</u>: <tt>capacity() == max_size</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">~bounded_vector()</pre>
<blockquote>

<p>Вызывает <tt>clear()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bounded_vector(bounded_vector &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<pre class="prototype">bounded_vector &amp;operator=(bounded_vector &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Операции перемещения для режима C++11.</p>
</blockquote>
</div>

<div>
<pre class="prototype">size_t size() const</pre>
<pre class="prototype">size_t capacity() const</pre>
<blockquote>


<p>Текущее и максимальное количество элементов в данном экземпляре контейнера.
</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool empty() const</pre>
<blockquote>

<p>Возвращает <tt>size() == 0</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool full() const</pre>
<blockquote>

<p>Возвращает <tt>size() == capacity()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void recreate(size_t new_max_size, bool size_exact = false)</pre>
<blockquote>

<p>Пересоздаёт контейнер. Сначала вызывается <tt>clear()</tt>, затем
перевыделяется буфер, если <tt>new_max_size &gt; capacity()</tt> или <tt>size_exact
== true</tt> и <tt>new_max_size != capacity()</tt>.</p>
<div>
<u>Постусловие</u>: <tt>capacity() &gt;= new_max_size &amp;&amp; empty() == true</tt>
(если <tt>size_exact == true</tt>, то <tt>capacity() == new_max_size &amp;&amp;
empty() == true</tt>)</div>
</blockquote>
</div>

<div>
<pre class="prototype">void *alloc()</pre>
<blockquote>

<p>Возвращает указатель на блок памяти, достаточный для размещения экземпляра
<tt>value_type</tt>.</p>
<div>
<u>Предусловие</u>: <tt>!full()</tt>
</div>
<div>
<u>Замечание</u>: Используйте <tt>emplace_back()</tt> в режиме C++11.</div>
</blockquote>
</div>

<div>
<pre class="prototype">void push_allocated()</pre>
<blockquote>

<p>Фиксирует успешно созданный объект в контейнере, увеличивая <tt>size()</tt>
на единицу.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class... Args&gt; T &amp;emplace_back(Args &amp;&amp;... args) <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Конструирует новый объект в контейнере с помощью переданных аргументов и
увеличивает <tt>size()</tt> на единицу (<tt>alloc()</tt> + <tt>new</tt> +
<tt>push_allocated()</tt> одним вызовом). Возвращает ссылку на новый элемент.
</p>
<div>
<u>Предусловие</u>: <tt>!full()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void pop_back()</pre>
<blockquote>

<p>Удаляет из контейнера последний элемент.</p>
<div>
<u>Предусловие</u>: <tt>!empty()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void clear()</pre>
<blockquote>

<p>Разрушает все элементы контейнера в порядке обратном порядку создания.</p>
<div>
<u>Постусловие</u>: <tt>size() == 0</tt> (<tt>empty() == true</tt>)</div>
</blockquote>
</div>

<div>
<pre class="prototype">void swap(bounded_vector &amp;o)</pre>
<pre class="prototype">template&lt;class T&gt; void swap(bounded_vector&lt;T&gt; &amp;o1, bounded_vector&lt;T&gt; &amp;o2) noexcept</pre>
<blockquote>


<p>Обменивается значением с <tt>o</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">T &amp;operator[](size_t i)</pre>
<pre class="prototype">const T &amp;operator[](size_t i) const</pre>
<blockquote>


<p>Доступ к элементам контейнера по индексу.</p>
<div>
<u>Предусловие</u>: <tt>i &lt; size()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">T &amp;front()</pre>
<pre class="prototype">const T &amp;front() const</pre>
<pre class="prototype">T &amp;back()</pre>
<pre class="prototype">const T &amp;back() const</pre>
<blockquote>




<p>Доступ к первому и последнему элементу контейнера.</p>
<div>
<u>Предусловие</u>: <tt>!empty()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">iterator begin()</pre>
<pre class="prototype">const_iterator begin() const</pre>
<pre class="prototype">const_iterator cbegin() const</pre>
<pre class="prototype">iterator end()</pre>
<pre class="prototype">const_iterator end() const</pre>
<pre class="prototype">const_iterator cend() const</pre>
<blockquote>






<p>Доступ к элементам через итераторы.</p>
</blockquote>
</div>



<div class="section">Пример</div>
<pre class="code">
// Создаём вектор на два объекта класса C
__vic::bounded_vector&lt;C&gt; v(2);

// Создание элемента в режиме C++98:
new(v.alloc()) C(...); // Запрашиваем блок памяти и создаём в нём объект
v.push_allocated();    // Фиксируем в контейнере успешно созданный объект

// Создание элемента в режиме C++11:
v.emplace_back(...);
</pre>






<h2 id="date_time.h">
<span class="h2_num">2.10</span><tt>__vic/date_time.h</tt>
</h2>


<p>Работа с датой и временем.</p>


<h3 id="is_leap_year">
<span class="h3_num">2.10.1</span><tt>is_leap_year()</tt>
</h3>


<pre class="code">
constexpr bool is_leap_year(int year);
</pre>

<p>Определяет, является ли данный год високосным, согласно Григорианскому
календарю.</p>




<h3 id="days_in_month">
<span class="h3_num">2.10.2</span><tt>days_in_month()</tt>
</h3>


<pre class="code">
int days_in_month(int month, int year);
</pre>

<p>Возвращает количество дней в данном месяце. Месяц - это число от 1 до 12.
Второй параметр используется только, если месяц - 2 (февраль), в остальных
случаях просто игнорируется.</p>




<h3 id="days_between_years">
<span class="h3_num">2.10.3</span><tt>days_between_years()</tt>
</h3>


<pre class="code">
long days_between_years(unsigned year1, unsigned year2);
</pre>

<p>Возвращает разность в днях между началами годов <tt>year2</tt> и
<tt>year1</tt>.</p>




<h3 id="invalid_date">
<span class="h3_num">2.10.4</span><tt>invalid_date</tt>
</h3>


<pre class="code">
class invalid_date; // : public std::exception
</pre>

<p>Исключение, бросаемое в случае неправильного элемента даты или времени.</p>




<h3 id="validate_date_time">
<span class="h3_num">2.10.5</span><tt>validate_date()</tt>, <tt>validate_time()</tt>,
<tt>validate_date_time()</tt>
</h3>


<pre class="code">
void validate_date(int yy, int mm, int dd);
void validate_time(int hh, int mi, int ss);
void validate_date_time(int yy, int mm, int dd, int hh, int mi, int ss);
</pre>

<p>Проверяет правильность даты/времени. Проверяются следующие ограничения:</p>
<ul>
<li>
<tt>yy</tt> (год) - не может быть <tt>0</tt>,</li>
<li>
<tt>mm</tt> (месяц) - <tt>1..12</tt>,</li>
<li>
<tt>dd</tt> (день месяца) - <tt>1..{28..31}</tt>, в зависимости
        от месяца,</li>
<li>
<tt>hh</tt> (час) - <tt>0..23</tt>,</li>
<li>
<tt>mi</tt> (минута) - <tt>0..59</tt>,</li>
<li>
<tt>ss</tt> (секунда) - <tt>0..59</tt>.</li>
</ul>

<p>В случае нарушения какого-то из ограничений бросается <tt>invalid_date</tt>.
</p>

<div>
<u><b>Замечание</b></u>: Специальные значения, такие как <tt>24:00:00</tt> (полночь в конце дня)
или <tt>59:60</tt> (високосная секунда) рассматриваются как неправильные!</div>






<h2 id="endian.h">
<span class="h2_num">2.11</span><tt>__vic/endian.h</tt>
</h2>


<p>Утилиты для манипуляций порядком байт.</p>


<h3 id="endianness">
<span class="h3_num">2.11.1</span><tt>endianness</tt>
</h3>


<pre class="code">
namespace endian {
enum endianness
{
    unknown = 0,
    little  = 1234,
    big     = 4321,
    pdp     = 3412,
    native  = <span class="nonterminal">&lt;one-of-the-above&gt;</span>
};
} // namespace

using endian::endianness;
</pre>

<p>Константы, соответсвующие различным порядкам байт. <tt>endian::native</tt>
принимает значение одной из констант, в зависимости от текущей платформы
(подобно макросу <tt>__BYTE_ORDER__</tt> в UNIX-подобных системах).
Предполагается использование данных констант для специализации шаблонов или
проверках времени компиляции (например с использованием <tt>static_assert</tt>).
</p>

<div class="section">Примеры</div>
<pre class="code">
template&lt;__vic::endianness &gt; struct some_algo; // not implemented

// Реализация для little-endian
template&lt;&gt; struct some_algo&lt;__vic::endian::little&gt;
{
    static void doit() { ... }
};
// Реализация для big-endian
template&lt;&gt; struct some_algo&lt;__vic::endian::big&gt;
{
    static void doit() { ... }
};

// Автоматически выбрать подходящую для используемой платформы реализацию
some_algo&lt;__vic::endian::native&gt;::doit();
</pre>

<pre class="code">
static_assert(__vic::endian::native == __vic::endian:little,
    "Litte-endian is expected");
</pre>





<h3 id="endian--from">
<span class="h3_num">2.11.2</span><tt>endian::from_...()</tt>
</h3>


<pre class="code">
template&lt;class T&gt; [[nodiscard]] constexpr T endian::from_little(T v);
template&lt;class T&gt; [[nodiscard]] constexpr T endian::from_big(T v);
</pre>

<p>Возвращают значение, представленное в порядке байт, используемом платформой,
преобразованное из litte/big endian, если необходимо.</p>

<p><tt>T</tt> может быть любым интегральным типом или enum размера не более,
чем <tt>sizeof(long long)</tt>.</p>

<div class="section">Пример</div>
<pre class="code">
uint16_t v;
read_bytes(&amp;v, 2); // serialized as big endian
std::cout &lt;&lt; "The value is " &lt;&lt; __vic::endian::from_big(v) &lt;&lt; '\n';
</pre>





<h3 id="endian--to">
<span class="h3_num">2.11.3</span><tt>endian::to_...()</tt>
</h3>


<pre class="code">
template&lt;class T&gt; [[nodiscard]] constexpr T endian::to_little(T v);
template&lt;class T&gt; [[nodiscard]] constexpr T endian::to_big(T v);
</pre>

<p>Возвращают значение, представленное в litte/big endian.</p>

<p><tt>T</tt> может быть любым интегральным типом или enum размера не более,
чем <tt>sizeof(long long)</tt>.</p>

<div class="section">Пример</div>
<pre class="code">
uint16_t v = __vic::endian::to_big(...);
write_bytes(&amp;v, 2); // serialize as big endian
</pre>





<h3 id="swab">
<span class="h3_num">2.11.4</span><tt>swab16()</tt>, <tt>swab32()</tt>, <tt>swab64()</tt>
</h3>


<pre class="code">
[[nodiscard]] constexpr uint16_t swab16(uint16_t v);
[[nodiscard]] constexpr uint32_t swab32(uint32_t v);
[[nodiscard]] constexpr uint64_t swab64(uint64_t v);
</pre>

<p>Быстрые утилиты для обращения порядка байт (обычно реализуются с помощью
специфичных для компилятора intrinsics).</p>

<div class="section">Пример</div>
<pre class="code">
static_assert(__vic::swab32(0x01020304) == 0x04030201);
</pre>







<h2 id="error.h">
<span class="h2_num">2.12</span><tt>__vic/error.h</tt>
</h2>


<p>Инструменты обработки ошибок.</p>


<h3 id="exception">
<span class="h3_num">2.12.1</span><tt>exception</tt>
</h3>


<pre class="code">
class exception : public std::exception
{
public:
    exception();
    explicit exception(const char *message);
    const char *what() const noexcept;
protected:
    void set_message(const char *message);
};
</pre>

<p>Небольшое расширение <tt>std::exception</tt> - объект хранит сообщение об
ошибке, переданное в конструкторе, которое потом возвращает <tt>what()</tt>.
Может быть использован как базовый или конкретный класс исключения. Не
использует и не зависит от <tt>std::string</tt>, в отличие от
<tt>std::logic_error</tt> и <tt>std::runtime_error</tt>. Также Вам нет нужды
решать, какое из последних следует использовать в каждом конкретном случае.</p>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">exception()</pre>
<blockquote>

<p>Создаёт объект с пустым сообщением об ошибке.</p>
</blockquote>
</div>

<div>
<pre class="prototype">explicit exception(const char *message)</pre>
<blockquote>

<p>Создаёт объект с указанным сообщением об ошибке.</p>
</blockquote>
</div>

<div>
<pre class="prototype">const char *what() const noexcept</pre>
<blockquote>

<p>Возвращает установленное ранее сообщение.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void set_message(const char *message)</pre>
<blockquote>

<p>Устанавливает новое сообщение.</p>
</blockquote>
</div>



<div class="section">Пример</div>
<pre class="code">
struct custom_exception : public __vic::exception
{
    explicit custom_exception(const char *msg) : __vic::exception(msg) {}
};

throw custom_exception("Error condition description");
</pre>





<h3 id="libc_error">
<span class="h3_num">2.12.2</span><tt>libc_error</tt>
</h3>


<pre class="code">
class libc_error : public std::exception
{
public:
    explicit libc_error(int err_no = errno);
    explicit libc_error(const char *prompt, int err_no = errno);

    const char *what() const noexcept;
    int code() const;
    int get_errno() const;
};
</pre>

<p>Класс предназначен для замены стандартного механизма обработки ошибок
в мире C - <tt>errno</tt> - на механизм исключений. Также класс пригоден для
использования в многопоточных приложениях вместо не всегда реентерабельного
вызова <tt>std::strerror()</tt>.</p>
<p>Ниже приведён фрагмент кода, типичный для языка C:</p>

<pre class="code">
// C:

int fd;
if((fd = open("qqqq", O_RDONLY)) == -1)
{
    perror("open");
    if(errno == ENOENT) exit(1);
}
</pre>

<p>Если файл не найден, программа напечатает</p>
<pre class="code">
open: No such file or directory
</pre>
<p>в <tt>stderr</tt> и выйдет, вернув в ОС значение <tt>1</tt>.</p>

<p>Какие проблемы присущи этому коду? Во-первых, не у каждой программы есть
<tt>stderr</tt>, поэтому библиотечная функция не может сама выводить туда
сообщения об ошибках. Во-вторых, значение глобальной переменной <tt>errno</tt>
может быть затёрто любым следующим вызовом, если его не сохранить. В-третьих,
решение о завершении процесса должна принимать конечная программа. Обычная
библиотечная функция не может брать на себя такие полномочия. В-четвёртых,
в общем случае программа на С++ не может вызывать <tt>std::exit()</tt>, так
как не будут вызваны деструкторы активных объектов, что может разрушить логику
работы программы.</p>

<p>Ниже приведён адаптированный пример для C++ с использованием описываемого
класса:</p>

<pre class="code">
// C++:

try
{
    int fd = open("qqqq", O_RDONLY);
    if(fd == -1) throw __vic::libc_error("open");
    // or just
    // if(fd == -1) throw __vic::libc_error();
}
catch(const __vic::libc_error &amp;ex)
{
    std::cerr &lt;&lt; ex.what() &lt;&lt; '\n';
    if(ex.code() == ENOENT) return 1;
}
</pre>

<p>Как видно, функция просто корректно отслеживает ошибочную ситуацию и
сообщает о ней вызывающей среде. Далее вызывающая сторона уже сама может
принять решение об обработке ошибки. В простейшем случае она поступает также
как предыдущая C-программа: печатает сообщение в стандартный поток вывода
ошибок и завершает выполнение. Кроме того, код ошибки надёжно сохранён в
исключении и ни кем не перетрётся.</p>

<div>
<u><b>Замечание</b></u>: Обычно исключения данного класса не должны бросаться явно! Используйте
<a href="#throw_errno"><tt>throw_errno()</tt></a> для их генерации.</div>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">explicit libc_error(int err_no = errno)</pre>
<blockquote>

<p><tt>err_no</tt> - код ошибки.</p>
<div>
<u>Постусловие</u>: <tt>code() == err_no</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">explicit libc_error(const char *prompt, int err_no = errno)</pre>
<blockquote>

<p><tt>prompt</tt> - заголовок выводимого сообщения. Параметр имеет такой же
смысл, как и параметр <tt>std::perror()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">const char *what() const noexcept</pre>
<blockquote>

<p>Возвращает описание ошибки в формате <tt>std::perror()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">int code() const</pre>
<pre class="prototype">int get_errno() const</pre>
<blockquote>


<p>Возвращает хранимый код ошибки.</p>
</blockquote>
</div>








<h2 id="fs.h">
<span class="h2_num">2.13</span><tt>__vic/fs.h</tt>
</h2>


<p>Утилиты для работы с файловой системой.</p>

<div>
<u><b>Замечание</b></u>: Для всех путей ожидается использование кодировки UTF-8!</div>


<h3 id="path_exists">
<span class="h3_num">2.13.1</span><tt>path_exists()</tt>, <tt>file_exists()</tt>, <tt>dir_exists()</tt>
</h3>


<pre class="code">
bool path_exists(const char *path);
bool path_exists(const std::string &amp;path);

bool file_exists(const char *path);
bool file_exists(const std::string &amp;path);

bool dir_exists(const char *path);
bool dir_exists(const std::string &amp;path);
</pre>

<p><tt>path_exists()</tt> проверяет, существует ли путь в фаловой системе.
Вторая и третья функции дополнительно, кроме существования, проверяют,
ссылается ли путь на регулярный файл или на каталог, соответсвенно.</p>




<h3 id="mkdir">
<span class="h3_num">2.13.2</span><tt>mkdir()</tt>, <tt>mkdir_if_absent()</tt>
</h3>


<pre class="code">
void mkdir(const char *path, mode_t mode = 0777);
void mkdir(const std::string &amp;path, mode_t mode = 0777);

bool mkdir_if_absent(const char *path, mode_t mode = 0777);
bool mkdir_if_absent(const std::string &amp;path, mode_t mode = 0777);
</pre>

<p>Создаёт каталог. Бросает исключения в случае ошибок.
<tt>mkdir_if_absent()</tt> возвращает <tt>false</tt> вместо исключения, если
каталог с таким именем уже существует.</p>




<h3 id="rmdir">
<span class="h3_num">2.13.3</span><tt>rmdir()</tt>, <tt>rmdir_if_exists()</tt>
</h3>


<pre class="code">
void rmdir(const char *path);
void rmdir(const std::string &amp;path);

bool rmdir_if_exists(const char *path);
bool rmdir_if_exists(const std::string &amp;path);
</pre>

<p>Удаляет пустой каталог. Бросает исключения в случае ошибок.
<tt>rmdir_if_exists()</tt> возвращает <tt>false</tt> вместо исключения, если
каталога с таким именем не существует.</p>




<h3 id="get_current_dir">
<span class="h3_num">2.13.4</span><tt>get_current_dir()</tt>
</h3>


<pre class="code">
std::string get_current_dir();
</pre>

<p>Возвращает текущий рабочий каталог.</p>




<h3 id="remove_file">
<span class="h3_num">2.13.5</span><tt>remove_file()</tt>, <tt>remove_file_if_exists()</tt>,
<tt>remove_file_nt()</tt>
</h3>


<pre class="code">
void remove_file(const char *path);
void remove_file(const std::string &amp;path);

bool remove_file_if_exists(const char *path);
bool remove_file_if_exists(const std::string &amp;path);

bool remove_file_nt(const char *path) noexcept;
bool remove_file_nt(const std::string &amp;path) noexcept;
</pre>

<p>Удаляет файл. Бросает исключения в случае ошибок.</p>

<p><tt>remove_file_if_exists()</tt> возвращает <tt>false</tt> вместо
исключения, если файл с таким именем не существует.</p>

<p><tt>remove_file_nt()</tt> вообще не бросает исключений, а возвращает
<tt>false</tt> в случае ошибок.</p>




<h3 id="copy_file">
<span class="h3_num">2.13.6</span><tt>copy_file()</tt>, <tt>copy_file_if_exists()</tt>,
<tt>copy_file_replace()</tt>, <tt>copy_file_replace_if_exists()</tt>
</h3>


<pre class="code">
void copy_file(
    const char *src_path, const char *dest_path, bool replace = false);
void copy_file(
    const std::string &amp;src_path, const std::string &amp;dest_path,
    bool replace = false);

bool copy_file_if_exists(
    const char *src_path, const char *dest_path, bool replace = false);
bool copy_file_if_exists(
    const std::string &amp;src_path, const std::string &amp;dest_path,
    bool replace = false);

void copy_file_replace(
    const char *src_path, const char *dest_path);
void copy_file_replace(
    const std::string &amp;src_path, const std::string &amp;dest_path);

bool copy_file_replace_if_exists(
    const char *src_path, const char *dest_path);
bool copy_file_replace_if_exists(
    const std::string &amp;src_path, const std::string &amp;dest_path);
</pre>

<p>Создаёт новый файл <tt>dest_path</tt>, являющийся копией файла
<tt>src_path</tt>. Вызов заканчивается ошибкой, если новый файл существует и
<tt>replace == false</tt>.</p>

<p><tt>copy_file_if_exists()</tt> возвращает <tt>false</tt> вместо исключения,
если файла с именем <tt>src_path</tt> не существует.</p>

<p><tt>copy_file_replace()</tt> - то же самое, что <tt>copy_file(..., true)</tt>.
</p>

<p><tt>copy_file_replace_if_exists()</tt> - то же самое, что
<tt>copy_file_if_exists(..., true)</tt>.</p>




<h3 id="move_file">
<span class="h3_num">2.13.7</span><tt>move_file()</tt>, <tt>move_file_if_exists()</tt>,
<tt>move_file_replace()</tt>, <tt>move_file_replace_if_exists()</tt>
</h3>


<pre class="code">
void move_file(const char *src_path, const char *dest_path);
void move_file(const std::string &amp;src_path, const std::string &amp;dest_path);

bool move_file_if_exists(const char *src_path, const char *dest_path);
bool move_file_if_exists(
    const std::string &amp;src_path, const std::string &amp;dest_path);

void move_file_replace(const char *src_path, const char *dest_path);
void move_file_replace(
    const std::string &amp;src_path, const std::string &amp;dest_path);

bool move_file_replace_if_exists(
    const char *src_path, const char *dest_path);
bool move_file_replace_if_exists(
    const std::string &amp;src_path, const std::string &amp;dest_path);
</pre>

<p>Перемещает файл <tt>src_path</tt> в новое место, указанное в
<tt>dest_path</tt>.</p>

<p>Функции с суффиксом <tt>_replace</tt> перетирают целевой файл, если он
существует, остальные - возвращают ошибку в таком случае.</p>

<p><tt>move_file_if_exists()</tt> возвращает <tt>false</tt> вместо ошибки,
если файл с именем <tt>src_path</tt> не существует.</p>




<h3 id="rename_file">
<span class="h3_num">2.13.8</span><tt>rename_file()</tt>, <tt>rename_file_if_exists()</tt>,
    <tt>rename_file_replace()</tt>, <tt>rename_file_replace_if_exists()</tt>
</h3>


<pre class="code">
void rename_file(const char *src_name, const char *dest_name);
void rename_file(const std::string &amp;src_name, const std::string &amp;dest_name);

bool rename_file_if_exists(const char *src_name, const char *dest_name);
bool rename_file_if_exists(
    const std::string &amp;src_name, const std::string &amp;dest_name);

void rename_file_replace(const char *src_name, const char *dest_name);
void rename_file_replace(
    const std::string &amp;src_name, const std::string &amp;dest_name);

bool rename_file_replace_if_exists(
    const char *src_name, const char *dest_name);
bool rename_file_replace_if_exists(
    const std::string &amp;src_name, const std::string &amp;dest_name);
</pre>

<p>Переименовывает файл <tt>src_path</tt> в <tt>dest_path</tt>. Новый путь
должен находиться на той же самой физической файловой системе.</p>

<p>В отличие от <tt>std::rename()</tt>, вызов функций без суффикса
<tt>_replace</tt> заканчивается ошибкой, если файл с именем <tt>dest_path</tt>
уже существует.</p>

<p><tt>rename_file_if_exists()</tt> возвращает <tt>false</tt> вместо
исключения, если файла с именем <tt>src_path</tt> не существует.</p>




<h3 id="file_size">
<span class="h3_num">2.13.9</span><tt>file_size()</tt>
</h3>


<pre class="code">
uintmax_t file_size(const char *path);
uintmax_t file_size(const std::string &amp;path);
</pre>

<p>Возвращает размер файла в байтах.</p>






<h2 id="iterator.h">
<span class="h2_num">2.14</span><tt>__vic/iterator.h</tt>
</h2>


<p>Инструменты работы с итераторами.</p>


<h3 id="begin-array">
<span class="h3_num">2.14.1</span><tt>begin(T[])</tt>, <tt>end(T[])</tt>, <tt>cbegin(T[])</tt>,
<tt>cend(T[])</tt>
</h3>


<pre class="code">
template&lt;class T, size_t N&gt; constexpr T *begin(T (&amp;arr)[N]);
template&lt;class T, size_t N&gt; constexpr T *end(T (&amp;arr)[N]);

template&lt;class T, size_t N&gt; constexpr const T *cbegin(T (&amp;arr)[N]);
template&lt;class T, size_t N&gt; constexpr const T *cend(T (&amp;arr)[N]);
</pre>

<p>Возвращают указатели на начало и за конец массива.</p>

<div class="section">Пример</div>
<pre class="code">
int vals[] = { 1, 2, 3 };
std::list&lt;int&gt; lst(__vic::begin(vals), __vic::end(vals));
assert(lst.size() == 3);
</pre>





<h3 id="advance">
<span class="h3_num">2.14.2</span><tt>advance()</tt>
</h3>


<pre class="code">
template&lt;class Iter&gt;
void advance(Iter &amp;it, Iter end, size_t n);
</pre>

<p>Функция похожа на <tt>std::advance()</tt>, но отличается по формату вызова
и поведению. Главные отличия:</p>
<ol>
<li>Позволяет двигаться только вперёд (<tt>++</tt>),</li>
<li>Контролирует выход за границу диапазона. Прекращает работу, если
        достигнут <tt>end</tt>.</li>
</ol>




<h3 id="next">
<span class="h3_num">2.14.3</span><tt>next()</tt>, <tt>prev()</tt>
</h3>


<pre class="code">
template&lt;class ForwardIterator&gt;
ForwardIterator next(ForwardIterator it);

template&lt;class ForwardIterator&gt;
ForwardIterator next(ForwardIterator it, size_t n);

template&lt;class BidirectionalIterator&gt;
BidirectionalIterator prev(BidirectionalIterator it);

template&lt;class BidirectionalIterator&gt;
BidirectionalIterator prev(BidirectionalIterator it, size_t n);
</pre>

<p><tt>next()</tt> возвращает значение итератора, передвинутое вперёд на
<tt>n</tt> позиций. <tt>prev()</tt> делает то же самое, но в противоположную
сторону. В отличие от одноимённых функций из STL C++11, смещение не может быть
отрицательным. Версии с одним параметром просто вызывают
<tt>++it</tt>/<tt>--it</tt> и возвращают результат.</p>

<div class="section">Пример</div>
<pre class="code">
template&lt;class Container&gt;
void f(const Container &amp;c)
{
    // Начать обход со второго элемента
    // v.begin() + 1 работает только для RandomAccessIterator
    // ++v.begin() может вообще не скомпилироваться
    for(auto it = __vic::next(c.begin()); it != c.end(); ++it) ...;
}
</pre>







<h2 id="logger.h">
<span class="h2_num">2.15</span><tt>__vic/logger.h</tt>
</h2>


<h3 id="logger">
<span class="h3_num">2.15.1</span><tt>logger</tt>
</h3>


<pre class="code">
class logger : private non_copyable
{
public:
    enum class severity : unsigned char
    {
        trace,
        debug,
        info,
        notice,
        warning,
        error,
        fatal
    };
    using severity_t = severity; // use this alias as a type name
    struct output
    {
        virtual void publish_record(severity_t , const char * , size_t ) = 0;
    protected:
        ~output() = default;
    };
    class settings_t
    {
        struct output &amp;output() const;
        severity_t level() const;
    };
    class record;

    explicit logger(output &amp;out, severity_t = severity::info);
    explicit logger(settings_t s);
    ~logger();

    severity_t level() const;
    void level(severity_t new_level);
    settings_t settings() const;
    output &amp;reset_output(output &amp;out);
    output &amp;get_output();
    const output &amp;get_output() const;

    static constexpr size_t min_buffer_size = ...;
    void shrink_buffer(size_t limit);

    void message(severity_t severity, const char *msg, size_t msg_len);
#if __cpp_lib_string_view // C++17
    void message(severity_t severity, std::string_view msg);

    void trace(std::string_view msg);
    void debug(std::string_view msg);
    void info(std::string_view msg);
    void notice(std::string_view msg);
    void warning(std::string_view msg);
    void error(std::string_view msg);
    void fatal(std::string_view msg);
#else // until C++17
    void message(severity_t severity, const char *msg);
    void message(severity_t severity, const std::string &amp;msg);

    void trace(const char *msg);
    void debug(const char *msg);
    void info(const char *msg);
    void notice(const char *msg);
    void warning(const char *msg);
    void error(const char *msg);
    void fatal(const char *msg);

    void trace(const std::string &amp;msg);
    void debug(const std::string &amp;msg);
    void info(const std::string &amp;msg);
    void notice(const std::string &amp;msg);
    void warning(const std::string &amp;msg);
    void error(const std::string &amp;msg);
    void fatal(const std::string &amp;msg);
#endif

#if __cpp_lib_format &gt;= 202106L // C++20 + P2508
    template&lt;class... Args&gt;
    void format(severity_t s,
        std::format_string&lt;Args...&gt; fmt, Args&amp;&amp;... args);

    template&lt;class Arg1, class... Args&gt;
    void trace(std::format_string&lt;Arg1,Args...&gt; fmt,
                                        Arg1 &amp;&amp;arg1, Args&amp;&amp;... args);
    template&lt;class Arg1, class... Args&gt;
    void debug(std::format_string&lt;Arg1,Args...&gt; fmt,
                                        Arg1 &amp;&amp;arg1, Args&amp;&amp;... args);
    template&lt;class Arg1, class... Args&gt;
    void info(std::format_string&lt;Arg1,Args...&gt; fmt,
                                        Arg1 &amp;&amp;arg1, Args&amp;&amp;... args);
    template&lt;class Arg1, class... Args&gt;
    void notice(std::format_string&lt;Arg1,Args...&gt; fmt,
                                        Arg1 &amp;&amp;arg1, Args&amp;&amp;... args);
    template&lt;class Arg1, class... Args&gt;
    void warning(std::format_string&lt;Arg1,Args...&gt; fmt,
                                        Arg1 &amp;&amp;arg1, Args&amp;&amp;... args);
    template&lt;class Arg1, class... Args&gt;
    void error(std::format_string&lt;Arg1,Args...&gt; fmt,
                                        Arg1 &amp;&amp;arg1, Args&amp;&amp;... args);
    template&lt;class Arg1, class... Args&gt;
    void fatal(std::format_string&lt;Arg1,Args...&gt; fmt,
                                        Arg1 &amp;&amp;arg1, Args&amp;&amp;... args);
#endif

    record trace();
    record debug();
    record info();
    record notice();
    record warning();
    record error();
    record fatal();

    bool trace_visible() const;
    bool debug_visible() const;
    bool info_visible() const;
    bool notice_visible() const;
    bool warning_visible() const;
    bool error_visible() const;
    bool fatal_visible() const;
};
class logger::record
{
public:
    record(logger &amp;log, severity_t sev);
    ~record();

    record append(const char *str, size_t str_len);

    template&lt;class T&gt; record operator&lt;&lt;(const T &amp;v);
};
template&lt;class T&gt; struct log_value
{
    static void to_text(const T &amp;v, std::string &amp;s);
};
const char *to_string(logger::severity_t s);
#if __cpp_lib_string_view // C++17
constexpr std::string_view to_string_view(logger::severity s);
#endif
</pre>

<p>Front-end логгера. Реализует построение записей с помощью оператора
<tt>&lt;&lt;</tt>, подобно стандартной библиотеке потоков <tt>iostream</tt>.
Каждая запись лога имеет назначенный приоритет. Логгер может фильтровать вывод
записей по этому приоритету. Предопределены 6 уровней приоритета (в порядке
возрастания):</p>
<ol>
<li>TRACE - подробная отладка,</li>
<li>DEBUG - отладка,</li>
<li>INFO - информационное сообщение,</li>
<li>NOTICE - нормальное, но важное событие,</li>
<li>WARNING - незначительная ошибка или подозрительная ситуация,</li>
<li>ERROR - серьёзная ошибка, но приложение может продолжать
        работу,</li>
<li>FATAL - критическая ошибка, приложение не может продолжить
        выполнение.</li>
</ol>

<p>INFO является уровнем логирования по умолчанию. Если сообщение (запись)
имеет приоритет ниже текущего уровня логирования, то оно игнорируется и никуда
не выводится.</p>

<p>Для создания сообщений с нужным приоритетом предоставляется набор одноимённых
функций. Например, <tt>info()</tt> для сообщений INFO. Также есть универсальная
функция <tt>message()</tt>, в которой приоритет задаётся параметром, но, обычно,
следует использовать специфичные функции.</p>

<p>Существует 2 способа создания сообщений. Первый прост и обычен:</p>
<pre class="code">
log.trace("Trace message");
log.debug("Debug message");
log.info("Info message");
log.notice("Notice");
log.warning("Warning");
log.error("Recoverable error");
log.fatal("Fatal error");
</pre>

<p>Второй немного более сложен, но предоставляет гораздо большие возможности:</p>
<pre class="code">
log.error() &lt;&lt; "Cannot open file " &lt;&lt; filename &lt;&lt; '!';
log.warning() &lt;&lt; "Loop iteration no " &lt;&lt; i;
</pre>

<p>Вызов функции без параметров создаёт объект типа <tt>logger::record</tt> с
соответствующим приоритетом. Теперь в него можно писать сообщение с
использованием оператора <tt>&lt;&lt;</tt>. Сформированная запись будет
выведена в лог по завершении вычисления «полного выражения» (термин из
Стандарта)</p>

<p>Если сформировать запись лога сложно или невозможно одним выражением, то
следует явно создать объект <tt>logger::record</tt> и писать в него. Запись
будет выведена с лог при вызове деструктора данного объекта:</p>
<pre class="code">
{
    logger::record rec = log.info(); // Начало формирования записи
    rec &lt;&lt; "List elements: ";
    for(auto el : list) rec &lt;&lt; el &lt;&lt; ", ";
    // Сформированная запись попадёт в лог при выходе из блока
}
</pre>

<div>
<u><b>Замечание</b></u>: В целях повышения эффективности используйте обычную функциональную запись,
если строка уже готова для вывода:</div>
<pre class="code">
log.info("Message");
// а не
log.info() &lt;&lt; "Message";
</pre>

<p>Вывод записей с приоритетами DEBUG и TRACE обычно отключен в нормальных
условиях. Такие записи хоть и не попадут в лог, но время на их форматирование
всё равно будет тратиться. Поэтому перед попыткой сформировать какую-нибудь
отладочную запись с помощью операторов <tt>&lt;&lt;</tt> проверьте, включена ли
отладка, с помощью вызова <tt>debug_visible()</tt> или <tt>trace_visible()</tt>:
</p>
<pre class="code">
if(log.debug_visible())
    log.debug() &lt;&lt; ...; // формируем запись
</pre>
<p>Это не относится к обычным вызовам <tt>debug(msg)</tt> и <tt>trace(msg)</tt>,
которым передаётся уже готовая к выводу строка, и никакого дополнительного
форматирования не требуется.</p>

<p>Для использования <tt>logger</tt> нужно реализовать абстрактный базовый класс
<tt>logger::output</tt> (определить <tt>publish_record()</tt>). Реализация
должна вывести куда-то сформированную запись, например, в файл или БД.
<tt>output</tt>, переданный в <tt>logger</tt> при конструировании, впоследствии
можно заменить с помощью вызова <tt>reset_output()</tt>.</p>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">severity::trace</pre>
<pre class="prototype">severity::debug</pre>
<pre class="prototype">severity::info</pre>
<pre class="prototype">severity::notice</pre>
<pre class="prototype">severity::warning</pre>
<pre class="prototype">severity::error</pre>
<pre class="prototype">severity::fatal</pre>
<blockquote>







<p>Константы приоритетов и уровней логирования. Данная форма используется как в
режиме C++11, так и в C++98.</p>
</blockquote>
</div>

<div>
<pre class="prototype">typename severity_t</pre>
<blockquote>

<p>Используйте данный идентификатор, если коду требуется совместимость с режимом
C++98. Начиная с C++11 это просто синоним <tt>severity</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">class output</pre>
<blockquote>

<p>Интерфейс back-end'а логирования.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void output::publish_record(severity_t sev, const char *buf, size_t buf_len)</pre>
<blockquote>

<p>Реализация этой чисто виртуальной функции должна вывести содержимое
<tt>buf</tt> длиной <tt>buf_len</tt> в лог как одну запись. Функция вызывается
только когда переданный <tt>sev &gt;= level()</tt>. Реализация может полагаться на
это предусловие.</p>
</blockquote>
</div>

<div>
<pre class="prototype">class settings_t</pre>
<blockquote>

<p>Хранит настройки логгера: уровень логирования и ссылку на вывод
(<tt>level()</tt> + <tt>get_output()</tt>).</p>
</blockquote>
</div>

<div>
<pre class="prototype">explicit logger(output &amp;out, severity_t level = severity::info)</pre>
<blockquote>

<p>Создаёт логгер с данным выводом и уровнем логирования. Время жизни объекта,
на который ссылается <tt>out</tt>, должно превосходить время жизни логгера!</p>
<div>
<u>Постусловие</u>: <tt>this-&gt;level() == level &amp;&amp; &amp;this-&gt;get_output() == &amp;out</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">explicit logger(settings_t s)</pre>
<blockquote>

<p>Создаёт логгер с указанными настройками.</p>
</blockquote>
</div>

<div>
<pre class="prototype">severity_t level() const</pre>
<blockquote>

<p>Возвращает текущий уровень логирования.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void level(severity_t new_level)</pre>
<blockquote>

<p>Устанавливает уровень логирования.</p>
<div>
<u>Постусловие</u>: <tt>level() == new_level</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">settings_t settings() const</pre>
<blockquote>

<p>Возвращает текущие настройки.</p>
</blockquote>
</div>

<div>
<pre class="prototype">output &amp;reset_output(output &amp;out)</pre>
<blockquote>

<p>Устанавливает новый вывод и возвращает старый.</p>
<div>
<u>Постусловие</u>: <tt>&amp;get_output() == &amp;out</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">output &amp;get_output()</pre>
<pre class="prototype">const output &amp;get_output() const</pre>
<blockquote>


<p>Возвращает ссылку на текущий вывод.</p>
</blockquote>
</div>

<div>
<pre class="prototype">static constexpr size_t min_buffer_size</pre>
<blockquote>

<p>Минимальный размер внутреннего буфера в байтах.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void shrink_buffer(size_t limit)</pre>
<blockquote>

<p>Устанавливает размер внутреннего буфера в <tt>min_buffer_size</tt>, если он
превосходит <tt>limit</tt> байтов. Позволяет предотвратить бесконрольное
разрастание используемой памяти при выводе записей большого размера.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void message(severity_t severity, const char *msg, size_t msg_len)</pre>
<pre class="prototype">void message(severity_t severity, std::string_view msg) <span class="sign">[C++17]</span></pre>
<pre class="prototype">void message(severity_t severity, const char *msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void message(severity_t severity, const std::string &amp;msg) <span class="sign">[until C++17]</span></pre>
<blockquote>




<p>Выводит сообщение с заданным приоритетом.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void trace(std::string_view msg) <span class="sign">[C++17]</span></pre>
<pre class="prototype">void trace(const char *msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void trace(const std::string &amp;msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void debug(std::string_view msg) <span class="sign">[C++17]</span></pre>
<pre class="prototype">void debug(const char *msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void debug(const std::string &amp;msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void info(std::string_view msg) <span class="sign">[C++17]</span></pre>
<pre class="prototype">void info(const char *msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void info(const std::string &amp;msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void notice(std::string_view msg) <span class="sign">[C++17]</span></pre>
<pre class="prototype">void notice(const char *msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void notice(const std::string &amp;msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void warning(std::string_view msg) <span class="sign">[C++17]</span></pre>
<pre class="prototype">void warning(const char *msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void warning(const std::string &amp;msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void error(std::string_view msg) <span class="sign">[C++17]</span></pre>
<pre class="prototype">void error(const char *msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void error(const std::string &amp;msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void fatal(std::string_view msg) <span class="sign">[C++17]</span></pre>
<pre class="prototype">void fatal(const char *msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void fatal(const std::string &amp;msg) <span class="sign">[until C++17]</span></pre>
<blockquote>





















<p>Выводит сообщение с соответствующим приоритетом.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class... Args&gt;
void format(severity_t s,
    std::format_string&lt;Args...&gt; fmt, Args&amp;&amp;... args) <span class="sign">[C++20]</span></pre>
<blockquote>

<p>Форматирует сообщение используя указанную строку формата и аргументы
(подобно <tt>std::format</tt>), затем выводит его с заданным приоритетом.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class Arg1, class... Args&gt;
void trace(std::format_string&lt;Arg1,Args...&gt; fmt, Arg1 &amp;&amp;arg1, Args&amp;&amp;... args) <span class="sign">[C++20]</span></pre>
<pre class="prototype">template&lt;class Arg1, class... Args&gt;
void debug(std::format_string&lt;Arg1,Args...&gt; fmt, Arg1 &amp;&amp;arg1, Args&amp;&amp;... args) <span class="sign">[C++20]</span></pre>
<pre class="prototype">template&lt;class Arg1, class... Args&gt;
void info(std::format_string&lt;Arg1,Args...&gt; fmt, Arg1 &amp;&amp;arg1, Args&amp;&amp;... args) <span class="sign">[C++20]</span></pre>
<pre class="prototype">template&lt;class Arg1, class... Args&gt;
void notice(std::format_string&lt;Arg1,Args...&gt; fmt, Arg1 &amp;&amp;arg1, Args&amp;&amp;... args) <span class="sign">[C++20]</span></pre>
<pre class="prototype">template&lt;class Arg1, class... Args&gt;
void warning(std::format_string&lt;Arg1,Args...&gt; fmt, Arg1 &amp;&amp;arg1, Args&amp;&amp;... args) <span class="sign">[C++20]</span></pre>
<pre class="prototype">template&lt;class Arg1, class... Args&gt;
void error(std::format_string&lt;Arg1,Args...&gt; fmt, Arg1 &amp;&amp;arg1, Args&amp;&amp;... args) <span class="sign">[C++20]</span></pre>
<pre class="prototype">template&lt;class Arg1, class... Args&gt;
void fatal(std::format_string&lt;Arg1,Args...&gt; fmt, Arg1 &amp;&amp;arg1, Args&amp;&amp;... args) <span class="sign">[C++20]</span></pre>
<blockquote>







<p>Форматирует сообщение используя указанную строку формата и аргументы
(подобно <tt>std::format</tt>), затем выводит его с соответствующим
приоритетом.</p>
</blockquote>
</div>

<div>
<pre class="prototype">logger::record trace()</pre>
<pre class="prototype">logger::record debug()</pre>
<pre class="prototype">logger::record info()</pre>
<pre class="prototype">logger::record notice()</pre>
<pre class="prototype">logger::record warning()</pre>
<pre class="prototype">logger::record error()</pre>
<pre class="prototype">logger::record fatal()</pre>
<blockquote>







<p>Создаёт новую запись c соответствующим приоритетом и позволяет писать в неё
части сообщения с помощью оператора <tt>&lt;&lt;</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool trace_visible() const</pre>
<pre class="prototype">bool debug_visible() const</pre>
<pre class="prototype">bool info_visible() const</pre>
<pre class="prototype">bool notice_visible() const</pre>
<pre class="prototype">bool warning_visible() const</pre>
<pre class="prototype">bool error_visible() const</pre>
<pre class="prototype">bool fatal_visible() const</pre>
<blockquote>







<p>Возвращает <tt>true</tt>, если запись с указанным уровнем логирования будет
выведена в лог при текущих настройках. Использование данных функций позволяет
исключить форматирование сообщений, которые всё равно не попадут в лог.</p>
</blockquote>
</div>

<div>
<pre class="prototype">record::record(logger &amp;log, severity_t sev)</pre>
<blockquote>

<p>Создаёт запись лога с указанным приоритетом. Обычно вместо явного вызова
данного конструктора следует использовать функции <tt>logger</tt>’а, вроде
<tt>info()</tt> без параметров, для создания объекта.</p>
</blockquote>
</div>

<div>
<pre class="prototype">record::~record()</pre>
<blockquote>

<p>Выводит сформированную запись в лог.</p>
</blockquote>
</div>

<div>
<pre class="prototype">record record::append(const char *str, size_t str_len)</pre>
<blockquote>

<p>Добавляет строку к сообщению.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class T&gt; record record::operator&lt;&lt;(const T &amp;v)</pre>
<blockquote>

<p>Набор инсертеров для различных типов данных. Указанное значение преобразуется
в текст с использованием вызова <tt>log_value&lt;T&gt;::to_text()</tt>.</p>
</blockquote>
</div>



<div class="section">Преобразователи значений в текст</div>

<div>
<pre class="prototype">template&lt;class T&gt; void log_value&lt;T&gt;::to_text(const T &amp;v, std::string &amp;s)</pre>
<blockquote>

<p>Преобразует значение типа <tt>T</tt> в текст, используя unqualified вызов
<a href="#to_text_append"><tt>to_text_append()</tt></a>.</p>
<div>
<u>Замечание</u>: Данная функция (точнее класс со статической функцией) может быть
спецализирована для Вашего <tt>T</tt>. Однако, обычно, Вам следует просто
определить <tt>to_text_append(const T &amp;, std::string &amp;)</tt>.</div>
</blockquote>
</div>



<div class="section">Свободные функции</div>

<div>
<pre class="prototype">const char *to_string(logger::severity_t s)</pre>
<pre class="prototype">constexpr std::string_view to_string_view(logger::severity s) <span class="sign">[C++17]</span></pre>
<blockquote>


<p>Преобразует приоритет записи лога в текстовое представление, которое можно,
например, вывести в лог. Пример: для <tt>severity::debug</tt> возвращается
"<tt>DEBUG</tt>" и т.п.</p>
</blockquote>
</div>



<div class="section">Пример</div>

<pre class="code">
/////////////////////////////////////////////////////////////////////////////
// Вывод сообщений в std::clog с указанием приоритета
class coutput : public __vic::logger::output
{
public:
    void publish_record(__vic::logger::severity_t s,
                            const char *rec, size_t rec_n)
    {
        std::clog &lt;&lt; to_string(s) &lt;&lt; ": ";
        std::clog.write(rec, rec_n) &lt;&lt; std::endl;
    }
};
/////////////////////////////////////////////////////////////////////////////

int main()
{
    coutput log_output:
    __vic::logger log(log_output, __vic::logger::severity::debug);

    log.info("Application is started");

    for(int i = 0; i &lt; 5; i++)
        log.debug() &lt;&lt; "Loop i = " &lt;&lt; i;

    log.warning("Application end");
}
</pre>

<p>Результат:</p>

<pre class="code">
INFO: Application is started
DEBUG: Loop i = 0
DEBUG: Loop i = 1
DEBUG: Loop i = 2
DEBUG: Loop i = 3
DEBUG: Loop i = 4
WARNING: Application end
</pre>







<h2 id="memory.h">
<span class="h2_num">2.16</span><tt>__vic/memory.h</tt>
</h2>


<p>Утилиты для работы с памятью.</p>


<h3 id="load_unaligned">
<span class="h3_num">2.16.1</span><tt>load_unaligned()</tt>
</h3>


<pre class="code">
template&lt;class T&gt;
T load_unaligned(const void *p);
</pre>

<p>Загружает значение с потенциально невыровненного адреса, не вызывая ошибку
шины (<tt>SIGBUS</tt>).</p>

<div class="section">Пример</div>
<pre class="code">
const void *p = ...;
// int data = *static_cast&lt;const int *&gt;(p); // потенциальная ошибка шины
int data = __vic::load_unaligned&lt;int&gt;(p);
</pre>





<h3 id="store_unaligned">
<span class="h3_num">2.16.2</span><tt>store_unaligned()</tt>
</h3>


<pre class="code">
template&lt;class T&gt;
void store_unaligned(void *p, T v);
</pre>

<p>Записывает значение по потенциально невыровненному адресу, не вызывая ошибку
шины (<tt>SIGBUS</tt>).</p>

<div class="section">Пример</div>
<pre class="code">
void *p = ...;
// *static_cast&lt;int *&gt;(p) = 123; // потенциальная ошибка шины
__vic::store_unaligned(p, 123);
</pre>







<h2 id="mutex.h">
<span class="h2_num">2.17</span><tt>__vic/mutex.h</tt>
</h2>



<h3 id="mutex">
<span class="h3_num">2.17.1</span><tt>mutex</tt>
</h3>


<pre class="code">
class mutex : private non_copyable
{
public:
    mutex();
    ~mutex();

    void lock();
    bool try_lock();
    bool unlock() noexcept;
};
</pre>

<p>Обычный нерекурсивный мьютекс.</p>

<div class="section">Замечания по использованию</div>
<p>В большинстве случаев, явного использования <tt>lock()</tt> и
<tt>unlock()</tt> нужно избегать. Вместо этого используйте класс
<a href="#mutex_lock"><tt>mutex_lock</tt></a> для управления блокировкими. Он обеспечивает
безопасность при исключениях и удобен для использования.</p>
<p>В режиме C++11 <tt>std::mutex</tt> может быть более подходящим вариантом.</p>


<div class="section">Члены класса</div>

<div>
<pre class="prototype">mutex()</pre>
<blockquote>

<p>Создаёт незаблокированный мьютекс.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~mutex()</pre>
<blockquote>

<p>Уничтожает мьютекс.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void lock()</pre>
<blockquote>

<p>Захватывает блокировку на мьютексе. Ждёт его освобождения, если он уже
захвачен другим потоком в данный момент.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool try_lock()</pre>
<blockquote>

<p>Пытается захватить мьютекс. Немедленно возвращает <tt>false</tt> без
ожидания, если он уже захвачен другим потоком.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool unlock() noexcept</pre>
<blockquote>

<p>Освобождает ранее захваченный мьютекс. Иногда может возвращать <tt>false</tt>
в случае ошибок, но в общем случае обнаружение ошибок не гарантируется.</p>
</blockquote>
</div>



<div class="section">Пример</div>
<p>См. <a href="#mutex_lock"><tt>mutex_lock</tt></a>.</p>





<h3 id="mutex_lock">
<span class="h3_num">2.17.2</span><tt>mutex_lock</tt>
</h3>


<pre class="code">
class mutex_lock : private non_copyable
{
public:
    enum adopt_t { adopt };

    explicit mutex_lock(mutex &amp;mtx);
    mutex_lock(mutex &amp;mtx, adopt_t);
    ~mutex_lock();
};
</pre>

<p>Управляет блокировкой на мьютексе. Снимает блокировку по окончании времени
жизни объекта.</p>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">adopt</pre>
<blockquote>

<p>Тэг конструктора, подавляет захват мьютекса.</p>
</blockquote>
</div>

<div>
<pre class="prototype">explicit mutex_lock(mutex &amp;mtx)</pre>
<blockquote>

<p>Захватывает <tt>mtx</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~mutex_lock()</pre>
<blockquote>

<p>Освобождает <tt>mtx</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">mutex_lock(mutex &amp;mtx, adopt_t)</pre>
<blockquote>

<p>Принимает уже захваченный <tt>mtx</tt>. См. пример.</p>
</blockquote>
</div>



<div class="section">Пример</div>
<pre class="code">
// Типичное использование
__vic::mutex mtx;
void reentrant_function()
{
    __vic::mutex_lock lock(mtx);
    // Критическая секция до конца этого блока
    ...
}

// Использование незахватывающего конструктора
if(mtx.try_lock()) // Пытаемся захватить мьютекс
{
    // Мьютекс успешно захвачен
    __vic::mutex_lock lock(mtx, __vic::mutex_lock::adopt);
    // Критическая секция до конца этого блока
    ...
}
else
{
    // Мьютекс удерживается другим потоком
    ...
}
</pre>







<h2 id="packon.h">
<span class="h2_num">2.18</span><tt>__vic/packon.h</tt> &amp; <tt>__vic/packoff.h</tt>
</h2>


<p>Включение первого файла отключает выравнивание полей структур. Другими
словами, включает «упаковку структур» - размер структуры - это строго сумма
размеров его полей. Включение второго файла восстанавливает выравнивание,
используемое по умолчанию. Таким образом, пара директив <tt>#include</tt>
формируют секцию исходного файла с отключенным выравниванием сруктур.</p>

<div>
<u><b>Замечание</b></u>: Каждый <tt>#include&lt;__vic/packon.h&gt;</tt> должен иметь соответсвующий
<tt>#include&lt;__vic/packoff.h&gt;</tt>.</div>

<div class="section">Пример</div>
<pre class="code">
struct unpacked
{
    bool f1;
    int f2;
};
static_assert(sizeof(unpacked) &gt;= sizeof(bool) + sizeof(int),
    "Total struct size can exceed the sum of members sizes");

#include&lt;__vic/packon.h&gt; // выравнивание отключено, начиная отсюда

struct packed
{
    bool f1;
    int f2;
};
static_assert(sizeof(packed) == sizeof(bool) + sizeof(int),
    "Total struct size is exactly the sum of members sizes");

#include&lt;__vic/packoff.h&gt; // выравнивание снова включено
</pre>




<h2 id="readers">
<span class="h2_num">2.19</span><tt>__vic/readers/</tt>
</h2>



<h3 id="reader-concept">
<span class="h3_num">2.19.1</span><tt>Reader</tt> concept</h3>


<pre class="code">
template&lt;class ElementT&gt;
class <span class="nonterminal">Reader</span>
{
public:
    Reader(Reader &amp;&amp;o); or Reader(const Reader &amp;o);
    bool read(ElementT &amp;v); // throws on errors
};
</pre>

<p>Concept, используемый алгоритмами библиотеки для поэлементного чтения
логической последовательности элементов типа <tt>ElementT</tt>. Является
обобщением и переработкой concept'а <tt>InputIterator</tt>. В частности,
он лучше обрабатывает потоки ввода/вывода, строки с нулевым терминатором и
другие последовательности, в которых <tt>end</tt>-итератор не имеет смысла или
его получение дорого. В то же время, традиционные пары итераторов
[<tt>begin</tt>,<tt>end</tt>) являются просто частным случаем и полностью
поддерживаются адаптером <tt>__vic::iterator_reader</tt>.</p>

<p>В случаях, когда конкретный класс удовлетворяет требованиям данного concept
для некоторого <tt>ElementT = T</tt>, говорят, что он <b>моделирует</b> concept
<tt>Reader&lt;T&gt;</tt>.</p>

<p>Каждый экземпляр класса должен быть move- или copy-constructible.</p>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">bool read(ElementT &amp;v)</pre>
<blockquote>

<p>Пытается получить следующий элемент последовательности. Возвращает
<tt>true</tt> и помещает прочитанное значение в <tt>v</tt> в случае успеха.
Возвращает <tt>false</tt>, если больше элементов не осталось (EOF). Бросает
исключения в остальных случаях.</p>
</blockquote>
</div>






<h3 id="iterator_reader">
<span class="h3_num">2.19.2</span><tt>iterator_reader</tt>
</h3>


<pre class="code">
#include&lt;__vic/readers/iterator.h&gt;

template&lt;class InputIterator,
         class T = typename std::iterator_traits&lt;InputIterator&gt;::value_type&gt;
class iterator_reader
{
public:
    iterator_reader(InputIterator begin, InputIterator end);
    bool read(T &amp;v);
    InputIterator position() const;
};

template&lt;class InputIterator&gt; iterator_reader&lt;InputIterator&gt;
make_iterator_reader(InputIterator begin, InputIterator end);

template&lt;class T, class InputIterator&gt; iterator_reader&lt;InputIterator,T&gt;
make_iterator_reader_for(InputIterator begin, InputIterator end);
</pre>

<p>Адаптер для традиционной [<tt>begin</tt>,<tt>end</tt>) пары итераторов.</p>

<p>Дополнительная функция <tt>position()</tt> возвращает текущую позицию
итератора внутри диапазона.</p>

<p>Может быть создан с помощью конструктора или одной из функций
<tt>make_...</tt>.</p>




<h3 id="iterator_reader_n">
<span class="h3_num">2.19.3</span><tt>iterator_reader_n</tt>
</h3>


<pre class="code">
#include&lt;__vic/readers/iterator.h&gt;

template&lt;class InputIterator,
         class T = typename std::iterator_traits&lt;InputIterator&gt;::value_type&gt;
class iterator_reader_n
{
public:
    iterator_reader_n(InputIterator begin, size_t n);
    bool read(T &amp;v);
    InputIterator position() const;
};

template&lt;class InputIterator&gt; iterator_reader_n&lt;InputIterator&gt;
make_iterator_reader_n(InputIterator begin, size_t n);

template&lt;class T, class InputIterator&gt; iterator_reader_n&lt;InputIterator,T&gt;
make_iterator_reader_n_for(InputIterator begin, size_t n);
</pre>

<p>Адаптер для итератора со счётчиком элементов.</p>

<p>Дополнительная функция <tt>position()</tt> возвращает текущую позицию
итератора внутри диапазона.</p>

<p>Может быть создан с помощью конструктора или одной из функций
<tt>make_...</tt>.</p>




<h3 id="container_reader">
<span class="h3_num">2.19.4</span><tt>container_reader</tt>
</h3>


<pre class="code">
#include&lt;__vic/readers/container.h&gt;

template&lt;class Cont, class T = typename Cont::value_type&gt;
class container_reader
{
public:
    explicit container_reader(const Cont &amp;c);
    bool read(T &amp;v);
    typename Cont::const_iterator position() const;
};

template&lt;class Cont&gt;
container_reader&lt;Cont&gt; make_container_reader(const Cont &amp;c);

template&lt;class T, class Cont&gt;
container_reader&lt;Cont,T&gt; make_container_reader_for(const Cont &amp;c);
</pre>

<p>Адаптер для контейнеров в стиле STL, имеющих члены <tt>begin()</tt> и
<tt>end()</tt>.</p>

<p>Дополнительная функция <tt>position()</tt> возвращает текущую позицию
итератора внутри диапазона.</p>

<p>Может быть создан с помощью конструктора или одной из функций
<tt>make_...</tt>.</p>




<h3 id="cstring_reader">
<span class="h3_num">2.19.5</span><tt>cstring_reader</tt>
</h3>


<pre class="code">
#include&lt;__vic/readers/cstring.h&gt;

template&lt;class charT&gt;
class basic_cstring_reader
{
public:
    explicit basic_cstring_reader(const charT *s);
    bool read(charT &amp;ch);
    const charT *position() const;
};

template&lt;&gt;
class basic_cstring_reader&lt;char&gt;
{
public:
    explicit basic_cstring_reader(const char *s);
    bool read(char &amp;ch);
    bool read(unsigned char &amp;ch);
    const char *position() const;
};
using cstring_reader = basic_cstring_reader&lt;char&gt;;

template&lt;class charT&gt;
basic_cstring_reader&lt;charT&gt; make_cstring_reader(const charT *s);
</pre>

<p>Адаптер для C-строк с нулевым терминатором.</p>

<p>Дополнительная функция <tt>position()</tt> возвращает текущую позицию
указателя внутри строки.</p>

<p>Специализация для <tt>char</tt> моделирует как <tt>Reader&lt;char&gt;</tt>,
так и<tt>Reader&lt;unsigned char&gt;</tt>.</p>

<p>Может быть создан с помощью конструктора или функции <tt>make_...</tt>.</p>




<h3 id="string_reader">
<span class="h3_num">2.19.6</span><tt>string_reader</tt>
</h3>


<pre class="code">
#include&lt;__vic/readers/string.h&gt;

template&lt;
    class charT,
    class Tr = std::char_traits&lt;charT&gt;,
    class Al = std::allocator&lt;charT&gt;
&gt;
class basic_string_reader
{
public:
    explicit basic_string_reader(const std::basic_string&lt;charT,Tr,Al&gt; &amp;s);
    bool read(charT &amp;ch);
    const charT *position() const;
};

template&lt;class Tr, class Al&gt;
class basic_string_reader&lt;char,Tr,Al&gt;
{
public:
    explicit basic_string_reader(const std::basic_string&lt;char,Tr,Al&gt; &amp;s);
    bool read(char &amp;ch);
    bool read(unsigned char &amp;ch);
    const char *position() const;
};
using string_reader = basic_string_reader&lt;char&gt;;

template&lt;class charT, class Tr, class Al&gt;
basic_string_reader&lt;charT,Tr,Al&gt;
    make_string_reader(const std::basic_string&lt;charT,Tr,Al&gt; &amp;s);
</pre>

<p>Адаптер для <tt>std::basic_string</tt>.</p>

<p>Дополнительная функция <tt>position()</tt> возвращает текущую позицию
указателя внутри строки.</p>

<p>Специализация для <tt>char</tt> моделирует как <tt>Reader&lt;char&gt;</tt>,
так и <tt>Reader&lt;unsigned char&gt;</tt>.</p>

<p>Может быть создан с помощью конструктора или функции <tt>make_...</tt>.</p>




<h3 id="cstream_reader">
<span class="h3_num">2.19.7</span><tt>cstream_reader</tt>
</h3>


<pre class="code">
#include&lt;__vic/readers/cstream.h&gt;

class cstream_reader
{
public:
    explicit cstream_reader(std::FILE *fp);
    bool read(char &amp;ch) { return __vic::read(fp, ch); }
    bool read(unsigned char &amp;ch) { return __vic::read(fp, ch); }
};

cstream_reader make_cstream_reader(std::FILE *fp);
</pre>

<p>Моделирует <tt>Reader&lt;char&gt;</tt> и <tt>Reader&lt;unsigned char&gt;</tt> для
<tt>std::FILE</tt>.</p>

<p>Может быть создан с помощью конструктора или функции <tt>make_...</tt>.</p>






<h2 id="readonly_cstring.h">
<span class="h2_num">2.20</span><tt>__vic/readonly_cstring.h</tt>
</h2>


<h3 id="readonly_cstring">
<span class="h3_num">2.20.1</span><tt>readonly_cstring</tt>
</h3>


<pre class="code">
class readonly_cstring
{
public:
    readonly_cstring();
    readonly_cstring(const char *str);
    readonly_cstring(const char *begin, const char *end);
    readonly_cstring(const char *chars, size_t n);
    readonly_cstring(const readonly_cstring &amp;str);
    ~readonly_cstring() noexcept;

    // BEGIN C++11
    readonly_cstring(readonly_cstring &amp;&amp;str) noexcept;
    readonly_cstring &amp;operator=(readonly_cstring &amp;&amp;str) noexcept;
    // END C++11

    readonly_cstring &amp;operator=(const char *str);
    readonly_cstring &amp;operator=(const readonly_cstring &amp;str);
    readonly_cstring &amp;assign(const char *str);
    readonly_cstring &amp;assign(const char *chars, size_t n);
    readonly_cstring &amp;assign(const char *begin, const char *end);

    bool empty() const;
    const char *c_str() const;
    operator const char*() const;

    char *reserve(size_t n);
    void swap(readonly_cstring &amp;str) noexcept;
};

int compare(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2);
int compare(const readonly_cstring &amp;s1, const char *s2);
int compare(const char *s1, const readonly_cstring &amp;s2);

bool operator==(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2);
bool operator!=(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2);
bool operator&lt;(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2);
bool operator&gt;(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2);
bool operator&lt;=(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2);
bool operator&gt;=(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2);

bool operator==(const readonly_cstring &amp;s1, const char *s2);
bool operator!=(const readonly_cstring &amp;s1, const char *s2);
bool operator&lt;(const readonly_cstring &amp;s1, const char *s2);
bool operator&gt;(const readonly_cstring &amp;s1, const char *s2);
bool operator&lt;=(const readonly_cstring &amp;s1, const char *s2);
bool operator&gt;=(const readonly_cstring &amp;s1, const char *s2);

bool operator==(const char *s1, const readonly_cstring &amp;s2);
bool operator!=(const char *s1, const readonly_cstring &amp;s2);
bool operator&lt;(const char *s1, const readonly_cstring &amp;s2);
bool operator&gt;(const char *s1, const readonly_cstring &amp;s2);
bool operator&lt;=(const char *s1, const readonly_cstring &amp;s2);
bool operator&gt;=(const char *s1, const readonly_cstring &amp;s2);

void swap(readonly_cstring &amp;s1, readonly_cstring &amp;s2) noexcept;
</pre>

<p>Простой класс неизменяемой строки с нулевым терминатором, автоматически
управляющий памятью. Имеет простейшую предсказуемую структуру, что может быть
полезно для обеспечения двоичной совместимости или в случаях, когда
использование <tt>std::string</tt> нежелательно по каким-либо причинам.
Функциональность класса также минимальна. Она обеспечивает копирование и
хранение строки, а также доступ к ней на чтение. Модифицировать строку нельзя –
только заменять полностью на другую.</p>

<p>Если Вам нужно хранить в классе строковое значение, то использование данного
типа для строкового поля – это хороший вариант. Это более удобно, универсально
и безопасно, чем массив символов (<tt>char[]</tt>) и часто более эффективно,
чем <tt>std::string</tt>, хотя, конечно, менее универсально. Если строку
предстоит часто редактировать (не считая полной замены), то лучше рассмотреть
альтернативные варианты представления, например <tt>__vic::string_buffer</tt>.
Класс <tt>readonly_cstring</tt> разработан не для этих целей.</p>

<div class="section">Гарантии, предоставляемые дизайном класса</div>
<ul>
<li>Пустой указатель корректно воспринимается как пустая строка.</li>
<li>Преобразователь в C-строку (<tt>const char *</tt>) всегда возвращает
        корректный указатель, никогда не возвращается <tt>nullptr</tt>.</li>
<li>Хранимая строка занимает в памяти ровно столько места, сколько ей
        требуется. Никогда не резервируется дополнительная память.</li>
<li>Набор полей-данных состоит только из одного поля – указателя на
        хранимую строку. Поэтому, если компилятор не применяет выравнивание,
        размер объекта будет равен размеру указателя.</li>
</ul>


<div class="section">Члены класса</div>

<div>
<pre class="prototype">readonly_cstring()</pre>
<blockquote>

<p>Создаёт пустую строку.</p>
<div>
<u>Постусловие</u>: <tt>empty() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">readonly_cstring(const char *str)</pre>
<pre class="prototype">readonly_cstring(const readonly_cstring &amp;str)</pre>
<blockquote>


<p>Создаёт копию <tt>str</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">readonly_cstring(const char *chars, size_t n)</pre>
<pre class="prototype">readonly_cstring(const char *begin, const char *end)</pre>
<blockquote>


<p>Создаёт строку из диапазона символов.</p>
</blockquote>
</div>

<div>
<pre class="prototype">readonly_cstring &amp;operator=(const char *str)</pre>
<pre class="prototype">readonly_cstring &amp;operator=(const readonly_cstring &amp;str)</pre>
<pre class="prototype">readonly_cstring &amp;assign(const char *str)</pre>
<blockquote>



<p>Присваивает <tt>str</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">readonly_cstring(readonly_cstring &amp;&amp;str) noexcept <span class="sign">[C++11]</span></pre>
<pre class="prototype">readonly_cstring &amp;operator=(readonly_cstring &amp;&amp;str) noexcept <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Операции перемещения для режима C++11.</p>
</blockquote>
</div>

<div>
<pre class="prototype">readonly_cstring &amp;assign(const char *begin, const char *end)</pre>
<pre class="prototype">readonly_cstring &amp;assign(const char *chars, size_t n)</pre>
<blockquote>


<p>Присваивает строку из диапазона символов.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool empty() const</pre>
<blockquote>

<p>Возвращает <tt>true</tt>, если строка пустая.</p>
</blockquote>
</div>

<div>
<pre class="prototype">const char *c_str() const</pre>
<pre class="prototype">operator const char*() const</pre>
<blockquote>


<p>Возвращает указатель на хранимую строку. Возвращаемый указатель никогда не
бывает пустым.</p>
</blockquote>
</div>

<div>
<pre class="prototype">char *reserve(size_t n)</pre>
<blockquote>

<p>Резервирует внутренний буфер в <tt>n</tt> символов и возвращает указатель на
него. Бывает полезно для использования с функциями вроде <tt>std::sprintf()</tt>.
</p>
<div>
<u>Замечание</u>: Используйте как можно реже данную опасную функцию!</div>
</blockquote>
</div>

<div>
<pre class="prototype">void swap(readonly_cstring &amp;str) noexcept</pre>
<blockquote>

<p>Меняется содержимым с <tt>str</tt>.</p>
</blockquote>
</div>



<div class="section">Свободные функции</div>

<div>
<pre class="prototype">int compare(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2)</pre>
<pre class="prototype">int compare(const readonly_cstring &amp;s1, const char *s2)</pre>
<pre class="prototype">int compare(const char *s1, const readonly_cstring &amp;s2)</pre>
<blockquote>



<p>Сравнивает две строки аналогично <tt>std::strcmp</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool operator==(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2)</pre>
<pre class="prototype">...</pre>
<pre class="prototype">bool operator&gt;=(const char *s1, const readonly_cstring &amp;s2)</pre>
<blockquote>



<p>Полный набор операторов сравнения <tt>readonly_cstring</tt> и
<tt>const char *</tt> в различных сочетаниях.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void swap(readonly_cstring &amp;s1, readonly_cstring &amp;s2) noexcept</pre>
<blockquote>

<p>Специализация стандартного алгоритма.</p>
</blockquote>
</div>



<div class="section">Пример</div>
<pre class="code">
class C
{
    __vic::readonly_cstring st;
public:
    explicit C(const char *str) : st(str) {}
    const char *get_str() const { return st; }
};
</pre>






<h2 id="set_of_chars.h">
<span class="h2_num">2.21</span><tt>__vic/set_of_chars.h</tt>
</h2>


<h3 id="set_of_chars">
<span class="h3_num">2.21.1</span><tt>set_of_chars</tt>
</h3>


<pre class="code">
class set_of_chars
{
public:
    constexpr set_of_chars();
    template&lt;class Iter&gt; constexpr set_of_chars(Iter begin, Iter end);
    constexpr set_of_chars(std::initializer_list&lt;char&gt; set); // C++11
    constexpr set_of_chars(const char *c_str);

    constexpr bool contains(char ch) const;

    constexpr void add(char ch);
    constexpr void remove(char ch);

    template&lt;class Iter&gt; constexpr void add(Iter begin, Iter end);
    constexpr void add(const char *c_str);
    constexpr void add(std::initializer_list&lt;char&gt; set); // C++11

    template&lt;class Iter&gt; void assign(Iter begin, Iter end);
    void assign(const char *c_str)
    void assign(std::initializer_list&lt;char&gt; set); // C++11

    void clear();
};
</pre>

<p>Компактная (всего 32 байта) и очень быстрая реализация множества символов.
Операция <tt>contains()</tt> всегда выполняется за константное время, независимо
от аргумента и количества элементов во множестве.</p>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">constexpr set_of_chars()</pre>
<blockquote>

<p>Создаёт пустое множество.</p>
<div>
<u>Постусловие</u>: <tt>contains(char(ch)) == false</tt> для любого символа
</div>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class Iter&gt; constexpr set_of_chars(Iter begin, Iter end)</pre>
<pre class="prototype">constexpr set_of_chars(std::initializer_list&lt;char&gt; set) <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Создаёт множество, заполненное символами из указанного диапазона значений.
</p>
<div>
<u>Замечание</u>: <tt>constexpr</tt> только начиная с C++14!</div>
</blockquote>
</div>

<div>
<pre class="prototype">constexpr set_of_chars(const char *c_str)</pre>
<blockquote>

<p>Создаёт множество, заполненное символами указанной C-строки, исключая
нулевой терминатор.</p>
<div>
<u>Замечание</u>: <tt>constexpr</tt> только начиная с C++14!</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool contains(char ch) const</pre>
<blockquote>

<p>Проверяет, содержит ли множество <tt>ch</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">constexpr void add(char ch)</pre>
<blockquote>

<p>Добавляет <tt>ch</tt> во множество.</p>
<div>
<u>Постусловие</u>: <tt>contains(ch) == true</tt>
</div>
<div>
<u>Замечание</u>: <tt>constexpr</tt> только начиная с C++14!</div>
</blockquote>
</div>

<div>
<pre class="prototype">constexpr void remove(char ch)</pre>
<blockquote>

<p>Удаляет <tt>ch</tt> из множества.</p>
<div>
<u>Постусловие</u>: <tt>contains(ch) == false</tt>
</div>
<div>
<u>Замечание</u>: <tt>constexpr</tt> только начиная с C++14!</div>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class Iter&gt; constexpr void add(Iter begin, Iter end)</pre>
<pre class="prototype">constexpr void add(std::initializer_list&lt;char&gt; set) <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Вызывает <tt>add(ch)</tt> для каждого значения из диапазона.</p>
<div>
<u>Замечание</u>: <tt>constexpr</tt> только начиная с C++14!</div>
</blockquote>
</div>

<div>
<pre class="prototype">constexpr void add(const char *c_str)</pre>
<blockquote>

<p>Вызывает <tt>add(ch)</tt> для каждого символа C-строки, исключая нулевой
терминатор.</p>
<div>
<u>Замечание</u>: <tt>constexpr</tt> только начиная с C++14!</div>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class Iter&gt; void assign(Iter begin, Iter end)</pre>
<pre class="prototype">void assign(const char *c_str)</pre>
<pre class="prototype">void assign(std::initializer_list&lt;char&gt; set) <span class="sign">[C++11]</span></pre>
<blockquote>



<p>Вызывает <tt>clear()</tt>, затем <tt>add()</tt> с указанными параметрами.
</p>
</blockquote>
</div>

<div>
<pre class="prototype">void clear()</pre>
<blockquote>

<p>Удаляет все элементы из множества.</p>
<div>
<u>Постусловие</u>: <tt>contains(char(ch)) == false</tt> для любого символа
</div>
</blockquote>
</div>







<h2 id="stdint.h">
<span class="h2_num">2.22</span><tt>__vic/stdint.h</tt>
</h2>


<p><tt>&lt;stdint.h&gt;</tt> из ISO C99 для C++98. Начиная с C++11 - просто
перенаправление на <tt>&lt;cstdint&gt;</tt>.</p>
<p>Дополнительно содержит некоторые метафункции для шаблонного
метапрограммирования.</p>


<h3 id="intN_t">
<span class="h3_num">2.22.1</span>Целые с точной длиной</h3>


<p>Гарантируется, что следующие типы доступны в <b>глобальном пространстве
имён</b>:</p>
<ul>
<li><tt>int8_t</tt></li>
<li><tt>int16_t</tt></li>
<li><tt>int32_t</tt></li>
<li><tt>int64_t</tt></li>
<li><tt>uint8_t</tt></li>
<li><tt>uint16_t</tt></li>
<li><tt>uint32_t</tt></li>
<li><tt>uint64_t</tt></li>
</ul>




<h3 id="int_leastN_t">
<span class="h3_num">2.22.2</span>Целые с минимальной длиной</h3>


<p>Гарантируется, что следующие типы доступны в <b>глобальном пространстве
имён</b>:</p>
<ul>
<li><tt>int_least8_t</tt></li>
<li><tt>int_least16_t</tt></li>
<li><tt>int_least32_t</tt></li>
<li><tt>int_least64_t</tt></li>
<li><tt>uint_least8_t</tt></li>
<li><tt>uint_least16_t</tt></li>
<li><tt>uint_least32_t</tt></li>
<li><tt>uint_least64_t</tt></li>
</ul>




<h3 id="int_fastN_t">
<span class="h3_num">2.22.3</span>Быстрейшие целые с минимальной длиной</h3>


<p>Гарантируется, что следующие типы доступны в <b>глобальном пространстве
имён</b>:</p>
<ul>
<li><tt>int_fast8_t</tt></li>
<li><tt>int_fast16_t</tt></li>
<li><tt>int_fast32_t</tt></li>
<li><tt>int_fast64_t</tt></li>
<li><tt>uint_fast8_t</tt></li>
<li><tt>uint_fast16_t</tt></li>
<li><tt>uint_fast32_t</tt></li>
<li><tt>uint_fast64_t</tt></li>
</ul>




<h3 id="intmax_t">
<span class="h3_num">2.22.4</span>Целые наибольшего размера</h3>


<p>Гарантируется, что следующие типы доступны в <b>глобальном пространстве
имён</b>:</p>
<ul>
<li><tt>intmax_t</tt></li>
<li><tt>uintmax_t</tt></li>
</ul>




<h3 id="intptr_t">
<span class="h3_num">2.22.5</span>Целые, вмещающие указатели на объекты</h3>


<p>Гарантируется, что следующие типы доступны в <b>глобальном пространстве
имён</b>:</p>
<ul>
<li><tt>intptr_t</tt></li>
<li><tt>uintptr_t</tt></li>
</ul>




<h3 id="int_exactly_bytes">
<span class="h3_num">2.22.6</span><tt>int_exactly_bytes&lt;&gt;</tt>, <tt>uint_exactly_bytes&lt;&gt;</tt>
</h3>


<pre class="code">
template&lt;unsigned SizeInBytes&gt;
struct int_exactly_bytes
{
    using type = <span class="nonterminal">&lt;signed-integer-type-of-the-corresponding-size&gt;</span>;
};

template&lt;unsigned SizeInBytes&gt;
struct uint_exactly_bytes
{
    using type = <span class="nonterminal">&lt;unsigned-integer-type-of-the-corresponding-size&gt;</span>;
};

// BEGIN C++11
template&lt;unsigned N&gt;
using int_exact_bytes = typename int_exactly_bytes&lt;N&gt;::type;

template&lt;unsigned N&gt;
using uint_exact_bytes = typename uint_exactly_bytes&lt;N&gt;::type;
// END C++11
</pre>

<p>Метафункции, возвращающие знаковый/беззнаковый целый тип для указанного
размера в байтах. Более короткие псевдонимы доступны в режиме C++11 и выше.
Допустимые значения для <tt>SizeInBytes</tt>: <tt>1</tt>, <tt>2</tt>,
<tt>4</tt>, <tt>8</tt>.</p>

<div class="section">Пример</div>
<pre class="code">
typedef __vic::int_exactly_bytes&lt; sizeof(void *) &gt;::type my_intptr_t;
// or in C++11
using my_intptr_t = __vic::int_exact_bytes&lt; sizeof(void *) &gt;
assert( sizeof(my_intptr) == sizeof(intptr_t) );
</pre>







<h2 id="stdio_file.h">
<span class="h2_num">2.23</span><tt>__vic/stdio_file.h</tt>
</h2>


<p>C++ обёртки для <tt>std::FILE</tt>.</p>


<h3 id="stdio_file">
<span class="h3_num">2.23.1</span><tt>stdio_file</tt>
</h3>


<pre class="code">
class stdio_file : private non_copyable
{
public:
    explicit stdio_file(std::FILE *fp = nullptr);
    stdio_file(const char *name, const char *mode);
    ~stdio_file();

    // BEGIN C++11
    stdio_file(stdio_file &amp;&amp;o) noexcept;
    stdio_file &amp;operator=(stdio_file &amp;&amp;o) noexcept;
    // END C++11

    bool open(const char *name, const char *mode);
    bool is_open() const;
    void close();
    bool close_nt() noexcept;

    void swap(stdio_file &amp;o) noexcept;
    std::FILE *detach_handle() noexcept;
    std::FILE *attach_handle(std::FILE *fp) noexcept;
    std::FILE *handle() const;
    operator std::FILE*() const;
};
</pre>

<p>Тонкая RAII-обёртка для <tt>std::FILE *</tt>. Контролирует время жизни
файла. Автоматический преобразователь типа позволяет использовать объекты
данного типа в контекстах, требующих <tt>FILE *</tt>.</p>

<div>
<u><b>Замечание</b></u>: Хоть деструктор объекта и закрывает незакрытый поток, но лучше
использовать явный вызов <tt>close()</tt>. При закрытии потока также могут
происходить ошибки, и <tt>close()</tt> проинформирует о них исключением.
Деструктор же их просто проигнорирует, и они останутся незамечены приложением.
</div>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">explicit stdio_file(std::FILE *fp = nullptr)</pre>
<blockquote>

<p>Создаёт обёртку для уже имеющегося указателя потока.</p>
<div>
<u>Предусловие</u>: <tt>fp</tt> указывает на открытый файл или <tt>nullptr</tt>.
</div>
</blockquote>
</div>

<div>
<pre class="prototype">stdio_file(const char *name, const char *mode)</pre>
<blockquote>

<p>Вызывает <tt>open(name, mode)</tt>. Необходимо проверить результат открытия
последующим вызовом <tt>is_open()</tt>!</p>
</blockquote>
</div>

<div>
<pre class="prototype">~stdio_file()</pre>
<blockquote>

<p>Вызывает <tt>std::fclose()</tt>, если <tt>is_open() == true</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">stdio_file(stdio_file &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<pre class="prototype">stdio_file &amp;operator=(stdio_file &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Операции перемещения для режима C++11.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool open(const char *name, const char *mode)</pre>
<blockquote>

<p>Вызывает <tt>std::fopen(name, mode)</tt>. Возвращает <tt>true</tt> в случае
успеха.</p>
<div>
<u>Предусловие</u>: <tt>is_open() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool is_open() const</pre>
<blockquote>

<p>Возвращает <tt>true</tt> если файл открыт.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void close()</pre>
<blockquote>

<p>Вызывает <tt>std::fclose()</tt>. Проверка на то, открыт ли файл, не
производится! Если <tt>std::fclose()</tt> возвращает ошибку, то бросается
исключение.</p>
<div>
<u>Предусловие</u>: <tt>is_open() == true</tt>
</div>
<div>
<u>Постусловие</u>: <tt>is_open() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool close_nt() noexcept</pre>
<blockquote>

<p>Аналог <tt>close()</tt>, но никогда не бросает исключений, а возвращает
<tt>false</tt> в случае ошибок.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void swap(stdio_file &amp;o) noexcept</pre>
<blockquote>

<p>Обменивается значением с <tt>o</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">std::FILE *detach_handle() noexcept</pre>
<blockquote>

<p>Освобождает файл из-под контроля объекта.</p>
<div>
<u>Постусловие</u>: <tt>is_open() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">std::FILE *attach_handle(std::FILE *fp) noexcept</pre>
<blockquote>

<p>Помещает <tt>fp</tt> под контроль объекта и возвращает предыдущее хранимое
значение.</p>
<div>
<u>Предусловие</u>: <tt>fp</tt> – указатель на открытый файл или <tt>nullptr</tt>.
</div>
<div>
<u>Постусловие</u>: <tt>handle() == fp</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">std::FILE *handle() const</pre>
<blockquote>

<p>Возвращает хранимое завёрнутое значение.</p>
</blockquote>
</div>

<div>
<pre class="prototype">operator std::FILE*() const</pre>
<blockquote>

<p>Позволяет использовать объект как <tt>std::FILE *</tt>.</p>
</blockquote>
</div>



<div class="section">Пример</div>
<pre class="code">
__vic::stdio_file file("file.txt", "w");
if(!file.is_open()) throw __vic::exception("Cannot open file");
std::fprintf(file, "Message");
file.close();
// fclose() также вызовется автоматически деструктором при исключениях
</pre>





<h3 id="read-FILE-char">
<span class="h3_num">2.23.2</span><tt>read(std::FILE, char&amp;)</tt>,
    <tt>read(std::FILE, unsigned char&amp;)</tt>
</h3>


<pre class="code">
bool read(std::FILE *fp, char &amp;ch);
bool read(std::FILE *fp, unsigned char &amp;ch);
</pre>

<p>Пытается прочитать байт из потока C. Возвращает <tt>true</tt> в случае
успеха, <tt>false</tt> при достижении конца файла или бросает исключение в
случае ошибки.</p>



<h3 id="write-FILE-char">
<span class="h3_num">2.23.3</span><tt>write(std::FILE, char)</tt>
</h3>


<pre class="code">
void write(std::FILE *fp, char ch);
</pre>

<p>Записывает байт в поток C. Бросает исключение в случае ошибки.</p>



<h3 id="getline-FILE">
<span class="h3_num">2.23.4</span><tt>getline(std::FILE)</tt>
</h3>


<pre class="code">
bool getline(std::FILE *fp, std::string &amp;str, char delim = '\n');
</pre>

<p>Аналог <tt>std::getline</tt> для потоков C. Возвращает <tt>false</tt>,
если конец файла достигнут раньше, чем что-то было прочитано.</p>





<h2 id="str2num.h">
<span class="h2_num">2.24</span><tt>__vic/str2num.h</tt>
</h2>



<h3 id="decimal_to_number">
<span class="h3_num">2.24.1</span><tt>decimal_to_number()</tt>
</h3>


<pre class="code">
#if __cpp_lib_string_view // since C++17

void decimal_to_number(std::string_view s, long long &amp;res);
void decimal_to_number(std::string_view s, long &amp;res);
void decimal_to_number(std::string_view s, int &amp;res);
void decimal_to_number(std::string_view s, short &amp;res);
void decimal_to_number(std::string_view s, signed char &amp;res);

void decimal_to_number(std::string_view s, unsigned long long &amp;res);
void decimal_to_number(std::string_view s, unsigned long &amp;res);
void decimal_to_number(std::string_view s, unsigned &amp;res);
void decimal_to_number(std::string_view s, unsigned short &amp;res);
void decimal_to_number(std::string_view s, unsigned char &amp;res);

template&lt;class Integer&gt;
[[nodiscard]] Integer decimal_to_number(std::string_view s);

#else // until C++17

void decimal_to_number(const std::string &amp;s, long long &amp;res);
void decimal_to_number(const std::string &amp;s, long &amp;res);
void decimal_to_number(const std::string &amp;s, int &amp;res);
void decimal_to_number(const std::string &amp;s, short &amp;res);
void decimal_to_number(const std::string &amp;s, signed char &amp;res);

void decimal_to_number(const std::string &amp;s, unsigned long long &amp;res);
void decimal_to_number(const std::string &amp;s, unsigned long &amp;res);
void decimal_to_number(const std::string &amp;s, unsigned &amp;res);
void decimal_to_number(const std::string &amp;s, unsigned short &amp;res);
void decimal_to_number(const std::string &amp;s, unsigned char &amp;res);

void decimal_to_number(const char *s, long long &amp;res);
void decimal_to_number(const char *s, long &amp;res);
void decimal_to_number(const char *s, int &amp;res);
void decimal_to_number(const char *s, short &amp;res);
void decimal_to_number(const char *s, signed char &amp;res);

void decimal_to_number(const char *s, unsigned long long &amp;res);
void decimal_to_number(const char *s, unsigned long &amp;res);
void decimal_to_number(const char *s, unsigned &amp;res);
void decimal_to_number(const char *s, unsigned short &amp;res);
void decimal_to_number(const char *s, unsigned char &amp;res);

template&lt;class Integer&gt;
[[nodiscard]] Integer decimal_to_number(const std::string &amp;s);

template&lt;class Integer&gt;
[[nodiscard]] Integer decimal_to_number(const char *s);

#endif
</pre>

<p>Набор функций, преобразующих строки, содержащие десятичное представление
целого числа, в один из стандартных целых типов C++. Входная строка может быть
как C-строкой, так и <tt>std::string</tt>.</p>

<p>В отличие от стандартных преобразователей, вроде <tt>std::strtol()</tt>,
производится строгая проверка на формат строки и диапазон значения. В частности,
лидирующие пробелы и символы, не являющиеся цифрами, в конце не допустимы. Для
беззнаковых типов недопустим символ '-', который <tt>std::strtoul()</tt> по
непонятной причине воспринимает как корректный.</p>

<p>В случае ошибок бросаются исключения:</p>
<ul>
<li>
<tt>std::invalid_argument</tt> – строка не является корректным целым
        десятичным числом;</li>
<li>
<tt>std::range_error</tt> – строка является корректным числом, но
        результат не представим в диапазоне запрошенного типа (целочисленное
        переполнение).</li>
</ul>

<p>Для данных функций доступны две категории прототипов:</p>
<ol>
<li>Значение возвращается через дополнительный выходной параметр и</li>
<li>Значение возвращается естественным образом, а его тип задаётся
        аргументом шаблона.</li>
</ol>




<h3 id="decimal_to_number_range">
<span class="h3_num">2.24.2</span><tt>decimal_to_number_range()</tt>
</h3>


<pre class="code">
template&lt;class T, class InputIterator&gt;
void decimal_to_number_range(InputIterator begin, InputIterator end, T &amp;res);

template&lt;class T, class InputIterator&gt;
[[nodiscard]] T decimal_to_number_range(InputIterator begin, InputIterator end);
</pre>

<p>Функции являются полным аналогом функций <tt>decimal_to_number()</tt> за
тем исключением, что на вход принимают диапазон символов вместо строки.</p>




<h3 id="decimal_parser">
<span class="h3_num">2.24.3</span><tt>decimal_parser</tt>
</h3>


<pre class="code">
template&lt;class T&gt;
class decimal_parser
{
    using status = number_parse_status; // только для краткости
public:
    template&lt;class InputIterator&gt;
    [[nodiscard]] status parse(InputIterator begin, InputIterator end);
#if __cpp_lib_string_view // since C++17
    [[nodiscard]] status parse(std::string_view str);
#else // until C++17
    [[nodiscard]] status parse(const std::string &amp;str);
    [[nodiscard]] status parse(const char *str);
#endif
    [[nodiscard]] T result() const;
};
</pre>

<p>Аналог функций <tt>decimal_to_number()</tt>, но ни бросает исключений.
Вместо них <tt>parse()</tt> возвращает коды <a href="#number_parse_status"><tt>number_parse_status</tt></a>.
</p>

<div class="section">Коды статусов</div>
<div>
<pre class="prototype">number_parse_status::ok</pre>
<blockquote>

<p>Удачно, результат может быть получен вызовом функции <tt>result()</tt>.</p>
</blockquote>
</div>
<div>
<pre class="prototype">number_parse_status::invalid_number</pre>
<blockquote>

<p>Строка не является корректным десятичным целым.</p>
</blockquote>
</div>
<div>
<pre class="prototype">number_parse_status::unrepresentable</pre>
<blockquote>

<p>Строка, возможно, корректна, но результат не представим в диапазоне
запрошенного типа (целочисленное переполнение).</p>
</blockquote>
</div>


<div class="section">Члены класса</div>

<div>
<pre class="prototype">template&lt;class InputIterator&gt;
[[nodiscard]] status parse(InputIterator begin, InputIterator end)</pre>
<pre class="prototype">[[nodiscard]] status parse(std::string_view str) <span class="sign">[C++17]</span></pre>
<pre class="prototype">[[nodiscard]] status parse(const std::string &amp;str) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">[[nodiscard]] status parse(const char *str) <span class="sign">[until C++17]</span></pre>
<blockquote>




<p>Преобразует диапазон символов или строку в число.</p>
<div>
<u>Постусловие</u>: Результат преобразования может быть получен вызовом
<tt>result()</tt>, если возвращён <tt>number_parse_status::ok</tt>.
</div>
</blockquote>
</div>

<div>
<pre class="prototype">[[nodiscard]] T result() const</pre>
<blockquote>

<p>Возвращает результат преобразования последнего вызова <tt>parse()</tt>.</p>
<div>
<u>Предусловие</u>: Последний вызов <tt>parse()</tt> вернул
<tt>number_parse_status::ok</tt>.</div>
</blockquote>
</div>



<div class="section">Пример</div>
<pre class="code">
template&lt;class T&gt;
bool to_number(const std::string &amp;s, T &amp;result) noexcept
{
    __vic::decimal_parser&lt;T&gt; p;
    if(p.parse(s) != __vic::number_parse_status::ok) return false;
    result = p.result();
    returt true; // 'result' содержит результат преобразования
}
</pre>





<h3 id="number_parse_status">
<span class="h3_num">2.24.4</span><tt>number_parse_status</tt>
</h3>


<pre class="code">
enum class number_parse_status
{
    ok,
    invalid_number,
    unrepresentable
};
using number_parse_status_t = number_parse_status; // for C++98
</pre>

<p>Коды статусов результата разбора.</p>

<div class="section">Типы</div>

<div>
<pre class="prototype">typename number_parse_status_t</pre>
<blockquote>

<p>Используйте данное имя типа, если коду требуется совместимость с режимом
C++98.</p>
</blockquote>
</div>








<h2 id="string_buffer.h">
<span class="h2_num">2.25</span><tt>__vic/string_buffer.h</tt>
</h2>


<h3 id="string_buffer">
<span class="h3_num">2.25.1</span><tt>string_buffer</tt>
</h3>


<pre class="code">
class string_buffer : public std::string
{
public:
    string_buffer();
    explicit string_buffer(size_type n);
    string_buffer(const char *str);
    string_buffer(std::string str);
    string_buffer(string_ref sr);
    string_buffer(const std::string &amp;str, size_type off, size_type n = npos);
    string_buffer(const char *char_buf, size_type n);
    string_buffer(const char *begin, const char *end);
    template&lt;class InputIterator&gt;
    string_buffer(InputIterator begin, InputIterator end);

    template&lt;class T&gt; string_buffer &amp;operator&lt;&lt;(const T &amp;v);

    string_buffer &amp;operator=(string_ref sr);
    string_buffer &amp;operator+=(string_ref sr);
    string_buffer &amp;assign(string_ref sr);
    string_buffer &amp;append(string_ref sr);

    // improved std::string calls
    string_buffer &amp;assign(const std::string &amp;str,
                            size_type off, size_type n = npos);
    string_buffer &amp;append(const std::string &amp;str,
                            size_type off, size_type n = npos);
    string_buffer &amp;insert(size_type pos, const std::string &amp;str,
                            size_type off, size_type n = npos);

    string_buffer &amp;reserve(size_type n);
    string_buffer &amp;clear();

    // missing container interface of std::string
    reference front();
    reference back();
    const_reference front() const;
    const_reference back() const;
    void pop_back();

    operator const char *() const;
};

string_buffer operator+(const string_buffer &amp;s1, const string_buffer &amp;s2);
string_buffer operator+(const string_buffer &amp;s1, const std::string &amp;s2);
string_buffer operator+(const std::string &amp;s1, const string_buffer &amp;s2);

string_buffer operator+(const string_buffer &amp;s1, const char *s2);
string_buffer operator+(const char *s1, const string_buffer &amp;s2);

string_buffer operator+(const string_buffer &amp;s, char ch);
string_buffer operator+(char ch, const string_buffer &amp;s);

using msg = string_buffer;
</pre>

<p>Класс является улучшенным и расширенным <tt>std::string</tt>. Он имеет
следующие преимущества:</p>

<ol>
<li>Лево-ассоциативная операция конкатенации (<tt>&lt;&lt;</tt>),
позволяющая конструкции, вроде:
<pre class="code">
str &lt;&lt; "Error message: " &lt;&lt; err_msg &lt;&lt; "\n";
</pre>
</li>
<li>В конструкторе можно зарезервировать место под строку в целях
оптимизации, чтобы избежать многократного перераспределения буфера, что
значительно улучшает производительность. Часто имеется возможность оценить
максимальный размер строки. Но если она вдруг окажется длиннее, то буфер
автоматически расширится, как и у <tt>std::string</tt>.
<pre class="code">
__vic::string_buffer st(4096);

// Эффект аналогичен
std::string st;
st.reserve(4096);
</pre>
</li>
<li>Оператор <tt>&lt;&lt;</tt> воспринимает все фундаментальные типы:
числа, символы, указатели, <tt>bool</tt> и другие типы, к которым применима
<a href="#to_text_append"><tt>to_text_append()</tt></a>.
<pre class="code">
for(int i=0; i&lt;10; i++)
    str &lt;&lt; "i = " &lt;&lt; i &lt;&lt; '\n';
</pre>
</li>
<li>Все операции, работающие с <tt>const char *</tt>, корректно воспринимают
пустой указатель как пустую строку. Реализации <tt>std::string</tt> не
проверяют указатель на пустоту и пытаются читать по нему в любом случае.
<pre class="code">
std::string s1("Str");
const char *p = nullptr;
s1.append(p); // Oops.... Null pointer access!

__vic::string_buffer s2("Str");
s2.append(p); // Ok. s2 == "Str" still
s2 = p; // Ok. s2.empty() == true
</pre>
</li>
<li>Автоматическое преобразование в <tt>const char *</tt> позволяет
использовать объекты в контекстах, требующих C-строку без явного преобразования.
<pre class="code">
std::string fname(...);
FILE *fp = fopen(fname.c_str(), "r");

__vic::string_buffer fname(...);
FILE *fp = fopen(fname, "r");)
</pre>
</li>
<li>Исправлены нерегулярности в дизайне класса <tt>std::string</tt>. Например,
класс является полноценным контейнером с доступом к его началу и концу, но у
него отсутствуют операции <tt>front()</tt> и <tt>back()</tt> в C++98.
Также класс имеет операцию <tt>push_back()</tt>, но не имеет симметричной
<tt>pop_back()</tt>.</li>
</ol>

<p>При всех этих улучшениях, объекты данного типа полностью совместимы по
структуре с <tt>std::string</tt> и могут передаваться в контексты, требующие
<tt>std::string</tt>. Никаких дополнительных членов-данных в классе нет.</p>

<p>Использование инсертера (оператора <tt>&lt;&lt;</tt>) данного класса –
это простейший способ преобразовать число или указатель в строку. Механизм,
конечно, не такой мощный, как использование <tt>std::ostringstream</tt>,
например нельзя задать основание системы счисления или форматирование, но зато
самый простой и эффективный. Для вывода диагностики, к примеру, обычно его
вполне достаточно.</p>

<p>Также для данного типа введён синоним <tt>msg</tt>, который удобно
использовать для конструирования составных сообщений на лету одним
выражением без введения дополнительных переменных:</p>

<pre class="code">
oresult res = db_open(db_name);
if(res != 0) throw __vic::exception(
    __vic::msg(64) &lt;&lt; "Cannot open DB " &lt;&lt; db_name &lt;&lt; ". res = " &lt;&lt; res
);
</pre>

<p>Как  видно в примере, в конструктор в целях оптимизации передан максимальный
ожидаемый размер строки.</p>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">string_buffer()</pre>
<blockquote>

<p>Создаёт пустую строку.</p>
<div>
<u>Постусловие</u>: <tt>empty() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">explicit string_buffer(size_type n)</pre>
<blockquote>

<p>Вызывает <tt>reserve(n)</tt>.</p>
<div>
<u>Постусловие</u>: <tt>capacity() &gt;= n</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer(const char *str)</pre>
<pre class="prototype">string_buffer(std::string str)</pre>
<blockquote>


<p>Создаёт копию <tt>str</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer(const std::string &amp;str, size_type off, size_type n = npos)</pre>
<blockquote>

<p>Создаёт копию подстроки <tt>str</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer(const char *char_buf, size_type n)</pre>
<blockquote>

<p>Создаёт строку из буфера и его длины.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer(string_ref sr)</pre>
<pre class="prototype">string_buffer(const char *begin, const char *end)</pre>
<pre class="prototype">template&lt;class InputIterator&gt;
string_buffer(InputIterator begin, InputIterator end)</pre>
<blockquote>



<p>Создаёт строку из диапазона символов.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class T&gt; string_buffer &amp;operator&lt;&lt;(const T &amp;v)</pre>
<blockquote>

<p>Вызывает <tt>to_text_append(v, *this)</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer &amp;operator=(string_ref sr)</pre>
<pre class="prototype">string_buffer &amp;operator+=(string_ref sr)</pre>
<pre class="prototype">string_buffer &amp;assign(string_ref sr)</pre>
<pre class="prototype">string_buffer &amp;append(string_ref sr)</pre>
<blockquote>




<p>Операции для <tt>string_ref</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer &amp;reserve(size_type n)</pre>
<pre class="prototype">string_buffer &amp;clear()</pre>
<blockquote>


<p>Вызывают одноимённую операцию <tt>std::string</tt> и дополнительно возвращают
ссылку на себя, что позволяет использовать вызовы в составных выражениях.</p>
</blockquote>
</div>

<div>
<pre class="prototype">reference front()</pre>
<pre class="prototype">reference back()</pre>
<pre class="prototype">const_reference front() const</pre>
<pre class="prototype">const_reference back() const</pre>
<pre class="prototype">void pop_back()</pre>
<blockquote>





<p>Недостающие операции интерфейса <tt>std::string</tt> в C++98.</p>
</blockquote>
</div>

<div>
<pre class="prototype">operator const char *() const</pre>
<blockquote>

<p>Вызывает <tt>std::string::c_str()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer operator+(const string_buffer &amp;s1, const string_buffer &amp;s2)</pre>
<pre class="prototype">string_buffer operator+(const string_buffer &amp;s1, const std::string &amp;s2)</pre>
<pre class="prototype">string_buffer operator+(const std::string &amp;s1, const string_buffer &amp;s2)</pre>
<pre class="prototype">string_buffer operator+(const string_buffer &amp;s1, const char *s2)</pre>
<pre class="prototype">string_buffer operator+(const char *s1, const string_buffer &amp;s2)</pre>
<pre class="prototype">string_buffer operator+(const string_buffer &amp;s, char ch)</pre>
<pre class="prototype">string_buffer operator+(char ch, const string_buffer &amp;s)</pre>
<blockquote>







<p>Конкатенация строк и символов.</p>
</blockquote>
</div>







<h2 id="string_ref.h">
<span class="h2_num">2.26</span><tt>__vic/string_ref.h</tt>
</h2>


<h3 id="string_ref">
<span class="h3_num">2.26.1</span><tt>string_ref</tt>
</h3>


<pre class="code">
template&lt;class charT&gt;
class basic_string_ref
{
public:
    using value_type = charT;
    using iterator = const value_type *;
    using const_iterator = iterator;

    // Constructors
    basic_string_ref();
    basic_string_ref(const charT *str);
    basic_string_ref(const charT *chars, size_t n);
    basic_string_ref(const charT *begin, const charT *end);
    template&lt;class Traits, class Alloc&gt;
    explicit basic_string_ref(
        const std::basic_string&lt;charT,Traits,Alloc&gt; &amp;str);
    basic_string_ref(
        typename std::basic_string&lt;charT&gt;::const_iterator begin,
        typename std::basic_string&lt;charT&gt;::const_iterator end);
    // BEGIN C++11
    basic_string_ref(std::initializer_list&lt;charT&gt; );
    // END C++11

#if __cpp_lib_string_view // since C++17
    template&lt;class Traits&gt;
    basic_string_ref(std::basic_string_view&lt;charT,Traits&gt; s);
    operator std::basic_string_view&lt;charT&gt;() const;
#endif

    // Accessors
    iterator begin() const;
    iterator end() const;
    iterator cbegin() const;
    iterator cend() const;

    charT front() const;
    charT back() const;
    charT operator[](size_t i) const;
    const charT *data() const;

    bool empty() const;
    size_t size() const;
    size_t length() const;

    int compare(basic_string_ref s) const;

    // Converters
    std::basic_string&lt;charT&gt; str() const;
    template&lt;class Traits&gt;
    std::basic_string&lt;charT,Traits&gt; str() const;
    template&lt;class Traits, class Alloc&gt;
    std::basic_string&lt;charT,Traits,Alloc&gt; str(const Alloc &amp;a = Alloc())const;

    operator std::basic_string&lt;charT&gt;() const;
};

using string_ref = basic_string_ref&lt;char&gt; ;

template&lt;class charT&gt;
bool operator==(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2);
template&lt;class charT&gt;
bool operator!=(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2);
template&lt;class charT&gt;
bool operator&lt;(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2);
template&lt;class charT&gt;
bool operator&gt;(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2);
template&lt;class charT&gt;
bool operator&lt;=(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2);
template&lt;class charT&gt;
bool operator&gt;=(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2);

#ifdef __VIC_DEFINE_OSTREAM_INSERTERS
template&lt;class charT, class Traits&gt;
std::basic_ostream&lt;charT,Traits&gt; &amp;operator&lt;&lt;(
    std::basic_ostream&lt;charT,Traits&gt; &amp;os, const basic_string_ref&lt;charT&gt; &amp;sr);
#endif
</pre>

<p>Класс преставляет собой ссылку на протяжённый диапазон символов, доступных
только для чтения. При использовании в качестве возвращаемого типа он
значительно легче, чем <tt>std::string</tt>, потому что не требует копирования
строки и выделения дополнительной памяти. Но при использовании в контексте,
требующем <tt>std::string</tt>, происходит автоматическое преобразование.
Рассмотрим пример:</p>

<pre class="code">
class C
{
    std::string v;
public:
    std::string       get_v_1() const { return v; }
    __vic::string_ref get_v_2() const { return v; }
};
</pre>

<p>Как видно, в классе хранится поле в виде строки. Для доступа на чтение к
нему описаны две функции. Первая традиционно возвращает <tt>std::string</tt>,
вторая – <tt>string_ref</tt>. При доступе через первую функцию каждый раз
создаётся временная строка, при доступе через первую – просто возвращается
ссылка.</p>

<p>Другой сценарий использования – это входной аргумент, строка используемая
только для чтения. Класс - универсальная замена для <tt>const std::string
&amp;</tt>. В большинстве случаев он также может быть использован вместо
<tt>const char *</tt>. Накладными расходами в этом случае будет проход по
строке в поисках NULL-терминатора, который всё равно нужно сделать в случаях,
когда в любом случае нужен конец строки или её длина. Рассмотрим три набора
перегруженных функций:</p>

<pre class="code">
void f1(const std::string &amp; );

void f2(const std::string &amp; );
void f2(const char * );

void f3(string_ref );
</pre>

<p>Каждый из них может быть использован как</p>

<pre class="code">
fx("Nul-terminated string");
</pre>

<p>так и как</p>

<pre class="code">
fx(std::string("std::string"));
</pre>

<p>Но в случае с <tt>f1()</tt> в первом случае будет лишнее копирование строки
в кучу только для того чтобы его прочитать. В случае с <tt>f2()</tt> нужно
писать несколько перегрузок функции, и если с одним аргументом это не является
сильно утруждающим, то при увеличении их количества количество комбинаций
сильно увеличивается. Последний вариант с <tt>f3()</tt> является таким же
удобным и универсальным, как с <tt>f1()</tt>, но при этом он более
«дружественный» к строковым литералам и строкам из мира C – копирования их в
динамическую память и превращения в <tt>std::string</tt> не происходит.</p>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">basic_string_ref()</pre>
<blockquote>

<div>
<u>Постусловие</u>: <tt>empty() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">basic_string_ref(const charT *str)</pre>
<pre class="prototype">template&lt;class Traits, class Alloc&gt;
basic_string_ref(const std::basic_string&lt;charT,Traits,Alloc&gt; &amp;str)</pre>
<blockquote>


<p>Создают ссылку на <tt>str</tt>.</p>
<div>
<u>Постусловие</u>: <tt>*this == str</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">basic_string_ref(const charT *chars, size_t n)</pre>
<pre class="prototype">basic_string_ref(const charT *begin, const charT *end)</pre>
<pre class="prototype">basic_string_ref(const charT *chars, size_t n)</pre>
<pre class="prototype">basic_string_ref(
    typename std::basic_string&lt;charT&gt;::const_iterator begin,
    typename std::basic_string&lt;charT&gt;::const_iterator end)</pre>
<pre class="prototype">basic_string_ref(std::initializer_list&lt;charT&gt; ) <span class="sign">[C++11]</span></pre>
<blockquote>





<p>Создают ссылку на диапазон символов.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class Traits&gt;
basic_string_ref(std::basic_string_view&lt;charT,Traits&gt; s) <span class="sign">[C++17]</span></pre>
<pre class="prototype">operator std::basic_string_view&lt;charT&gt;() const <span class="sign">[C++17]</span></pre>
<blockquote>


<p>Преобразователи из/в <tt>std::basic_string_view</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">iterator begin() const</pre>
<pre class="prototype">iterator cbegin() const</pre>
<pre class="prototype">const charT *data() const</pre>
<blockquote>



<p>Начало диапазона символов.</p>
</blockquote>
</div>

<div>
<pre class="prototype">iterator end() const</pre>
<pre class="prototype">iterator cend() const</pre>
<blockquote>


<p>Конец диапазона символов.</p>
</blockquote>
</div>

<div>
<pre class="prototype">charT front() const</pre>
<pre class="prototype">charT back() const</pre>
<blockquote>


<p>Первый и последний символ диапазона, соответственно.</p>
<div>
<u>Предусловие</u>: <tt>!empty()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">charT operator[](size_t i) const</pre>
<blockquote>

<p><tt>i</tt>-й символ строки.</p>
<div>
<u>Предусловие</u>: <tt>i &lt; length()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool empty() const</pre>
<blockquote>

<p>Возвращает <tt>begin() == end()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">size_t size() const</pre>
<pre class="prototype">size_t length() const</pre>
<blockquote>


<p>Длина строки.</p>
</blockquote>
</div>

<div>
<pre class="prototype">int compare(basic_string_ref s) const</pre>
<blockquote>

<p>Сравнивает строку с <tt>s</tt>. Возвращаемые значения аналогичны
<tt>std::string::compare()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">std::basic_string&lt;charT&gt; str() const</pre>
<pre class="prototype">template&lt;class Traits&gt;
std::basic_string&lt;charT,Traits&gt; str() const</pre>
<pre class="prototype">template&lt;class Traits, class Alloc&gt;
std::basic_string&lt;charT,Traits,Alloc&gt; str(const Alloc &amp;a = Alloc()) const</pre>
<blockquote>



<p>Явный преобразователь в <tt>std::basic_string</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">operator std::basic_string&lt;charT&gt;() const</pre>
<blockquote>

<p>Неявный преобразователь в <tt>std::basic_string</tt>.</p>
</blockquote>
</div>



<div class="section">Свободные функции</div>

<div>
<pre class="prototype">template&lt;class charT&gt;
bool operator==(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2)</pre>
<pre class="prototype">template&lt;class charT&gt;
bool operator!=(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2)</pre>
<pre class="prototype">template&lt;class charT&gt;
bool operator&lt;(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2)</pre>
<pre class="prototype">template&lt;class charT&gt;
bool operator&gt;(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2)</pre>
<pre class="prototype">template&lt;class charT&gt;
bool operator&lt;=(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2)</pre>
<pre class="prototype">template&lt;class charT&gt;
bool operator&gt;=(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2)</pre>
<blockquote>






<p>Полный набор операторов сравнения.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class charT, class Traits&gt;
std::basic_ostream&lt;charT,Traits&gt; &amp;operator&lt;&lt;(
    std::basic_ostream&lt;charT,Traits&gt; &amp;os, const basic_string_ref&lt;charT&gt; &amp;sr)</pre>
<blockquote>

<p>Инсертер в стандартный выходной поток. Определён (а также
<tt>&lt;ostream&gt;</tt> включён) только, если определён макрос
<tt>__VIC_DEFINE_OSTREAM_INSERTERS</tt> перед включением.</p>
</blockquote>
</div>



<div class="section">Пример</div>
<pre class="code">
C c; // описание класса см. выше
__vic::string_ref s = c. get_v_2();

// печать строки разными способами
for(__vic::string_ref::iterator it = s.begin(); it != s.end(); ++it)
    std::cout &lt;&lt; *it;

// C++11
for(auto ch : s) std::cout &lt;&lt; ch;

std::copy(s.begin(), s.end(), std::ostream_iterator&lt;char&gt;(std::cout));

std::cout &lt;&lt; s;

// автоматическое преобразование в std::string
std::string ss = s;
</pre>






<h2 id="string_utils.h">
<span class="h2_num">2.27</span><tt>__vic/string_utils.h</tt>
</h2>


<p>Различные утилиты для работы со строками.</p>


<h3 id="trim">
<span class="h3_num">2.27.1</span>Набор функций <tt>trim</tt>
</h3>


<pre class="code">
char *trim(char *str);
char *trim_front(char *str);
char *trim_back(char *str);
char *trim(char *str, char ch);
char *trim_front(char *str, char ch);
char *trim_back(char *str, char ch);
char *trim(char *str, const char *set);
char *trim_front(char *str, const char *set);
char *trim_back(char *str, const char *set);

std::string &amp;trim(std::string &amp;str);
std::string &amp;trim_front(std::string &amp;str);
std::string &amp;trim_back(std::string &amp;str);
std::string &amp;trim(std::string &amp;str, char ch);
std::string &amp;trim_front(std::string &amp;str, char ch);
std::string &amp;trim_back(std::string &amp;str, char ch);
std::string &amp;trim(std::string &amp;str, const char *set);
std::string &amp;trim_front(std::string &amp;str, const char *set);
std::string &amp;trim_back(std::string &amp;str, const char *set);

std::string trimmed(const std::string &amp;str);
std::string trimmed_front(const std::string &amp;str);
std::string trimmed_back(const std::string &amp;str);
std::string trimmed(const std::string &amp;str, char ch);
std::string trimmed_front(const std::string &amp;str, char ch);
std::string trimmed_back(const std::string &amp;str, char ch);
std::string trimmed(const std::string &amp;str, const char *set);
std::string trimmed_front(const std::string &amp;str, const char *set);
std::string trimmed_back(const std::string &amp;str, const char *set);
</pre>

<p>Набор функций, обрезающих нежелательные символы по краям строки. Обрезаемые
символы можно задавать. Задать можно как одиночный символ <tt>ch</tt>, так и
набор <tt>set</tt>. Если набор не задан, то подразумеваются все пробельные
ASCII-символы. Используются следующие правила именования:</p>
<ul>
<li>
<tt>trim</tt> – обрезает строку с обоих концов,</li>
<li>
<tt>trim_front</tt> – обрезает строку в начале,</li>
<li>
<tt>trim_back</tt> – обрезает строку в конце.</li>
</ul>

<p>Функции <tt>trim</tt> модифицируют переданную строку и возвращают указатель
или ссылку на неё. Если это по каким-то причинам нежелательно, то следует
использовать набор функций <tt>trimmed</tt>.</p>
<ul><li>
<tt>trimmed</tt> – возвращает обрезанную строку в качестве выходного
        значения, не модифицируя входной параметр.</li></ul>

<p>Реализация функций <tt>trim</tt> выполнена с расчётом, что у строки может
не быть символов, подлежащих обрезанию. В подобных случаях никаких модификаций
не производится, и функция возвращает управление сразу после проверки. С точки
зрения эффективности, затраты на такие вызовы минимальны.</p>

<p>Все значения <tt>nullptr</tt> воспринимаются как пустая строка.</p>

<div class="section">Примеры</div>
<pre class="code">
char st1[] = "\t value    \n";

// CHOICE:
__vic::trim(st1);       // result: "value"
__vic::trim_front(st1); // result: "value    \n"
__vic::trim_back(st1);  // result: "\t value"

std::string st2("...value123");

// CHOICE:
// trim dot chars
__vic::trim_front(st1, '.');        // result: "value123"
// trim all digits
__vic::trim_back(st1, "123456789"); // result: "...value"
</pre>





<h3 id="sift">
<span class="h3_num">2.27.2</span><tt>sift()</tt>
</h3>


<pre class="code">
char *sift(char *str, const char *trash_chars);
std::string &amp;sift(std::string &amp;str, const char *trash_chars);
</pre>

<p>Удаляет из строки все символы из указанного набора. Все значения
<tt>nullptr</tt> воспринимаются как пустая строка.</p>

<div class="section">Пример</div>
<pre class="code">
char st[] = "..ab.c..d.e.";
__vic::sift(st, ".");
assert(std::strcmp(st, "abcde") == 0);
</pre>





<h3 id="sift_if">
<span class="h3_num">2.27.3</span><tt>sift_if()</tt>
</h3>


<pre class="code">
template&lt;class Pred&gt;
char *sift(char *str, Pred pred);
template&lt;class Pred&gt;
std::string &amp;sift(std::string &amp;str, Pred pred);
</pre>

<p>Удаляет из строки все символы, удовлетворяющие предикату <tt>pred</tt>.
Все значения <tt>nullptr</tt> воспринимаются как пустая строка.</p>




<h3 id="pad_front">
<span class="h3_num">2.27.4</span><tt>pad_front()</tt>
</h3>


<pre class="code">
std::string &amp;pad_front(std::string &amp;str, size_t size, char pad_ch = ' ');
char *pad_front(char *str, size_t size, char pad_ch = ' ');
</pre>

<p>Дополняет строку до длины <tt>size</tt> в начале символами
<tt>pad_ch</tt>. Ничего не происходит, если строка уже имеет длину
<tt>size</tt> или большую, либо указатель - null. Возвращает <tt>str</tt>.</p>




<h3 id="pad_back">
<span class="h3_num">2.27.5</span><tt>pad_back()</tt>
</h3>


<pre class="code">
std::string &amp;pad_back(std::string &amp;str, size_t size, char pad_ch = ' ');
char *pad_back(char *str, size_t size, char pad_ch = ' ');
</pre>

<p>Дополняет строку до длины <tt>size</tt> в конце символами
<tt>pad_ch</tt>. Ничего не происходит, если строка уже имеет длину
<tt>size</tt> или большую, либо указатель - null. Возвращает <tt>str</tt>.</p>




<h3 id="starts_with">
<span class="h3_num">2.27.6</span><tt>starts_with()</tt>
</h3>


<pre class="code">
bool starts_with(const char *s, char pref);
bool starts_with(const char *s, const char *pref);
bool starts_with(const char *s, const char *pref, size_t pref_len);

#if __cpp_lib_string_view // C++17
bool starts_with(std::string_view s, char pref);
bool starts_with(std::string_view s, std::string_view pref);
bool starts_with(std::string_view s, const char *pref);
#else // until C++17
bool starts_with(const std::string &amp;s, char pref);
bool starts_with(const std::string &amp;s, const char *pref);
bool starts_with(const std::string &amp;s, const std::string &amp;pref);
bool starts_with(const std::string &amp;s, const char *pref, size_t pref_len);
#endif

bool starts_with(const char *s, size_t s_len, char pref);
bool starts_with(const char *s, size_t s_len, const char *pref);
bool starts_with(const char *s, size_t s_len, const char *pref, size_t pref_len);
</pre>

<p>Возвращает <tt>true</tt>, если строка <tt>s</tt> начинается с указанного
префикса.</p>




<h3 id="ends_with">
<span class="h3_num">2.27.7</span><tt>ends_with()</tt>
</h3>


<pre class="code">
#if __cpp_lib_string_view // C++17
bool ends_with(std::string_view s, char suff);
bool ends_with(std::string_view s, std::string_view suff);
#else // until C++17
bool ends_with(const char *s, char suff);
bool ends_with(const char *s, const char *suff);
bool ends_with(const char *s, const char *suff, size_t suff_len);
bool ends_with(const char *s, size_t s_len, const char *suff);

bool ends_with(const std::string &amp;s, char suff);
bool ends_with(const std::string &amp;s, const char *suff);
bool ends_with(const std::string &amp;s, const std::string &amp;suff);
bool ends_with(const std::string &amp;s, const char *suff, size_t suff_len);
#endif

bool ends_with(const char *s, size_t s_len, char suff);
bool ends_with(const char *s, size_t s_len, const char *suff, size_t suff_len);
</pre>

<p>Возвращает <tt>true</tt>, если строка <tt>s</tt> оканчивается указанным
суффиксом.</p>






<h2 id="tchar.h">
<span class="h2_num">2.28</span><tt>__vic/tchar.h</tt>
</h2>


<p>Обобщенные (generic) функции для манипуляции С-строками независимо от
используемого ими типа символов, подобно <tt>std::char_traits&lt;&gt;</tt>.
Использование данных функций в шаблонах нередко значительно сокращает
потребность в написании специализаций для различных типов символов.</p>

<p>Все функции находятся в пространстве имён <tt>__vic::tchar</tt>.</p>

<p>Большинство функций являются просто обобщёнными обёртками для функций,
вроде <tt>strcpy</tt>, <tt>wcscpy</tt> и т.п. Поисковые функции имеют более
осмысленные имена, чем их аналоги в билиотеке C, и унифицированные параметры:
они всегда принимают указатели и никогда индексы. Также набор функций дополнен
«логически симметричными», но отсутствующими в стандартной билиотеке.
Поисковые функции возвращают <tt>nullptr</tt> в случае неудачи.</p>

<div class="section">Пример</div>
<pre class="code">
template&lt;class charT&gt;
charT *generic_dup(const charT *st)
{
    namespace tchar = __vic::tchar;

    charT *st_copy = new charT[tchar::length(st) + 1];
    tchar::copy(st_copy, st);
    return st_copy;
}
</pre>



<h3 id="tchar--length">
<span class="h3_num">2.28.1</span><tt>tchar::length()</tt>
</h3>


<pre class="code">
template&lt;class charT&gt;
size_t tchar::length(const charT *str);
</pre>

<p>Длина строки в элементах. Обобщённый <tt>strlen</tt> / <tt>wcslen</tt>.</p>




<h3 id="tchar--empty">
<span class="h3_num">2.28.2</span><tt>tchar::empty()</tt>
</h3>


<pre class="code">
template&lt;class charT&gt;
bool tchar::empty(const charT *str);
</pre>

<p>Проверяет, является ли <tt>str</tt> <tt>nullptr</tt> или пустой строкой.</p>




<h3 id="tchar--end">
<span class="h3_num">2.28.3</span><tt>tchar::end()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT&gt;
const charT *end(const charT *str);

template&lt;class charT&gt;
charT *end(charT *str);

}
</pre>

<p>Указатель на NULL-терминатор. Обобщённый <tt>strchr(str, '\0')</tt> /
<tt>wcschr(str, L'\0')</tt>.</p>

<div>
<u><b>Замечание</b></u>: Некоторые «кривые» реализации <tt>std::strchr()</tt>, например в  MinGW,
возвращают неконстантный <tt>char *</tt>, даже если аргумент - <tt>const char
*</tt>. В связи с этим, данные функции могут быть использованы как обход
данной проблемы.</div>




<h3 id="tchar--compare">
<span class="h3_num">2.28.4</span><tt>tchar::compare()</tt>
</h3>


<pre class="code">
template&lt;class charT&gt;
int tchar::compare(const charT *str1, const charT *str2);
</pre>

<p>Сравнивает две строки. Обобщённый <tt>strcmp</tt> / <tt>wcscmp</tt>.</p>




<h3 id="tchar--equal">
<span class="h3_num">2.28.5</span><tt>tchar::equal()</tt>
</h3>


<pre class="code">
template&lt;class charT&gt;
bool tchar::equal(const charT *str1, const charT *str2);
</pre>

<p>Проверяет двестроки на равенство.</p>

<div>
<u>Предусловие</u>: <tt>str1 != nullptr &amp;&amp; str2 != nullptr</tt>
</div>




<h3 id="tchar--copy">
<span class="h3_num">2.28.6</span><tt>tchar::copy()</tt>
</h3>


<pre class="code">
template&lt;class charT&gt;
charT *tchar::copy(charT *dest, const charT *src);
</pre>

<p>Копирует строку. Обобщённый <tt>strcpy</tt> / <tt>wcscpy</tt>.</p>




<h3 id="tchar--move">
<span class="h3_num">2.28.7</span><tt>tchar::move()</tt>
</h3>


<pre class="code">
template&lt;class charT&gt;
charT *tchar::move(charT *dest, const charT *src);
</pre>

<p>Сдвигает строку в памяти (<tt>memmove</tt>).</p>




<h3 id="tchar--concat">
<span class="h3_num">2.28.8</span><tt>tchar::concat()</tt>
</h3>


<pre class="code">
template&lt;class charT&gt;
charT *tchar::concat(charT *dest, const charT *src);
</pre>

<p>Конкатенирует две строки. Обобщённый <tt>strcat</tt> / <tt>wcscat</tt>.</p>




<h3 id="tchar--find">
<span class="h3_num">2.28.9</span><tt>tchar::find()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT&gt;
const charT *find(const charT *str, charT ch);

template&lt;class charT&gt;
charT *find(charT *str, charT ch);

template&lt;class charT&gt;
const charT *find(const charT *str, const charT *sub);

template&lt;class charT&gt;
charT *find(charT *str, const charT *sub);

}
</pre>

<p>Ищет первое вхождение символа или подстроки. Обобщённые
<tt>strchr</tt> / <tt>wcschr</tt> / <tt>strstr</tt> / <tt>wcsstr</tt>.</p>




<h3 id="tchar--rfind">
<span class="h3_num">2.28.10</span><tt>tchar::rfind()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT&gt;
const charT *rfind(const charT *str, charT ch);

template&lt;class charT&gt;
charT *rfind(charT *str, charT ch);

}
</pre>

<p>Ищет последнее вхождение символа. Обобщённые <tt>strrchr</tt> /
<tt>wcsrchr</tt>.</p>




<h3 id="tchar--find_if">
<span class="h3_num">2.28.11</span><tt>tchar::find_if()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT, class Pred&gt;
const charT *find_if(const charT *str, Pred pred);

template&lt;class charT, class Pred&gt;
charT *find_if(charT *str, Pred pred);

}
</pre>

<p>Ищет первое вхождение символа, удовлетворяющего указанному предикату.</p>




<h3 id="tchar--find_if_not">
<span class="h3_num">2.28.12</span><tt>tchar::find_if_not()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT, class Pred&gt;
const charT *find_if_not(const charT *str, Pred pred);

template&lt;class charT, class Pred&gt;
charT *find_if_not(charT *str, Pred pred);

}
</pre>

<p>Ищет первое вхождение символа, не удовлетворяющего указанному предикату.</p>




<h3 id="tchar--rfind_if">
<span class="h3_num">2.28.13</span><tt>tchar::rfind_if()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT, class Pred&gt;
const charT *rfind_if(const charT *str, Pred pred);

template&lt;class charT, class Pred&gt;
charT *rfind_if(charT *str, Pred pred);

}
</pre>

<p>Ищет последнее вхождение символа, удовлетворяющего указанному предикату.</p>




<h3 id="tchar--rfind_if_not">
<span class="h3_num">2.28.14</span><tt>tchar::rfind_if_not()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT, class Pred&gt;
const charT *rfind_if_not(const charT *str, Pred pred);

template&lt;class charT, class Pred&gt;
charT *rfind_if_not(charT *str, Pred pred);

}
</pre>

<p>Ищет последнее вхождение символа, не удовлетворяющего указанному предикату.
</p>




<h3 id="tchar--find_first_of">
<span class="h3_num">2.28.15</span><tt>tchar::find_first_of()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT&gt;
const charT *find_first_of(const charT *str, const charT *set);

template&lt;class charT&gt;
charT *find_first_of(charT *str, const charT *set);

}
</pre>

<p>Ищет первое вхождение символа из указанного набора. Обобщённый
<tt>strpbrk</tt> / <tt>wcspbrk</tt>.</p>




<h3 id="tchar--find_first_not_of">
<span class="h3_num">2.28.16</span><tt>tchar::find_first_not_of()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT&gt;
const charT *find_first_not_of(const charT *str, const charT *set);

template&lt;class charT&gt;
charT *find_first_not_of(charT *str, const charT *set);

}
</pre>

<p>Ищет первое вхождение символа, отсутствующего в указанном наборе.
Обобщённый <tt>strspn</tt> / <tt>wcsspn</tt>.</p>




<h3 id="tchar--find_last_of">
<span class="h3_num">2.28.17</span><tt>tchar::find_last_of()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT&gt;
const charT *find_last_of(const charT *str, const charT *set);

template&lt;class charT&gt;
charT *find_last_of(charT *str, const charT *set);

}
</pre>

<p>Ищет последнее вхождение символа из указанного набора.</p>




<h3 id="tchar--find_last_not_of">
<span class="h3_num">2.28.18</span><tt>tchar::find_last_not_of()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT&gt;
const charT *find_last_not_of(const charT *str, const charT *set);

template&lt;class charT&gt;
charT *find_last_not_of(charT *str, const charT *set);

}
</pre>

<p>Ищет последнее вхождение символа, отсутсвующего в указанном наборе.</p>




<h3 id="tchar--skip">
<span class="h3_num">2.28.19</span><tt>tchar::skip()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT&gt;
const charT *skip(const charT *str, charT ch);

template&lt;class charT&gt;
charT *skip(charT *str, charT ch);

}
</pre>

<p>Пропускает все вхождения указанного символа и возвращает указатель.
Если другие символы в строке отсутствуют, возвращает указатель на
NULL-терминатор.</p>






<h2 id="thread.h">
<span class="h2_num">2.29</span><tt>__vic/thread.h</tt>
</h2>


<p>Поддержка вычислительных потоков.</p>


<h3 id="thread">
<span class="h3_num">2.29.1</span><tt>thread</tt>
</h3>


<pre class="code">
class thread : private non_copyable
{
public:
    class id;
    using native_handle_type = <span class="nonterminal">&lt;implementation-defined&gt;</span>;

    thread();
    virtual ~thread();

    // BEGIN C++11
    thread(thread &amp;&amp;o) noexcept;
    thread &amp;operator=(thread &amp;&amp;o) noexcept;
    // END C++11

    void start();
    void cancel();
    void join();

    bool alive() const;
    bool joinable() const;
    void kill(int signo); // POSIX only

    id get_id() const;
    native_handle_type handle() const;
protected:
    virtual void worker() = 0;
};
</pre>

<p>Абстрактный базовый класс потоков. Реализует pattern «Active object».
Унаследуйте данный класс и определите функцию <tt>worker()</tt>, содержимое
которой будет выполнено в новом потоке после вызова <tt>start()</tt>. Затем
где-то в Вашей программе Вы должны будете вызвать <tt>join()</tt> для
освобождения ресурсов ОС, ассоциированных с порождённым потоком.</p>

<div>
<u><b>Замечание</b></u>: Объект должен всегда жить дольше, чем ассоциированный с ним поток ОС.
Если это соглашение будет нарушено, программа будет завершена вызовом
<tt>std::terminate()</tt>.</div>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">thread()</pre>
<blockquote>

<div>
<u>Постусловие</u>: <tt>joinable() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">~thread()</pre>
<blockquote>

<p>Вызывает <tt>std::terminate()</tt>, если нарушено предусловие.</p>
<div>
<u>Предусловие</u>: <tt>joinable() == false || alive() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">thread(thread &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Перемещающий конструктор для режима C++11.</p>
</blockquote>
</div>

<div>
<pre class="prototype">thread &amp;operator=(thread &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Перемещающее присваивание для режима C++11. Вызывает
<tt>std::terminate()</tt>, если нарушено предусловие.</p>
<div>
<u>Предусловие</u>: <tt>joinable() == false || alive() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void start()</pre>
<blockquote>

<p>Порождает новый поток и вызывает в нём <tt>worker()</tt>.</p>
<div>
<u>Предусловие</u>: <tt>joinable() == false</tt>
</div>
<div>
<u>Постусловие</u>: <tt>joinable() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void cancel()</pre>
<blockquote>

<p>Прерывает выполнение потока.</p>
<div>
<u>Предусловие</u>: <tt>joinable() == true</tt>
</div>
<div>
<u>Постусловие</u>: <tt>joinable() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void join()</pre>
<blockquote>

<p>Ждёт завершения работы потока, если он выполняется в данный момент, и делает
его <tt>joinable() == false</tt>.</p>
<div>
<u>Предусловие</u>: <tt>joinable() == true</tt>
</div>
<div>
<u>Постусловие</u>: <tt>joinable() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool alive() const</pre>
<blockquote>

<p>Возращает <tt>true</tt>, если выполнение потока ещё не завершилось
(он находится в функции <tt>worker()</tt>).</p>
<div>
<u>Предусловие</u>: <tt>joinable() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool joinable() const</pre>
<blockquote>

<p>Возвращает <tt>true</tt>, если объект имеет соответсвующий объект ОС
(поток), созданный вызовом <tt>start()</tt> и ещё не уничтоженный вызовом
<tt>join()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void kill(int signo) <span class="sign">[POSIX]</span></pre>
<blockquote>

<p>Посылает сигнал потоку сигнал <tt>signo</tt>.</p>
<div>
<u>Предусловие</u>: <tt>joinable() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">id get_id() const</pre>
<blockquote>

<p>Возвращает ID потока.</p>
</blockquote>
</div>

<div>
<pre class="prototype">native_handle_type handle() const</pre>
<blockquote>

<p>Возвращает дескриптор потока, используемый в данной ОС.</p>
</blockquote>
</div>






<h3 id="thread--id">
<span class="h3_num">2.29.2</span><tt>thread::id</tt>
</h3>


<pre class="code">
class thread::id
{
public:
    id();
    explicit operator bool() const;
    native_handle_type handle() const;
};
bool operator==(thread::id a, thread::id b);
bool operator!=(thread::id a, thread::id b);
</pre>

<p>Уникальный идентификатор потока. Может содержать значение, ассоциированное
с потоком или специальное значение, не ассоциированное ни с одним потоком.</p>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">id()</pre>
<blockquote>

<p>Создаёт специальное значение не ассоциированное ни с одним потоком.</p>
<div>
<u>Постусловие</u>: <tt>bool(*this) == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">explicit operator bool() const</pre>
<blockquote>

<p>Возвращает <tt>true</tt>, если объект хранит ID какого-то потока.</p>
</blockquote>
</div>

<div>
<pre class="prototype">native_handle_type handle() const</pre>
<blockquote>

<p>Возвращает дескриптор потока, используемый в данной ОС.</p>
<div>
<u>Предусловие</u>: <tt>bool(*this) == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool operator==(thread::id a, thread::id b)</pre>
<pre class="prototype">bool operator!=(thread::id a, thread::id b)</pre>
<blockquote>


<p>Проверяет, ассоциированы ли <tt>a</tt> и <tt>b</tt> с одним и тем же
потоком (либо оба содержат значение по умолчанию).</p>
<div>
<u>Инвариант</u>: <tt>id() == id()</tt>
</div>
</blockquote>
</div>






<h3 id="this_thread">
<span class="h3_num">2.29.3</span><tt>this_thread</tt>
</h3>


<pre class="code">
namespace this_thread
{
    thread::id get_id();
    void sleep_ms(unsigned msec);
}
</pre>

<p>Набор функций для манипуляции с текущим (вызывающим) потоком.</p>

<div>
<pre class="prototype">thread::id get_id()</pre>
<blockquote>

<p>Возвращает ID вызывающего потока.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void sleep_ms(unsigned msec)</pre>
<blockquote>

<p>Приостанавливает выполнение вызывающего потока на указанное время в
миллисекундах.</p>
</blockquote>
</div>






<h2 id="throw_errno.h">
<span class="h2_num">2.30</span><tt>__vic/throw_errno.h</tt>
</h2>


<h3 id="throw_errno">
<span class="h3_num">2.30.1</span><tt>throw_errno()</tt>
</h3>


<pre class="code">
[[noreturn]] void throw_errno(const char *prompt);
[[noreturn]] void throw_errno(const char *prompt, int err_no);
</pre>

<p>Бросает исключение, содержащее глобальное значение <tt>errno</tt> или
данное <tt>err_no</tt>, соответственно. По умолчанию в данный момент типом
исключения будет <a href="#libc_error"><tt>libc_error</tt></a>, однако это можно изменить во время
компоновки переопределением данных функций. Например, можно использовать
<tt>std::system_error</tt>. Для этого просто создайте cpp-файл со следующим
содержимым в своём проекте:</p>

<pre class="code">
#include&lt;__vic/throw_errno.h&gt;
#include&lt;system_error&gt;

//----------------------------------------------------------------------------
// Override library functions to throw std::system_error
//----------------------------------------------------------------------------
void __vic::throw_errno(const char *prompt, int err_no)
{
    throw std::system_error(err_no, std::system_category(), prompt);
}
//----------------------------------------------------------------------------
</pre>

<p>Переопределения одной функции достаточно, так как вторая просто вызывает
<tt>throw_errno(prompt, errno)</tt>.</p>

<div class="section">Пример</div>
<pre class="code">
ssize_t written = ::write(fd, buf, buf_size);
if(written &lt; 0) __vic::throw_errno("write");
// ...
</pre>






<h2 id="to_text.h">
<span class="h2_num">2.31</span><tt>__vic/to_text.h</tt>
</h2>


<p>Generic преобразователи в текстовое представление.</p>


<h3 id="to_text_append">
<span class="h3_num">2.31.1</span><tt>to_text_append()</tt>
</h3>


<pre class="code">
void to_text_append(long long n, std::string &amp;str);
void to_text_append(long n, std::string &amp;str);
void to_text_append(int n, std::string &amp;str);
void to_text_append(short n, std::string &amp;str);
void to_text_append(signed char n, std::string &amp;str);

void to_text_append(unsigned long long n, std::string &amp;str);
void to_text_append(unsigned long n, std::string &amp;str);
void to_text_append(unsigned n, std::string &amp;str);
void to_text_append(unsigned short n, std::string &amp;str);
void to_text_append(unsigned char n, std::string &amp;str);

void to_text_append(long double n, std::string &amp;str);
void to_text_append(double n, std::string &amp;str);
void to_text_append(float n, std::string &amp;str);

void to_text_append(bool f, std::string &amp;str);

void to_text_append(const void *p, std::string &amp;str);

void to_text_append(const std::string &amp;st, std::string &amp;s);
void to_text_append(const char *st, std::string &amp;s);
void to_text_append(char ch, std::string &amp;s);

#if __cpp_lib_string_view // C++17
void to_text_append(std::string_view sv, std::string &amp;s);
#endif
</pre>

<p>Преобразует первый аргумент в некоторое текстовое представление и добавляет
его ко второму аргументу.</p>

<p>Данная функция являет собой customization point (подобно <tt>std::swap</tt>)
для библиотеки. Пользователи могут определять перегрузки для своих типов (в том
же самом namespace, где определён тип), чтобы "научить" библиотеку как создавать
текст из значения указанного типа.</p>

<div>
<u><b>Замечание</b></u>: Это не замена таким имеющим богатые возможности инструментам, как
<tt>std::format</tt> или <tt>std::sprintf</tt>. К примеру, нет возможности
представить целочисленное значение в HEX или выровнять его по правому краю при
указанной ширине. Главное назначение - это возможность представить значение в
виде текста в понятной человеку форме в отладочных сообщениях, логах, сообщениях
об ошибках.</div>

<div>
<u><b>Замечание</b></u>: Типы <tt>signed char</tt> и <tt>unsigned char</tt> воспринимаются как
целые, а не символы!</div>

<div>
<pre class="prototype">void to_text_append(long long n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(long n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(int n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(short n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(signed char n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(unsigned long long n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(unsigned long n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(unsigned n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(unsigned short n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(unsigned  char n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(long double n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(double n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(float n, std::string &amp;str)</pre>
<blockquote>













<p>Преобразуют число в десятичное представление.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void to_text_append(bool f, std::string &amp;str)</pre>
<blockquote>

<p>Преобразует булев тип в <tt>0</tt> или <tt>1</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void to_text_append(const void *p, std::string &amp;str)</pre>
<blockquote>

<p>Преобразует указатель в некоторое платформо-специфичное представление.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void to_text_append(const std::string &amp;st, std::string &amp;s)</pre>
<pre class="prototype">void to_text_append(const char *st, std::string &amp;s)</pre>
<pre class="prototype">void to_text_append(char ch, std::string &amp;s)</pre>
<pre class="prototype">void to_text_append(std::string_view sv, std::string &amp;s) <span class="sign">[C++17]</span></pre>
<blockquote>




<p>Добавляет указанную строку или символ к выходной строке.</p>
<div>
<u>Замечание</u>: Значение <tt>nullptr</tt> в перегрузке, принимающей <tt>const char *</tt>,
считается пустой строкой.</div>
</blockquote>
</div>

<div class="section">Пример</div>
<pre class="code">
int n = 5;
std::string st = "n = ";
__vic::to_text_append(n, st);
assert(st == "n = 5");
</pre>






<h2 id="type_traits.h">
<span class="h2_num">2.32</span><tt>__vic/type_traits.h</tt>
</h2>


<p>Поддержка метапрограммирования с помощью шаблонов.</p>
<p>Все метафункции-предикаты имеют член в виде булевой статической константы
по имени <tt>value</tt> и, как правило, порождены от
<tt>integral_constant</tt>.</p>
<p>Все метафункции-преобразователи типов имеют член-тип по имени <tt>type</tt>,
являющийся результатом преобразования.</p>
<p>Все шаблонные псевдонимы доступны только в режиме C++11.</p>


<h3 id="integral_constant">
<span class="h3_num">2.32.1</span><tt>integral_constant</tt>
</h3>


<pre class="code">
template&lt;class T, T Val&gt;
struct integral_constant
{
    using value_type = T;
    using type = integral_constant&lt;T, Val&gt;;

    static constexpr T value = Val;
};
</pre>

<p>Базовый класс большиства метафункций с <tt>value</tt>.</p>




<h3 id="true_type">
<span class="h3_num">2.32.2</span><tt>true_type</tt>
</h3>


<pre class="code">
using true_type = integral_constant&lt;bool, true&gt;;
</pre>

<p>Базовый класс метафункций-предикатов со значением <tt>true</tt>.</p>




<h3 id="false_type">
<span class="h3_num">2.32.3</span><tt>false_type</tt>
</h3>


<pre class="code">
using false_type = integral_constant&lt;bool, false&gt;;
</pre>

<p>Базовый класс метафункций-предикатов со значением <tt>false</tt>.</p>




<h3 id="is_same">
<span class="h3_num">2.32.4</span><tt>is_same</tt>
</h3>


<pre class="code">
template&lt;class T1, class T2&gt; struct is_same;
</pre>

<p>Предикат. Истинен, если <tt>T1</tt> и <tt>T2</tt> - это в точности один и
тот же тип.</p>




<h3 id="is_const">
<span class="h3_num">2.32.5</span><tt>is_const</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct is_const;
</pre>

<p>Предикат. Истинен, если <tt>T</tt> имеет квалификатор <tt>const</tt>.</p>




<h3 id="is_signed_integer">
<span class="h3_num">2.32.6</span><tt>is_signed_integer</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct is_signed_integer;
</pre>

<p>Предикат. Истинен, если <tt>T</tt> - «стандартный целый тип со знаком»
(см. Стандарт).</p>




<h3 id="is_unsigned_integer">
<span class="h3_num">2.32.7</span><tt>is_unsigned_integer</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct is_unsigned_integer;
</pre>

<p>Предикат. Истинен, если <tt>T</tt> - «стандартный целый беззнаковый тип»
(см. Стандарт).</p>




<h3 id="conjunction">
<span class="h3_num">2.32.8</span><tt>conjunction</tt> <span class="sign">[C++11]</span>
</h3>


<pre class="code">
template&lt;class... B&gt; struct conjunction;
</pre>

<p>Предикат. Конъюнкция предикатов <tt>B...</tt>. Ложен тогда и только тогда,
когда ложен один из <tt>B...</tt>.</p>




<h3 id="disjunction">
<span class="h3_num">2.32.9</span><tt>disjunction</tt> <span class="sign">[C++11]</span>
</h3>


<pre class="code">
template&lt;class... B&gt; struct disjunction;
</pre>

<p>Предикат. Дизъюнкция предикатов <tt>B...</tt>. Истинен тогда и только тогда,
когда истинен один из <tt>B...</tt>.</p>




<h3 id="negation">
<span class="h3_num">2.32.10</span><tt>negation</tt>
</h3>


<pre class="code">
template&lt;class B&gt; struct negation;
</pre>

<p>Предикат. Логическое отрицание предиката <tt>B</tt>.</p>




<h3 id="remove_const">
<span class="h3_num">2.32.11</span><tt>remove_const</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct remove_const;
template&lt;class T&gt; using remove_const_t = typename remove_const&lt;T&gt;::type;
</pre>

<p>Преобразователь типа. Удаляет у типа самый верхний квалификатор
<tt>const</tt>, либо просто возвращает <tt>T</tt>, если такого квалификатора
нет.</p>




<h3 id="remove_volatile">
<span class="h3_num">2.32.12</span><tt>remove_volatile</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct remove_volatile;
template&lt;class T&gt; using remove_volatile_t = typename remove_volatile&lt;T&gt;::type;
</pre>

<p>Преобразователь типа. Удаляет у типа самый верхний квалификатор
<tt>volatile</tt>, либо просто возвращает <tt>T</tt>, если такого квалификатора
нет.</p>




<h3 id="remove_cv">
<span class="h3_num">2.32.13</span><tt>remove_cv</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct remove_cv;
template&lt;class T&gt; using remove_cv_t = typename remove_cv&lt;T&gt;::type;
</pre>

<p>Преобразователь типа. Удаляет у типа самые верхние квалификаторы
<tt>const</tt> и/или <tt>volatile</tt>, либо просто возвращает <tt>T</tt>,
если таких квалификаторов нет.</p>




<h3 id="remove_reference">
<span class="h3_num">2.32.14</span><tt>remove_reference</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct remove_reference;
template&lt;class T&gt; using remove_reference_t = typename remove_reference&lt;T&gt;::type;
</pre>

<p>Преобразователь типа. Возвращает тип, на который ссылается <tt>T</tt>, либо
просто возвращает <tt>T</tt>, если он не является ссылкой.</p>




<h3 id="remove_cvref">
<span class="h3_num">2.32.15</span><tt>remove_cvref</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct remove_cvref;
template&lt;class T&gt; using remove_cvref_t = typename remove_cvref&lt;T&gt;::type;
</pre>

<p>Преобразователь типа. Применяет <tt>remove_reference</tt>, затем
<tt>remove_cv</tt> к <tt>T</tt>.</p>




<h3 id="remove_pointer">
<span class="h3_num">2.32.16</span><tt>remove_pointer</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct remove_pointer;
template&lt;class T&gt; using remove_pointer_t = typename remove_pointer&lt;T&gt;::type;
</pre>

<p>Преобразователь типа. Возвращает тип, на который указывает <tt>T</tt>, либо
просто возвращает <tt>T</tt>, если он не является указателем.</p>




<h3 id="conditional">
<span class="h3_num">2.32.17</span><tt>conditional</tt>
</h3>


<pre class="code">
template&lt;bool Cond, class Then, class Else&gt; struct conditional;

template&lt;bool Cond, class Then, class Else&gt;
using conditional_t = typename conditional&lt;Cond, Then, Else&gt;;
</pre>

<p>Преобразователь типа. Возвращает <tt>Then</tt>, если <tt>Cond == true</tt>.
В противном случае - <tt>Else</tt>.</p>




<h3 id="enable_if">
<span class="h3_num">2.32.18</span><tt>enable_if</tt>, <tt>disable_if</tt>
</h3>


<pre class="code">
template&lt;bool Test, class T = void&gt;
struct enable_if
{
    using type = T;
};
template&lt;class T&gt;
struct enable_if&lt;false, T&gt; {};

template&lt;bool Test, class T = void&gt;
struct disable_if : enable_if&lt;!Test, T&gt; {};
</pre>

<p>Классические инструменты для фокусов со SFINAE.</p>




<h3 id="index_sequence">
<span class="h3_num">2.32.19</span><tt>index_sequence</tt>, <tt>make_index_sequence</tt> <span class="sign">[C++11]</span>
</h3>


<pre class="code">
template&lt;size_t... I&gt;
struct index_sequence
{
    static constexpr size_t size() { return sizeof...(I); }
};

template&lt;size_t Size&gt;
using make_index_sequence = index_sequence&lt;0, 1, ..., Size-1&gt;;
</pre>

<p>Реализация <tt>std::index_sequence</tt> из C++14 для C++11.</p>

<div>
<u><b>Замечание</b></u>: В отличие от <tt>std::index_sequence</tt>, не является специализацией
какого-то аналога <tt>std::integer_sequence</tt>.</div>






<h2 id="unicode.h">
<span class="h2_num">2.33</span><tt>__vic/unicode.h</tt>
</h2>


<p>Утилиты для поддержки <a href="https://www.unicode.org/">Unicode</a>.
</p>


<h3 id="unicode_t">
<span class="h3_num">2.33.1</span><tt>unicode_t</tt>
</h3>


<pre class="code">
using unicode_t = char32_t; // since C++11
// или
using unicode_t = uint_least32_t; // C++98
</pre>

<p>Тип, предназначениый для хранения Unicode
<a href="https://www.unicode.org/glossary/#code_point">code point</a>.</p>




<h3 id="utf_transcode">
<span class="h3_num">2.33.2</span><tt>utf_transcode()</tt>
</h3>


<pre class="code">
template&lt;class UTFReader, class UTFWriter&gt;
void utf_transcode(UTFReader r, UTFWriter w);
</pre>

<p>Алгоритм, читающий code points типа <a href="#unicode_t"><tt>unicode_t</tt></a> из
<tt>UTFReader</tt>, используя <tt>r.read()</tt>, и записывающий их в
<tt>UTFWriter</tt>, используя <tt>w.write()</tt>.</p>




<h3 id="unicode_code_point_constants">
<span class="h3_num">2.33.3</span><tt>Code point constants</tt>
</h3>


<pre class="code">
constexpr unicode_t unicode_max = 0x10FFFF;
constexpr unicode_t unicode_bom = 0xFEFF;
constexpr unicode_t unicode_replacement_char = 0xFFFD;
</pre>

<p>Именованные константы некоторых полезных Unicode code points.</p>






<h2 id="utf8.status.h">
<span class="h2_num">2.34</span><tt>__vic/utf8/status.h</tt>
</h2>



<h3 id="utf8--status">
<span class="h3_num">2.34.1</span><tt>utf8::status</tt>
</h3>


<pre class="code">
enum class utf8::status
{
    ok = 0,
    eof,
    // Errors
    no_leading_byte,
    truncated_code_point,
    overlong_encoding,
    code_point_too_big
};
using utf8::status_t = utf8::status; // for C++98
</pre>

<p>Значения, возвращаемые функцией <tt>parse()</tt> класса
<a href="#utf8--reader"><tt>utf8::reader</tt></a>.</p>

<ul>
<li>
<tt>ok</tt> - code point успешно прочитан</li>
<li>
<tt>eof</tt> - больше нечего читать</li>
<li>
<tt>no_leading_byte</tt> - многобайтовая последовательность
        без ведущего байта</li>
<li>
<tt>truncated_code_point</tt> - оборванная многобайтовая
        последовательность</li>
<li>
<tt>overlong_encoding</tt> - использовано чрезмерно длинное
        представление</li>
<li>
<tt>code_point_too_big</tt> - code point имеет слишком большое
        значение</li>
</ul>




<h3 id="utf8--is_error">
<span class="h3_num">2.34.2</span><tt>utf8::is_error()</tt>
</h3>


<pre class="code">
constexpr bool utf8::is_error(utf8::status s);
</pre>

<p>Возвращает <tt>false</tt> для значений <tt>utf8::status::ok</tt> и
<tt>utf8::status::eof</tt>. В остальных случаях возвращается <tt>true</tt>.</p>




<h3 id="utf8--throw_if_error">
<span class="h3_num">2.34.3</span><tt>utf8::throw_if_error()</tt>
</h3>


<pre class="code">
bool utf8::throw_if_error(utf8::status s);
</pre>

<p>Бросает исключение из <a href="#utf8.exceptions.h"><tt>__vic/utf8/exceptions.h</tt></a> в случае
<tt>is_error(s)</tt>. Возвращает <tt>true</tt> для <tt>utf8::status::ok</tt>
или <tt>false</tt> для <tt>utf8::status::eof</tt>.</p>






<h2 id="utf8.exceptions.h">
<span class="h2_num">2.35</span><tt>__vic/utf8/exceptions.h</tt>
</h2>


<pre class="code">
namespace utf8 {

class bad_encoding; // public std::exception
    class no_leading_byte;
    class truncated_code_point;
    class overlong_encoding;
    class code_point_too_big;

} // namespace
</pre>

<p>Классы исключений, бросаемые функцией <tt>read()</tt> класса
<a href="#utf8--reader"><tt>utf8::reader</tt></a>. Все исключения порождены от абстактного базового
класса <tt>utf8::bad_encoding</tt>. Эквивалентные коды статусов описаны в
<a href="#utf8--status"><tt>utf8::status</tt></a>.</p>



<h2 id="utf8.reader.h">
<span class="h2_num">2.36</span><tt>__vic/utf8/reader.h</tt>
</h2>


<h3 id="utf8--reader">
<span class="h3_num">2.36.1</span><tt>utf8::reader</tt>
</h3>


<pre class="code">
template&lt;class ByteReader&gt;
class utf8::reader
{
public:
    using byte_reader_type = ByteReader;
    ByteReader &amp;get_byte_reader();
    const ByteReader &amp;get_byte_reader() const;

    template&lt;class... Args&gt;
    explicit reader(Args&amp;&amp;... args); // since C++11

    reader(); // C++98 only
    explicit reader(ByteReader r); // C++98 only

    status_t parse(unicode_t &amp;cp);
    bool read(unicode_t &amp;cp);
};

template&lt;class ByteReader&gt;
utf8::reader&lt;ByteReader&gt; utf8::make_reader(ByteReader r);
</pre>

<p>Вычитывает UTF-8 code points из последовательности байтов.
Последовательность читается посредством <tt>ByteReader</tt>, который
моделирует <tt>Reader&lt;unsigned char&gt;</tt> (см. <a href="#readers"><tt>__vic/readers/</tt></a>).</p>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">ByteReader &amp;get_byte_reader()</pre>
<pre class="prototype">const ByteReader &amp;get_byte_reader() const</pre>
<blockquote>


<p>Возвращает ссылку на используемый byte reader.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class... Args&gt;
explicit reader(Args&amp;&amp;... args) <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Передаёт все параметры в используемый byte reader.</p>
</blockquote>
</div>

<div>
<pre class="prototype">reader() <span class="sign">[C++98 only]</span></pre>
<pre class="prototype">explicit reader(ByteReader r) <span class="sign">[C++98 only]</span></pre>
<blockquote>


<p>Конструкторы для режима C++98.</p>
</blockquote>
</div>

<div>
<pre class="prototype">status_t parse(unicode_t &amp;cp)</pre>
<blockquote>

<p>Пытается извлечь следующий code point из последовательности байтов, используя
<tt>ByteReader</tt>. В случае успеха возвращается <tt>utf8::status::ok</tt>,
code point сохраняется в <tt>cp</tt>. Если байты кончились, возвращается
<tt>utf8::status::eof</tt>. Другие значения возвращаются в случае ошибок,
подробности см. в <a href="#utf8--status"><tt>utf8::status</tt></a>. Для доступа к отдельным байтам
используется <tt>ByteReader::read()</tt>.</p>
<div>
<u>Замечание</u>: Функция сама по себе не бросает исключений, но их может бросать
<tt>ByteReader::read()</tt>.</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool read(unicode_t &amp;cp)</pre>
<blockquote>

<p>То же самое, что <tt>parse()</tt>, но возвращает <tt>true</tt> в случае
успеха, <tt>false</tt> в случае EOF, бросает исключения из
<a href="#utf8.exceptions.h"><tt>__vic/utf8/exceptions.h</tt></a> в остальных случаях.</p>
</blockquote>
</div>



<div class="section">Свободные функции</div>

<div>
<pre class="prototype">template&lt;class ByteReader&gt;
utf8::reader&lt;ByteReader&gt; utf8::make_reader(ByteReader r)</pre>
<blockquote>

<p>Создаёт UTF-8 reader используя указанный <tt>ByteReader</tt>.</p>
</blockquote>
</div>



<div class="section">Пример</div>
<pre class="code">
#include&lt;__vic/utf8/reader.h&gt;
#include&lt;__vic/readers/string.h&gt;
#include&lt;string&gt;
#include&lt;cstdint&gt;
#include&lt;iostream&gt;

// C++11
using utf8_string_reader = __vic::utf8::reader&lt;__vic::string_reader&gt;;

// C++98
struct utf8_string_reader : __vic::utf8::reader&lt;__vic::string_reader&gt;
{
    explicit utf8_string_reader(const std::string &amp;s)
        : __vic::utf8::reader&lt;__vic::string_reader&gt;(__vic::string_reader(s)) {}
};

void print_utf8_code_points(const string &amp;s)
{
    utf8_string_reader r(s);
    __vic::unicode_t cp;
    while(r.read(cp))
        std::cout &lt;&lt; uint_least32_t(cp) &lt;&lt; '\n';
}
</pre>






<h2 id="utf8.writer.h">
<span class="h2_num">2.37</span><tt>__vic/utf8/writer.h</tt>
</h2>


<h3 id="utf8--writer">
<span class="h3_num">2.37.1</span><tt>utf8::writer</tt>
</h3>


<pre class="code">
template&lt;class ByteWriter&gt;
class utf8::writer
{
public:
    using byte_writer_type = ByteWriter;
    ByteWriter &amp;get_byte_writer();
    const ByteWriter &amp;get_byte_writer() const;

    template&lt;class... Args&gt;
    explicit writer(Args&amp;&amp;... args); // since C++11

    writer(); // C++98 only
    explicit writer(ByteWriter w); // C++98 only

    void write(unicode_t cp);
};

template&lt;class ByteWriter&gt;
utf8::writer&lt;ByteWriter&gt; utf8::make_writer(ByteWriter w);
</pre>

<p>Пишет UTF-8 code points в последовательность байтов. Для вывода байтов
используется <tt>ByteWriter</tt>, моделирующий <tt>Writer&lt;unsigned char&gt;</tt>
(см. <a href="#writers"><tt>__vic/writers/</tt></a>).</p>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">ByteWriter &amp;get_byte_writer()</pre>
<pre class="prototype">const ByteWriter &amp;get_byte_writer() const</pre>
<blockquote>


<p>Возвращает ссылку на используемый byte writer.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class... Args&gt;
explicit writer(Args&amp;&amp;... args) <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Передаёт все параметры в используемый byte writer.</p>
</blockquote>
</div>

<div>
<pre class="prototype">writer() <span class="sign">[C++98 only]</span></pre>
<pre class="prototype">explicit writer(ByteWriter r) <span class="sign">[C++98 only]</span></pre>
<blockquote>


<p>Конструкторы для режима C++98.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void write(unicode_t cp)</pre>
<blockquote>

<p>Выводит указанный code point согласно правилам кодирования UTF-8.
Для записи отдельных байтов используется <tt>ByteWriter::write()</tt>.</p>
</blockquote>
</div>



<div class="section">Свободные функции</div>

<div>
<pre class="prototype">template&lt;class ByteWriter&gt;
utf8::writer&lt;ByteWriter&gt; utf8::make_writer(ByteWriter w)</pre>
<blockquote>

<p>Создаёт UTF-8 writer используя указанный <tt>ByteWriter</tt>.</p>
</blockquote>
</div>



<div class="section">Пример</div>
<pre class="code">
#include&lt;__vic/utf8/writer.h&gt;
#include&lt;__vic/writers/string.h&gt;
#include&lt;string&gt;
#include&lt;vector&gt;

// C++11
using utf8_string_writer = __vic::utf8::writer&lt;__vic::string_writer&gt;;

// C++98
struct utf8_string_writer : __vic::utf8::writer&lt;__vic::string_writer&gt;
{
    explicit utf8_string_writer(std::string &amp;s)
        : __vic::utf8::writer&lt;__vic::string_writer&gt;(__vic::string_writer(s)) {}
};

std::string encode_utf8(const std::vector&lt;__vic::unicode_t&gt; &amp;code_points)
{
    std::string utf8_res;
    utf8_string_writer w(utf8_res);
    for(auto cp : code_points) w.write(cp);
    return utf8_res;
}
</pre>






<h2 id="utf16.defs.h">
<span class="h2_num">2.38</span><tt>__vic/utf16/defs.h</tt>
</h2>


<h3 id="utf16--code_unit_t">
<span class="h3_num">2.38.1</span><tt>utf16::code_unit_t</tt>
</h3>


<pre class="code">
namespace utf16 {

using code_unit_t = char16_t; // since C++11
// или
using code_unit_t = uint_least16_t; // C++98

} // namespace
</pre>

<p>Тип для UTF-16 <a href="https://unicode.org/glossary/#code_unit">code unit</a>.</p>





<h2 id="utf16.status.h">
<span class="h2_num">2.39</span><tt>__vic/utf16/status.h</tt>
</h2>



<h3 id="utf16--status">
<span class="h3_num">2.39.1</span><tt>utf16::status</tt>
</h3>


<pre class="code">
enum class utf16::status
{
    ok = 0,
    eof,
    // Errors
    truncated_code_unit,
    truncated_code_point,
    invalid_sequence
};
using utf16::status_t = utf16::status; // for C++98
</pre>

<p>Значения, возвращаемые функцией <tt>parse()</tt> класса
<a href="#utf16--reader"><tt>utf16::reader</tt></a>.</p>

<ul>
<li>
<tt>ok</tt> - code point успешно прочитан</li>
<li>
<tt>eof</tt> - больше нечего читать</li>
<li>
<tt>truncated_code_unit</tt> - оборванный code unit</li>
<li>
<tt>truncated_code_point</tt> - оборванный code point</li>
<li>
<tt>invalid_sequence</tt> - байты не кодируют правильный
        UTF-16 code point</li>
</ul>




<h3 id="utf16--is_error">
<span class="h3_num">2.39.2</span><tt>utf16::is_error()</tt>
</h3>


<pre class="code">
constexpr bool utf16::is_error(utf16::status s);
</pre>

<p>Возвращает <tt>false</tt> для значений <tt>utf16::status::ok</tt> и
<tt>utf16::status::eof</tt>. В остальных случаях возвращается <tt>true</tt>.</p>




<h3 id="utf16--throw_if_error">
<span class="h3_num">2.39.3</span><tt>utf16::throw_if_error()</tt>
</h3>


<pre class="code">
bool utf16::throw_if_error(utf16::status s);
</pre>

<p>Бросает исключение из <a href="#utf16.exceptions.h"><tt>__vic/utf16/exceptions.h</tt></a> в случае
<tt>is_error(s)</tt>. Возвращает <tt>true</tt> для <tt>utf16::status::ok</tt>
или <tt>false</tt> для <tt>utf16::status::eof</tt>.</p>






<h2 id="utf16.exceptions.h">
<span class="h2_num">2.40</span><tt>__vic/utf16/exceptions.h</tt>
</h2>


<pre class="code">
namespace utf16 {

class bad_encoding; // public std::exception
    class truncated_code_unit;
    class truncated_code_point;
    class invalid_sequence;

} // namespace
</pre>

<p>Классы исключений, бросаемые функцией <tt>read()</tt> класса
<a href="#utf16--reader"><tt>utf16::reader</tt></a>. Все исключения порождены от абстактного базового
класса <tt>utf16::bad_encoding</tt>. Эквивалентные коды статусов описаны в
<a href="#utf16--status"><tt>utf16::status</tt></a>.</p>



<h2 id="utf16.reader.h">
<span class="h2_num">2.41</span><tt>__vic/utf16/reader.h</tt>
</h2>


<h3 id="utf16--reader">
<span class="h3_num">2.41.1</span><tt>utf16::reader</tt>
</h3>


<pre class="code">
template&lt;class CodeUnitReader&gt;
class utf16::reader
{
public:
    using code_unit_reader_type = CodeUnitReader;
    CodeUnitReader &amp;get_code_unit_reader();
    const CodeUnitReader &amp;get_code_unit_reader() const;

    template&lt;class... Args&gt;
    explicit reader(Args&amp;&amp;... args);  // since C++11

    reader(); // C++98 only
    explicit reader(CodeUnitReader r); // C++98 only

    status_t parse(unicode_t &amp;cp);
    bool read(unicode_t &amp;cp);
};

template&lt;class CodeUnitReader&gt;
utf16::reader&lt;CodeUnitReader&gt; utf16::make_reader(CodeUnitReader r);
</pre>

<p>Вычитывает UTF-16 code points из последовательности 2-байтовых
<a href="#utf16--code_unit_t"><tt>utf16::code_unit_t</tt></a>. Последовательность читается посредством
специального reader, имеющего следующую структуру:</p>

<pre class="code">
class <span class="nonterminal">CodeUnitReader</span>
{
public:
    utf16::status_t read_unit(utf16::code_unit_t &amp;u);
};
</pre>

<div>
<pre class="prototype">utf16::status_t read_unit(utf16::code_unit_t &amp;u)</pre>
<blockquote>

<p>Пытается вычитать следующий code unit. Возвращает <tt>utf16::status::ok</tt>
в случае успеха, <tt>utf16::status::eof</tt>, если больше не осталось code units,
либо <tt>utf16::status::truncated_code_unit</tt> если доступна только часть
code unit.</p>
</blockquote>
</div>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">CodeUnitReader &amp;get_code_unit_reader()</pre>
<pre class="prototype">const CodeUnitReader &amp;get_code_unit_reader() const</pre>
<blockquote>


<p>Возвращает ссылку на используемый code unit reader.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class... Args&gt;
explicit reader(Args&amp;&amp;... args) <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Передаёт все параметры в используемый code unit reader.</p>
</blockquote>
</div>

<div>
<pre class="prototype">reader() <span class="sign">[C++98 only]</span></pre>
<pre class="prototype">explicit reader(CodeUnitReader r) <span class="sign">[C++98 only]</span></pre>
<blockquote>


<p>Конструкторы для режима C++98.</p>
</blockquote>
</div>

<div>
<pre class="prototype">status_t parse(unicode_t &amp;cp)</pre>
<blockquote>

<p>Пытается извлечь следующий code point из последовательности code unit,
используя <tt>CodeUnitReader</tt>. В случае успеха возвращается
<tt>utf16::status::ok</tt>, code point сохраняется в <tt>cp</tt>. Если code
units кончились, возвращается <tt>utf16::status::eof</tt>. Другие значения
возвращаются в случае ошибок, подробности см. в <a href="#utf16--status"><tt>utf16::status</tt></a>.
Для доступа к отдельным code units используется
<tt>CodeUnitReader::read_unit()</tt>.</p>
<div>
<u>Замечание</u>: Функция сама по себе не бросает исключений, но их может бросать
<tt>CodeUnitReader::read_unit()</tt>.</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool read(unicode_t &amp;cp)</pre>
<blockquote>

<p>То же самое, что <tt>parse()</tt>, но возвращает <tt>true</tt> в случае
успеха, <tt>false</tt> в случае EOF, бросает исключения из
<a href="#utf16.exceptions.h"><tt>__vic/utf16/exceptions.h</tt></a> в остальных случаях.</p>
</blockquote>
</div>



<div class="section">Свободные функции</div>

<div>
<pre class="prototype">template&lt;class CodeUnitReader&gt;
utf16::reader&lt;CodeUnitReader&gt; utf16::make_reader(CodeUnitReader r)</pre>
<blockquote>

<p>Создаёт UTF-16 reader используя указанный <tt>CodeUnitReader</tt>.</p>
</blockquote>
</div>



<div class="section">Пример</div>
<pre class="code">
#include&lt;__vic/utf16/reader.h&gt;
#include&lt;__vic/readers/string.h&gt;
#include&lt;string&gt;
#include&lt;cstdint&gt;
#include&lt;iostream&gt;

class u16string_code_unit_reader
{
    __vic::basic_string_reader&lt;char16_t&gt; r;
public:
    explicit u16string_code_unit_reader(const std::u16string &amp;s) : r(s) {}

    __vic::utf16::status_t read_unit(__vic::utf16::code_unit_t &amp;u)
    {
        if(r.read(u)) return __vic::utf16::status::ok;
        return __vic::utf16::status::eof;
    }
};

void print_utf16_code_points(const std::u16string &amp;s)
{
    __vic::utf16::reader&lt;u16string_code_unit_reader&gt; r(s);
    __vic::unicode_t cp;
    while(r.read(cp))
        std::cout &lt;&lt; uint_least32_t(cp) &lt;&lt; '\n';
}
</pre>






<h2 id="utf16.writer.h">
<span class="h2_num">2.42</span><tt>__vic/utf16/writer.h</tt>
</h2>


<h3 id="utf16--writer">
<span class="h3_num">2.42.1</span><tt>utf16::writer</tt>
</h3>


<pre class="code">
template&lt;class CodeUnitWriter&gt;
class utf16::writer
{
public:
    using code_unit_writer_type = CodeUnitWriter;
    CodeUnitWriter &amp;get_code_unit_writer();
    const CodeUnitWriter &amp;get_code_unit_writer() const;

    template&lt;class... Args&gt;
    explicit writer(Args&amp;&amp;... args); // since C++11

    writer(); // C++98 only
    explicit writer(CodeUnitWriter w); // C++98 only

    void write(unicode_t cp);
};

template&lt;class CodeUnitWriter&gt;
utf16::writer&lt;CodeUnitWriter&gt; utf16::make_writer(CodeUnitWriter w);
</pre>

<p>Пишет UTF-16 code points в последовательность 2-байтовых
<a href="#utf16--code_unit_t"><tt>utf16::code_unit_t</tt></a>. Для вывода code units используется
<tt>CodeUnitWriter</tt>, моделирующий <tt>Writer&lt;utf16::code_unit_t&gt;</tt>
(см. <a href="#writers"><tt>__vic/writers/</tt></a>).</p>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">CodeUnitWriter &amp;get_code_unit_writer()</pre>
<pre class="prototype">const CodeUnitWriter &amp;get_code_unit_writer() const</pre>
<blockquote>


<p>Возвращает ссылку на используемый code unit writer.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class... Args&gt;
explicit writer(Args&amp;&amp;... args) <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Передаёт все параметры в используемый code unit writer.</p>
</blockquote>
</div>

<div>
<pre class="prototype">writer() <span class="sign">[C++98 only]</span></pre>
<pre class="prototype">explicit writer(CodeUnitWriter r) <span class="sign">[C++98 only]</span></pre>
<blockquote>


<p>Конструкторы для режима C++98.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void write(unicode_t cp)</pre>
<blockquote>

<p>Выводит указанный code point согласно правилам кодирования UTF-16.
Для записи отдельных code units ипользуется <tt>CodeUnitWriter::write()</tt>.
</p>
</blockquote>
</div>



<div class="section">Свободные функции</div>

<div>
<pre class="prototype">template&lt;class CodeUnitWriter&gt;
utf16::writer&lt;CodeUnitWriter&gt; utf16::make_writer(CodeUnitWriter w)</pre>
<blockquote>

<p>Создаёт UTF-16 writer используя указанный <tt>CodeUnitWriter</tt>.</p>
</blockquote>
</div>



<div class="section">Пример</div>
<pre class="code">
#include&lt;__vic/utf16/writer.h&gt;
#include&lt;__vic/writers/string.h&gt;
#include&lt;string&gt;
#include&lt;vector&gt;

std::u16string encode_utf16(const std::vector&lt;__vic::unicode_t&gt; &amp;code_points)
{
    std::u16string utf16_res;
    __vic::utf16::writer&lt;__vic::basic_string_writer&lt;char16_t&gt;&gt; w(utf16_res);
    for(auto cp : code_points) w.write(cp);
    return utf16_res;
}
</pre>






<h2 id="waitable_event.h">
<span class="h2_num">2.43</span><tt>__vic/waitable_event.h</tt>
</h2>


<h3 id="waitable_event">
<span class="h3_num">2.43.1</span><tt>waitable_event</tt>
</h3>


<pre class="code">
class waitable_event : private non_copyable
{
public:
    explicit waitable_event(bool signaled = false);
    ~waitable_event();

    void set();
    void reset();
    bool signaled() const;

    void wait();
    bool wait_ms(unsigned msec);

    // BEGIN C++11
    template&lt;class Rep, class Period&gt;
    bool wait_for(const std::chrono::duration&lt;Rep,Period&gt; &amp;d);
    template&lt;class Clock, class Duration&gt;
    bool wait_until(const std::chrono::time_point&lt;Clock,Duration&gt; &amp;t);
    // END C++11
};

</pre>

<p>Инструмент синхронизации, подобный «Event Object» в ОС Windows. Может
находиться в одном из двух состояний: сигнальном или несигнальном. Поток
может эффективно ждать перехода в сигнальное состояние, используя
предоставляемые wait-функции (с минимальным потреблением ресурсов системы).</p>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">explicit waitable_event(bool signaled = false)</pre>
<blockquote>

<div>
<u>Постусловие</u>: <tt>signaled() == signaled</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool signaled() const</pre>
<blockquote>

<p>Возвращает <tt>true</tt>, если объект находится в сигнальном состоянии.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void set()</pre>
<blockquote>

<p>Устанавливает сигнальное состояние.</p>
<div>
<u>Постусловие</u>: <tt>signaled() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void reset()</pre>
<blockquote>

<p>Устанавливает несигнальное состояние.</p>
<div>
<u>Постусловие</u>: <tt>signaled() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void wait()</pre>
<blockquote>

<p>Ждёт сигнального состояния без таймаута.</p>
<div>
<u>Постусловие</u>: <tt>signaled() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool wait_ms(unsigned msec)</pre>
<blockquote>

<p>Ждёт сигнального состояния не дольше указанного таймаута в миллисекундах.
Returns <tt>signaled()</tt>.</p>
<div>
<u>Замечание</u>: В режиме C++11 используйте <tt>wait_for()</tt>.</div>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class Rep, class Period&gt;
bool wait_for(const std::chrono::duration&lt;Rep,Period&gt; &amp;d) <span class="sign">[C++11]</span></pre>
<pre class="prototype">template&lt;class Clock, class Duration&gt;
bool wait_until(const std::chrono::time_point&lt;Clock,Duration&gt; &amp;t) <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Ждёт сигнального состояния не дольше указанного таймаута. Возвращает
<tt>signaled()</tt>.</p>
</blockquote>
</div>







<h2 id="writers">
<span class="h2_num">2.44</span><tt>__vic/writers/</tt>
</h2>



<h3 id="writer-concept">
<span class="h3_num">2.44.1</span><tt>Writer</tt> concept</h3>


<pre class="code">
template&lt;class ElementT&gt;
class <span class="nonterminal">Writer</span>
{
public:
    Writer(Writer &amp;&amp;o); or Writer(const Writer &amp;o);
    void write(ElementT v); // throws on errors
};
</pre>

<p>Concept, используемый алгоритмами библиотеки для поэлементной записи
логической последовательности элементов типа <tt>ElementT</tt>. Является
обобщением и переработкой concept'а <tt>OutputIterator</tt>. В частности,
он лучше обрабатывает потоки ввода/вывода и другие последовательности, в
которых <tt>end</tt>-итератор не имеет смысла или его получение дорого. В то
же время, традиционные выходные итераторы являются частным просто случаем и
полностью поддерживаются адаптером <tt>__vic::iterator_writer</tt>.</p>

<p>В случаях, когда конкретный класс удовлетворяет требованиям данного concept
для некоторого <tt>ElementT = T</tt>, говорят, что он <b>моделирует</b> concept
<tt>Writer&lt;T&gt;</tt>.</p>

<p>Каждый экземпляр класса должен быть move- или copy-constructible.</p>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">void write(ElementT v)</pre>
<blockquote>

<p>Записывает элемент или бросает исключение в случае ошибки.</p>
</blockquote>
</div>






<h3 id="null_writer">
<span class="h3_num">2.44.2</span><tt>null_writer</tt>
</h3>


<pre class="code">
#include&lt;__vic/writers/null.h&gt;

class null_writer
{
public:
    template&lt;class T&gt; void write(T v) {}
};

null_writer make_null_writer();
</pre>

<p>Фиктивный writer, принимающий любые значения и никуда их не выводящий (как
<tt>/dev/null</tt> в UNIX).</p>




<h3 id="push_back_writer">
<span class="h3_num">2.44.3</span><tt>push_back_writer</tt>
</h3>


<pre class="code">
#include&lt;__vic/writers/push_back.h&gt;

template&lt;class Cont, class T = typename Cont::value_type&gt;
class push_back_writer
{
public:
    explicit push_back_writer(Cont &amp;c);
    void write(T v) { c-&gt;push_back(v); }
};

template&lt;class Cont&gt;
push_back_writer&lt;Cont&gt; make_push_back_writer(Cont &amp;c);

template&lt;class T, class Cont&gt;
push_back_writer&lt;Cont,T&gt; make_push_back_writer_for(Cont &amp;c);
</pre>

<p>Адаптер. Использует функцию-член <tt>push_back()</tt> для записи элементов.
Может быть создан с помощью конструктора или одной из функций <tt>make_...</tt>.
</p>




<h3 id="iterator_writer">
<span class="h3_num">2.44.4</span><tt>iterator_writer</tt>
</h3>


<pre class="code">
#include&lt;__vic/writers/iterator.h&gt;

template&lt;class OutputIterator,
         class T = typename std::iterator_traits&lt;OutputIterator&gt;::value_type&gt;
class iterator_writer
{
public:
    explicit iterator_writer(OutputIterator it);
    void write(T v);
};

template&lt;class OutputIterator&gt;
iterator_writer&lt;OutputIterator&gt; make_iterator_writer(OutputIterator it);

template&lt;class T, class OutputIterator&gt;
iterator_writer&lt;OutputIterator,T&gt; make_iterator_writer_for(OutputIterator it);
</pre>

<p>Записывает элементы в выходной итератор. Может быть создан с помощью
конструктора или одной из функций <tt>make_...</tt>.</p>




<h3 id="string_writer">
<span class="h3_num">2.44.5</span><tt>string_writer</tt>
</h3>


<pre class="code">
#include&lt;__vic/writers/string.h&gt;

template&lt;
    class charT,
    class Tr = std::char_traits&lt;charT&gt;,
    class Al = std::allocator&lt;charT&gt;
&gt;
class basic_string_writer
{
public:
    explicit basic_string_writer(std::basic_string&lt;charT,Tr,Al&gt; &amp;s);
    void write(charT ch);
};

using string_writer = basic_string_writer&lt;char&gt;;

template&lt;class charT, class Tr, class Al&gt;
basic_string_writer&lt;charT,Tr,Al&gt;
    make_string_writer(std::basic_string&lt;charT,Tr,Al&gt; &amp;s);
</pre>

<p>Адаптер для <tt>std::basic_string</tt>. Может быть создан с помощью
конструктора или функции <tt>make_...</tt>.</p>




<h3 id="cstream_writer">
<span class="h3_num">2.44.6</span><tt>cstream_writer</tt>
</h3>


<pre class="code">
#include&lt;__vic/writers/cstream.h&gt;

class cstream_writer
{
public:
    explicit cstream_writer(std::FILE *fp);
    void write(char ch) { __vic::write(fp, ch); }
};

cstream_writer make_cstream_writer(std::FILE *fp);
</pre>

<p>Моделирует <tt>Writer&lt;char&gt;</tt> для <tt>std::FILE</tt>. Может быть
создан с помощью конструктора или функции <tt>make_...</tt>.</p>






<h2 id="posix.cond_variable.h">
<span class="h2_num">2.45</span><tt>__vic/posix/cond_variable.h</tt>
</h2>


<h3 id="posix--cond_variable">
<span class="h3_num">2.45.1</span><tt>posix::cond_variable</tt>
</h3>


<pre class="code">
class posix::cond_variable
{
public:
    constexpr cond_variable() noexcept;
    ~cond_variable();

    cond_variable(const cond_variable &amp; ) = delete;
    cond_variable &amp;operator=(const cond_variable &amp; ) = delete;

    void wait(::pthread_mutex_t &amp;m);
    void wait(posix::mutex &amp;m);

    bool wait_until(::pthread_mutex_t &amp;m, const ::timespec &amp;abstime);
    bool wait_until(posix::mutex &amp;m, const ::timespec &amp;abstime);

    void signal();
    void broadcast();

    // C++11-compatible synonyms
    void notify_one() { signal(); }
    void notify_all() { broadcast(); }
};
</pre>

<p>Переменные условий POSIX.</p>

<div>
<u><b>Замечание</b></u>: В режиме С++11 <tt>std::condition_variable</tt> может быть более
подходящим вариантом.</div>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">cond_variable()</pre>
<blockquote>

<p>Создаёт объект.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~cond_variable()</pre>
<blockquote>

<p>Уничтожает объект.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void wait(::pthread_mutex_t &amp;m)</pre>
<pre class="prototype">void wait(posix::mutex &amp;m)</pre>
<blockquote>


<p>Блокирует вызывающий поток и ждёт сигналов (уведомлений).</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool wait_until(::pthread_mutex_t &amp;m, const ::timespec &amp;abstime)</pre>
<pre class="prototype">bool wait_until(posix::mutex &amp;m, const ::timespec &amp;abstime)</pre>
<blockquote>


<p>То же, что <tt>wait()</tt>, но время ожидания ограничено таймаутом.
Возвращает <tt>true</tt>, если сигнал был получен, <tt>false</tt>, если
таймаут истёк.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void signal()</pre>
<pre class="prototype">void notify_one()</pre>
<blockquote>


<p>Шлёт сигнал (уведомление) одному из ожидающих потоков.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void broadcast()</pre>
<pre class="prototype">void notify_all()</pre>
<blockquote>


<p>Шлёт сигнал (уведомление) всем ожидающим потокам.</p>
</blockquote>
</div>







<h2 id="posix.daemon_control.h">
<span class="h2_num">2.46</span><tt>__vic/posix/daemon_control.h</tt>
</h2>


<h3 id="posix--daemon_control">
<span class="h3_num">2.46.1</span><tt>posix::daemon_control</tt>
</h3>


<pre class="code">
class posix::daemon_control : private non_copyable
{
public:
    class already_running; // public std::exception

    explicit daemon_control(std::string pid_file_name);
    ~daemon_control();

    void daemonize();

    static int control(const char *cmd, const char *pid_file_name);
    static void stop_and_wait(const char *pid_file_name);
};
</pre>

<p>Класс реализует функции запуска, остановки, перезапуска, контроля состояния
и защиту от многократного запуска для приложений-daemon’ов. Рекомендуемый
способ использования – private-наследование классом вроде <tt>application</tt>
конкретного приложения.</p>

<div>
<u><b>Замечание</b></u>: Поиск процесса осуществляется по PID-файлу, который создаётся в текущей
директории при запуске. Если этот файл удалить, то механизмы будут считать,
что процесс не запущен, несмотря на его действительное состояние! Поэтому
PID-файл безопасно можно только читать сторонними средствами или удалять,
если точно известно, что процесс не запущен в данный момент.</div>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">class already_running</pre>
<blockquote>

<p>Исключение. Бросается конструктором, если запускаемый демон уже запущен в
данный момент.</p>
</blockquote>
</div>

<div>
<pre class="prototype">explicit daemon_control(std::string pid_file_name)</pre>
<blockquote>

<p>Запускает приложение и создаёт файл с именем, переданным в
<tt>pid_file_name</tt>, в текущем каталоге, содержащий PID созданного
процесса. Если при запуске обнаруживается, что процесс уже запущен, то
бросается <tt>already_running</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~daemon_control()</pre>
<blockquote>

<p>Удаляет PID-файл, созданный конструктором.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void daemonize()</pre>
<blockquote>

<p>Делает вызывающий процесс daemon’ом и обновляет значение в PID-файле.</p>
</blockquote>
</div>

<div>
<pre class="prototype">static int control(const char *cmd, const char *pid_file_name)</pre>
<blockquote>

<p>Выполняет одну из команд, заданных первым параметром, и возвращает
статус:</p>
<ul>
<li>
        <tt>stop</tt> - посылка сигнала <tt>SIGTERM</tt> выполняющемуся
        процессу, возвращает статус успешно/неуспешно (<tt>0</tt>/<tt>1</tt>),
    </li>
<li>
        <tt>kill</tt> - убийство выполняющегося процесса сигналом
        <tt>SIGKILL</tt>, возвращает статус успешно/неуспешно
        (<tt>0</tt>/<tt>1</tt>),
    </li>
<li>
        <tt>status</tt> - проверка текущего состояния процесса:
        <ul>
<li>вывод «Running» в <tt>stdout</tt> и возврат статуса
                <tt>0</tt>, если процесс выполняется,</li>
<li>вывод «Not running» и статус <tt>1</tt>, если не
                выполняется,</li>
<li>вывод сообщения об ошибке в <tt>stderr</tt> и возврат
                статуса <tt>&gt;1</tt> в случае ошибок.</li>
</ul>
    </li>
</ul>
<p>Если передана команда, отличная от перечисленных выше, то бросается
исключение. Вторым параметром передаётся имя PID-файла, которое передавалось
в конструктор при запуске.</p>
</blockquote>
</div>

<div>
<pre class="prototype">static void stop_and_wait(const char *pid_file_name)</pre>
<blockquote>

<p>Посылает сигнал <tt>SIGTERM</tt>, если процесс выполняется, и дожидается его
завершения. Если процесс в данный момент не выполняется, то просто возвращает
управление. Функция используется для рестарта приложения. После её вызова
можно создавать экземпляр <tt>daemon_control</tt> и запускать работу
приложения.</p>
</blockquote>
</div>







<h2 id="posix.dir_entries.h">
<span class="h2_num">2.47</span><tt>__vic/posix/dir_entries.h</tt>
</h2>


<h3 id="posix--dir_entries">
<span class="h3_num">2.47.1</span><tt>posix::dir_entries</tt>
</h3>


<pre class="code">
class posix::dir_entries : private non_copyable
{
public:
    dir_entries();
    explicit dir_entries(const char *dir);
    ~dir_entries();

    // BEGIN C++11
    dir_entries(dir_entries &amp;&amp;o) noexcept;
    dir_entries &amp;operator=(dir_entries &amp;&amp;o) noexcept;
    // END C++11

    bool reopen(const char *dir);
    void close();
    bool is_open() const;

    const char *next();
#ifdef _DIRENT_HAVE_D_TYPE
    unsigned char type() const;
#endif
    void rewind();
};
</pre>

<p>Класс позволяет просматривать список элементов в указанном каталоге.
Специальные ссылки <tt>.</tt> и <tt>..</tt> никогда не включаются в
результирующий набор.</p>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">dir_entries()</pre>
<blockquote>

<p>Создаёт закрытый объект.</p>
<div>
<u>Постусловие</u>: <tt>is_open() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">explicit dir_entries(const char *dir)</pre>
<blockquote>

<p>Пытается открыть каталог <tt>dir</tt> для просмотра. Необходимо проверить
результат открытия последующим вызовом <tt>is_open()</tt>! В случае неудачи,
ошибка сохраняется в <tt>errno</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~dir_entries()</pre>
<blockquote>

<p>Вызывает <tt>close()</tt>, если <tt>is_open() == true</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">dir_entries(dir_entries &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<pre class="prototype">dir_entries &amp;operator=(dir_entries &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Операции перемещения для режима C++11.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool reopen(const char *dir)</pre>
<blockquote>

<p>Инициализирует новый листинг. Предварительно вызывает <tt>close()</tt>,
если необходимо. Возвращает <tt>true</tt> в случае успеха. В случае неудачи,
ошибка сохраняется в <tt>errno</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void close()</pre>
<blockquote>

<p>Освобождает ресурсы. Бросает исключения при ошибках.</p>
<div>
<u>Предусловие</u>: <tt>is_open() == true</tt>
</div>
<div>
<u>Постусловие</u>: <tt>is_open() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool is_open() const</pre>
<blockquote>

<p>Возвращает <tt>true</tt>, если <tt>next()</tt> может быть вызван.</p>
</blockquote>
</div>

<div>
<pre class="prototype">const char *next()</pre>
<blockquote>

<p>Возвращает следующий элемент или <tt>nullptr</tt>, если достигнут конец
списка.</p>
<div>
<u>Предусловие</u>: <tt>is_open() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">unsigned char type() const</pre>
<blockquote>

<p>Возвращает тип элемента: <tt>DT_REG</tt>, <tt>DT_DIR</tt> и т.п. (см.
документацию на <tt>dirent</tt> в Вашей системе). Функция доступна только если
определён макрос <tt>_DIRENT_HAVE_D_TYPE</tt>. Но в любом случае, в некоторых
ситуациях тип не может быть определён, и возвращается <tt>DT_UNKNOWN</tt>.
Все приложения должны предусматривать данную ситуацию и быть готовымив таких
случаях явно получать тип вызовом <tt>stat()</tt>!</p>
</blockquote>
</div>

<div>
<pre class="prototype">void rewind()</pre>
<blockquote>

<p>Перематывает курсор списка на начало.</p>
<div>
<u>Предусловие</u>: <tt>is_open() == true</tt>
</div>
</blockquote>
</div>



<div class="section">Пример</div>
<pre class="code">
// Выводит содержимое текущего каталога
__vic::posix::dir_entries list(".");
if(!list.is_open())
    __vic::throw_errno("Can't open directory for listing");
while(const char *entry = list.next())
    std::cout &lt;&lt; entry &lt;&lt; '\n';
</pre>






<h2 id="posix.dir_files.h">
<span class="h2_num">2.48</span><tt>__vic/posix/dir_files.h</tt>
</h2>


<h3 id="posix--dir_files">
<span class="h3_num">2.48.1</span><tt>posix::dir_files</tt>
</h3>


<pre class="code">
class posix::dir_files : private non_copyable
{
public:
    dir_files();
    explicit dir_files(const char *dir, const char *pattern = nullptr);
    ~dir_files();

    // BEGIN C++11
    dir_files(dir_files &amp;&amp;o) noexcept;
    dir_files &amp;operator=(dir_files &amp;&amp;o) noexcept;
    // END C++11

    bool reopen(const char *dir, const char *pattern = nullptr);
    void close();
    bool is_open() const;

    const char *next();
    void rewind();
};
</pre>

<p>Класс аналогичен классу <tt>dir_entries</tt>, но игнорирует все элементы
каталога, не являющиеся регулярными файлами. Также имеется возможность задания
опциональной маски имён файлов с помощью параметра <tt>pattern</tt>.</p>

<div class="section">Пример</div>
<pre class="code">
// Выводит список cpp-файлов в текущем каталоге
__vic::posix::dir_files files(".", "*.cpp");
if(!files.is_open())
    __vic::throw_errno("Can't open directory for listing");
while(const char *file = files.next())
    std::cout &lt;&lt; file &lt;&lt; '\n';
</pre>






<h2 id="posix.error.h">
<span class="h2_num">2.49</span><tt>__vic/posix/error.h</tt>
</h2>


<p>Инструменты обработки ошибок специфичные для POSIX.</p>

<h3 id="posix--is_EAGAIN">
<span class="h3_num">2.49.1</span><tt>posix::is_EAGAIN()</tt>, <tt>posix::is_ENOENT()</tt>
</h3>


<pre class="code">
namespace posix {

bool is_EAGAIN(int err_no);
bool is_ENOENT(int err_no);

#define __VIC_CASE_EAGAIN <span class="nonterminal">case &lt;val1&gt;: case &lt;val2&gt;: ...</span>
#define __VIC_CASE_ENOENT <span class="nonterminal">case &lt;val1&gt;: case &lt;val2&gt;: ...</span>

}
</pre>

<p>Первая функция проверяет, имеет ли код значение <tt>EAGAIN</tt> или
<tt>EWOULDBLOCK</tt>. Это работает независимо от того, имеют они одно и
то же числовое значение на данной платформе или нет.</p>

<p>Вторая функция проверяет, имеет ли код значение <tt>ENOENT</tt>,
<tt>ESTALE</tt> и им подобные, означающие, что произошла попытка обращения к
несуществующему файлу.</p>

<p>Макросы должны использоваться внутри конструкции <tt>switch</tt>. Они
раскрываются в один <tt>case</tt> с двоеточием, либо в набор <tt>case</tt>’ов,
и выполняют ту же функцию, что и функции, описанные выше.</p>

<div class="section">Пример</div>
<pre class="code">
switch(errno)
{
    __VIC_CASE_ENOENT
        std::cout &lt;&lt; "No file found!\n"; break;
    case EPERM:
       ...
}
</pre>






<h2 id="posix.file.h">
<span class="h2_num">2.50</span><tt>__vic/posix/file.h</tt>
</h2>


<h3 id="posix--file">
<span class="h3_num">2.50.1</span><tt>posix::file</tt>
</h3>


<pre class="code">
class posix::file : private non_copyable
{
public:
    explicit constexpr file(int fd = -1);
    file(const char *name, int flags, ::mode_t mode = 0666);
    ~file();

    // BEGIN C++11
    file(file &amp;&amp;o) noexcept;
    file &amp;operator=(file &amp;&amp;o) noexcept;
    // END C++11

    bool open(const char *name, int flags, ::mode_t mode = 0666);
    bool is_open() const;
    void close();
    bool close_nt() noexcept;

    void swap(file &amp;o) noexcept;
    int detach_handle() noexcept;
    int attach_handle(int fd) noexcept;
    int handle() const;
    int descriptor() const { return handle(); }

    size_t read_max(void *buf, size_t n)
        { return read_max(handle(), buf, n); }
    size_t read_some(void *buf, size_t n)
        { return read_some(handle(), buf, n); }
    void write_all(const void *buf, size_t n)
        { write_all(handle(), buf, n); }
    size_t write_all_nt(const void *buf, size_t n) noexcept
        { return write_all_nt(handle(), buf, n); }

    static size_t read_max(int fd, void *buf, size_t n);
    static size_t read_some(int fd, void *buf, size_t n);
    static void write_all(int fd, const void *buf, size_t n);
    static size_t write_all_nt(int fd, const void *buf, size_t n) noexcept;
    static void close_reset(int &amp;fd);
    static bool close_nt(int fd) noexcept;
};
</pre>

<p>RAII-обёртка для POSIX'овых файловых дескрипторов, а также обёртки для
системных вызовов <tt>::read()</tt> и <tt>::write()</tt>.</p>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">explicit constexpr file(int fd = -1)</pre>
<blockquote>

<p>Принимает уже существующий дескриптор.</p>
<div>
<u>Предусловие</u>: <tt>fd</tt> - либо открытый дескриптор, либо <tt>-1</tt>.</div>
</blockquote>
</div>

<div>
<pre class="prototype">file(const char *name, int flags, ::mode_t mode = 0666)</pre>
<blockquote>

<p>Вызывает <tt>open()</tt>. Результат должен быть проверен последующим вызовом
<tt>is_open()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~file()</pre>
<blockquote>

<p>Вызывает <tt>::close()</tt>, если <tt>is_open() == true</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">file(file &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<pre class="prototype">file &amp;operator=(file &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Операции перемещения для режима C++11.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool open(const char *name, int flags, ::mode_t mode = 0666)</pre>
<blockquote>

<p>Вызывает <tt>::open()</tt> с указанными параметрами. Возвращает
<tt>is_open()</tt>. <tt>errno</tt> содержит код ошибки в случае неудачи.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool is_open() const</pre>
<blockquote>

<p>Возвращает <tt>true</tt>, если файл открыт.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void close()</pre>
<blockquote>

<p>Безусловно вызывает <tt>::close()</tt>. Никаких предварительных проверок,
открыт ли файл, не производится! Корректно обрабатывает прерывания сигналами.
Бросает исключения в случае ошибок. Постусловие соблюдается даже если функция
выбросила исключение.</p>
<div>
<u>Предусловие</u>: <tt>is_open() == true</tt>
</div>
<div>
<u>Постусловие</u>: <tt>is_open() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">static void close_reset(int &amp;fd)</pre>
<blockquote>

<p>Безусловно вызывает <tt>::close()</tt> с указанным дескриптором и присваивает
ему <tt>-1</tt>. Никаких предварительных проверок не производится! Корректно
обрабатывает прерывания сигналами. Бросает исключения в случае ошибок.
Постусловие соблюдается даже если функция выбросила исключение.</p>
<div>
<u>Предусловие</u>: <tt>fd &gt;= 0</tt>
</div>
<div>
<u>Постусловие</u>: <tt>fd == -1</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool close_nt() noexcept</pre>
<pre class="prototype">static bool close_nt(int fd) noexcept</pre>
<blockquote>


<p>Аналог <tt>close()</tt>, но не бросает исключений. В случае неудачи
возвращается <tt>false</tt>, и <tt>errno</tt> содержит код ошибки.</p>
</blockquote>
</div>

<div>
<pre class="prototype">int detach_handle() noexcept</pre>
<blockquote>

<p>Освобождает дескриптор из-под контроля объекта и возвращает его.</p>
<div>
<u>Постусловие</u>: <tt>is_open() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">int attach_handle(int fd) noexcept</pre>
<blockquote>

<p>Берёт <tt>fd</tt> под контроль и возвращает предыдущий дескриптор.</p>
<div>
<u>Предусловие</u>: <tt>fd</tt> - либо открытый дескриптор, либо <tt>-1</tt>.</div>
<div>
<u>Постусловие</u>: <tt>handle() == fd</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void swap(file &amp;o) noexcept</pre>
<blockquote>

<p>Обменивается значением с <tt>o</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">int handle() const</pre>
<pre class="prototype">int descriptor() const { return handle(); }</pre>
<blockquote>


<p>Возвращает контролируемый дескриптор.</p>
</blockquote>
</div>

<div>
<pre class="prototype">static size_t read_max(int fd, void *buf, size_t n)</pre>
<pre class="prototype">size_t read_max(void *buf, size_t n) { return read_max(handle(), buf, n); }</pre>
<blockquote>


<p>Пытается прочитать <tt>n</tt> байт в указанный буфер. Возвращает количество
прочитанных байтов. Возвращённое значение может быть меньше запрошенного только
в случае достижения конца файла. Набирает вычитанные фрагменты, пока буфер не
заполнится. Не прерывается сигналами. Вызывает <a href="#throw_errno"><tt>throw_errno()</tt></a> в случае
ошибок.</p>
</blockquote>
</div>

<div>
<pre class="prototype">static size_t read_some(int fd, void *buf, size_t n)</pre>
<pre class="prototype">size_t read_some(void *buf, size_t n) { return read_some(handle(), buf, n); }</pre>
<blockquote>


<p>Читает не более <tt>n</tt> байтов в указанный буфер. Возвращает количество
прочитанных байтов или <tt>0</tt> при достижении конца файла. Функция сразу
возвращает управление, как только считан первый фрагмент данных. Не прерывается
сигналами. Вызывает <a href="#throw_errno"><tt>throw_errno()</tt></a> в случае ошибок.</p>
</blockquote>
</div>

<div>
<pre class="prototype">static void write_all(int fd, const void *buf, size_t n);</pre>
<pre class="prototype">void write_all(const void *buf, size_t n) { write_all(handle(), buf, n); }</pre>
<blockquote>


<p>Записывает весь буфер в указанный дескриптор. Не прерывается сигналами.
Вызывает <a href="#throw_errno"><tt>throw_errno()</tt></a> в случае ошибок.</p>
</blockquote>
</div>

<div>
<pre class="prototype">static size_t write_all_nt(int fd, const void *buf, size_t n) noexcept</pre>
<pre class="prototype">size_t write_all_nt(const void *buf, size_t n) noexcept</pre>
<blockquote>


<p>Аналог <tt>write_all()</tt>, но не бросает исключений. Вместо них возвращает
значение меньше <tt>n</tt>, <tt>errno</tt> содержит код ошибки.</p>
</blockquote>
</div>



<div class="section">Пример</div>
<pre class="code">
__vic::posix::file file("path/file", O_WRONLY | O_CREAT);
if(!file.is_open()) __vic::throw_errno("Cannot create file");
const char msg[] = "Hello";
file.write_all(msg, sizeof msg - 1); // write without null-terminator
file.close();
</pre>






<h2 id="posix.file_stat.h">
<span class="h2_num">2.51</span><tt>__vic/posix/file_stat.h</tt>
</h2>


<h3 id="posix--file_stat">
<span class="h3_num">2.51.1</span><tt>posix::file_stat</tt>
</h3>


<pre class="code">
namespace posix {

struct file_stat : public ::stat
{
    enum for_link_t { for_link };

    file_stat() = default;
    file_stat(const struct ::stat &amp;s);
    explicit file_stat(int fd);
    explicit file_stat(const char *path);
    explicit file_stat(const std::string &amp;path);
    file_stat(const char *path, for_link_t);
    file_stat(const std::string &amp;path, for_link_t);

    void get(int fd);
    void get(const char *path);
    void get(const std::string &amp;path);
    void get_for_link(const char *path);
    void get_for_link(const std::string &amp;path);

    bool try_get(int fd);
    bool try_get(const char *path);
    bool try_get(const std::string &amp;path);
    bool try_get_for_link(const char *path);
    bool try_get_for_link(const std::string &amp;path);

    bool get_if_exists(const char *path);
    bool get_if_exists(const std::string &amp;path);

    // POSIX-defined attributes
    dev_t   dev() const { return this-&gt;st_dev; }
    ino_t   ino() const { return this-&gt;st_ino; }
    mode_t  mode() const { return this-&gt;st_mode; }
    nlink_t nlink() const { return this-&gt;st_nlink; }
    uid_t   uid() const { return this-&gt;st_uid; }
    gid_t   gid() const { return this-&gt;st_gid; }
    off_t   size() const { return this-&gt;st_size; }
    time_t  atime() const { return this-&gt;st_atime; }
    time_t  mtime() const { return this-&gt;st_mtime; }
    time_t  ctime() const { return this-&gt;st_ctime; }

    bool is_block() const { return S_ISBLK(mode()); }
    bool is_char() const { return S_ISCHR(mode()); }
    bool is_dir() const { return S_ISDIR(mode()); }
    bool is_fifo() const { return S_ISFIFO(mode()); }
    bool is_regular() const { return S_ISREG(mode()); }
    bool is_link() const { return S_ISLNK(mode()); }
    bool is_socket() const { return S_ISSOCK(mode()); }
};
inline bool is_block(const struct ::stat &amp;s) { return S_ISBLK(s.st_mode); }
inline bool is_char(const struct ::stat &amp;s) { return S_ISCHR(s.st_mode); }
inline bool is_dir(const struct ::stat &amp;s) { return S_ISDIR(s.st_mode); }
inline bool is_fifo(const struct ::stat &amp;s) { return S_ISFIFO(s.st_mode); }
inline bool is_regular(const struct ::stat &amp;s) { return S_ISREG(s.st_mode); }
inline bool is_link(const struct ::stat &amp;s) { return S_ISLNK(s.st_mode); }
inline bool is_socket(const struct ::stat &amp;s) { return S_ISSOCK(s.st_mode); }

bool is_same_file(const struct ::stat &amp;s1, const struct ::stat &amp;s2);

}
</pre>

<p>C++ обёртка для системной структуры <tt>stat</tt>. Конструкторы и функции
<tt>get()</tt> вызывают <a href="#throw_errno"><tt>throw_errno()</tt></a> в случае ошибок. Функции
<tt>try_get()</tt> вместо этого возвращают <tt>false</tt>, код ошибки содержится
в <tt>errno</tt>.</p>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">enum for_link_t { for_link }</pre>
<blockquote>

<p>Тэг конструктора.</p>
</blockquote>
</div>

<div>
<pre class="prototype">file_stat()</pre>
<blockquote>

<p>Создаёт неинициализированную структуру.</p>
</blockquote>
</div>

<div>
<pre class="prototype">file_stat(const struct ::stat &amp;s)</pre>
<blockquote>

<p>Копирует <tt>s</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">explicit file_stat(int fd)</pre>
<pre class="prototype">void get(int fd)</pre>
<blockquote>


<p>Получает stat для файлового дескриптора <tt>fd</tt> (системный вызов
<tt>fstat()</tt>).</p>
</blockquote>
</div>

<div>
<pre class="prototype">explicit file_stat(const char *path)</pre>
<pre class="prototype">explicit file_stat(const std::string &amp;path)</pre>
<pre class="prototype">void get(const char *path)</pre>
<pre class="prototype">void get(const std::string &amp;path)</pre>
<blockquote>




<p>Получает stat по файловому пути (системный вызов <tt>stat()</tt>).</p>
</blockquote>
</div>

<div>
<pre class="prototype">file_stat(const char *path, for_link_t)</pre>
<pre class="prototype">file_stat(const std::string &amp;path, for_link_t)</pre>
<pre class="prototype">void get_for_link(const char *path)</pre>
<pre class="prototype">void get_for_link(const std::string &amp;path)</pre>
<blockquote>




<p>Получает stat для символической ссылки (системный вызов <tt>lstat()</tt>).
</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool try_get(int fd)</pre>
<pre class="prototype">bool try_get(const char *path)</pre>
<pre class="prototype">bool try_get(const std::string &amp;path)</pre>
<pre class="prototype">bool try_get_for_link(const char *path)</pre>
<pre class="prototype">bool try_get_for_link(const std::string &amp;path)</pre>
<blockquote>





<p>Аналоги <tt>get()</tt> и <tt>get_for_link()</tt>, но возвращают
<tt>false</tt> вместо выброса исключений.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool get_if_exists(const char *path)</pre>
<pre class="prototype">bool get_if_exists(const std::string &amp;path)</pre>
<blockquote>


<p>Аналог <tt>get()</tt>, но возвращает <tt>false</tt> в случае, если файл не
найден, вместо выброса исключения. Бросает исключения в случае других ошибок.
</p>
</blockquote>
</div>

<div>
<pre class="prototype">dev_t   dev() const</pre>
<pre class="prototype">ino_t   ino() const</pre>
<pre class="prototype">mode_t  mode() const</pre>
<pre class="prototype">nlink_t nlink() const</pre>
<pre class="prototype">uid_t   uid() const</pre>
<pre class="prototype">gid_t   gid() const</pre>
<pre class="prototype">off_t   size() const</pre>
<pre class="prototype">time_t  atime() const</pre>
<pre class="prototype">time_t  mtime() const</pre>
<pre class="prototype">time_t  ctime() const</pre>
<blockquote>










<p>Атрибуты структуры <tt>stat</tt> определённые стандартом POSIX.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool is_block() const</pre>
<pre class="prototype">bool is_char() const</pre>
<pre class="prototype">bool is_dir() const</pre>
<pre class="prototype">bool is_fifo() const</pre>
<pre class="prototype">bool is_regular() const</pre>
<pre class="prototype">bool is_link() const</pre>
<pre class="prototype">bool is_socket() const</pre>
<blockquote>







<p>Обёртки стандартных макросов.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool is_same_file(const struct ::stat &amp;s1, const struct ::stat &amp;s2)</pre>
<blockquote>

<p>Определяет, ссылаются ли структуры на один и тот же файл.</p>
</blockquote>
</div>







<h2 id="posix.fs.h">
<span class="h2_num">2.52</span><tt>__vic/posix/fs.h</tt>
</h2>


<p>Инструменты для работы с файлами и путями на POSIX-совместимых файловых
системах.</p>


<h3 id="posix--basename">
<span class="h3_num">2.52.1</span><tt>posix::basename()</tt>, <tt>posix::dirname()</tt>
</h3>


<pre class="code">
namespace posix {

std::string basename(const std::string &amp;path);
std::string dirname(const std::string &amp;path);
void basename(const std::string &amp;path, std::string &amp;res);
void dirname(const std::string &amp;path, std::string &amp;res);
void append_basename(const std::string &amp;path, std::string &amp;res);
void append_dirname(const std::string &amp;path, std::string &amp;res);

}
</pre>

<p>Функции являются аналогами стандартных shell-команд. Извлекают имя файла
или каталога из пути. Есть 3 варианта функций:</p>
<ul>
<li>Результат возвращается стандартным способом,</li>
<li>Результат возвращается через выходной параметр и</li>
<li>Результат добавляется к выходному параметру.</li>
</ul>

<div class="section">Example</div>
<pre class="code">
std::cout &lt;&lt; __vic::posix::dirname("/usr/lib") &lt;&lt; '\n';   // "/usr"
std::cout &lt;&lt; __vic::posix::basename("/usr/lib") &lt;&lt; '\n';  // "lib"
std::cout &lt;&lt; __vic::posix::dirname("/usr/lib/") &lt;&lt; '\n';  // "/usr"
std::cout &lt;&lt; __vic::posix::basename("/usr/lib/") &lt;&lt; '\n'; // "lib"
std::cout &lt;&lt; __vic::posix::dirname("lib") &lt;&lt; '\n';        // "."
std::cout &lt;&lt; __vic::posix::basename("lib") &lt;&lt; '\n';       // "lib"
std::cout &lt;&lt; __vic::posix::dirname("/") &lt;&lt; '\n';          // "/"
std::cout &lt;&lt; __vic::posix::basename("/") &lt;&lt; '\n';         // "/"
std::cout &lt;&lt; __vic::posix::dirname("") &lt;&lt; '\n';           // "."
std::cout &lt;&lt; __vic::posix::basename("") &lt;&lt; '\n';          // ""
</pre>





<h3 id="posix--add_trailing_slash">
<span class="h3_num">2.52.2</span><tt>posix::add_trailing_slash()</tt>,
    <tt>posix::with_trailing_slash()</tt>
</h3>


<pre class="code">
namespace posix {

std::string &amp;add_trailing_slash(std::string &amp;path);
std::string with_trailing_slash(const std::string &amp;s);
std::string with_trailing_slash(const char *s);

}
</pre>

<p>Добавляют завершающий слеш к пути, если его там нет.
<tt>add_trailing_slash()</tt> модифицирует свой аргумент, а
<tt>with_trailing_slash()</tt> всегда создаёт новый объект и возвращает его.</p>

<div class="section">Пример</div>
<pre class="code">
std::string path = get_directory();
__vic::posix::add_trailing_slash(path) += "file.name"; // dir/file.name
create_file(path);
</pre>







<h2 id="posix.iov.h">
<span class="h2_num">2.53</span><tt>__vic/posix/iov.h</tt>
</h2>


<p>Векторизованный ввод/вывод.</p>


<h3 id="posix--ovectors">
<span class="h3_num">2.53.1</span><tt>posix::ovectors</tt>
</h3>


<pre class="code">
template&lt;unsigned N&gt;
class posix::ovectors
{
public:
    ovectors();

    void push_back(const void *buf, size_t buf_len);
    void pop_back();

    ::iovec *ptr();
    const ::iovec *ptr() const;
    unsigned size() const;

    bool full() const;
    bool empty() const;
    void clear();

    static constexpr unsigned max_size() { return N; }
    size_t total_bytes() const;
};
</pre>

<p>Обёртка для массива системных структур <tt>iovec</tt>, предназначенного для
вывода набора разрозненных буферов со сбором (gathering). Параметр шаблона
задаёт максимальное количество буферов.</p>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">ovectors()</pre>
<blockquote>

<div>
<u>Постусловие</u>: <tt>empty() &amp;&amp; total_bytes() == 0</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void push_back(const void *buf, size_t buf_len)</pre>
<blockquote>

<p>Добавляет указанный буфер к набору.</p>
<div>
<u>Предусловие</u>: <tt>!full()</tt>
</div>
<div>
<u>Постусловие</u>: <tt>size()</tt> увеличивается на <tt>1</tt>,
<tt>total_bytes()</tt> увеличивается на <tt>buf_len</tt>.</div>
</blockquote>
</div>

<div>
<pre class="prototype">void pop_back()</pre>
<blockquote>

<p>Удаляет последний добавленый в набор буфер.</p>
<div>
<u>Предусловие</u>: <tt>!empty()</tt>
</div>
<div>
<u>Постусловие</u>: <tt>size()</tt> уменьшается на <tt>1</tt>,
<tt>total_bytes()</tt> уменьшается на <tt>iov_len</tt> удалённого буфера.</div>
</blockquote>
</div>

<div>
<pre class="prototype">::iovec *ptr()</pre>
<pre class="prototype">const ::iovec *ptr() const</pre>
<blockquote>


<p>Возвращает указатель на массив выходных векторов.</p>
</blockquote>
</div>

<div>
<pre class="prototype">unsigned size() const</pre>
<blockquote>

<p>Возвращает текущее количество векторов в массиве.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool full() const</pre>
<blockquote>

<p>Возвращает <tt>size() == max_size()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool empty() const</pre>
<blockquote>

<p>Возвращает <tt>size() == 0</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void clear()</pre>
<blockquote>

<p>Удаляет все буферы из набора.</p>
<div>
<u>Постусловие</u>: <tt>empty() &amp;&amp; total_bytes() == 0</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">static constexpr unsigned max_size()</pre>
<blockquote>

<p>Возвращает <tt>N</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">size_t total_bytes() const</pre>
<blockquote>

<p>Возвращает суммарное количество байт во всех буферах массива.</p>
</blockquote>
</div>



<div class="section">Пример</div>
<pre class="code">
__vic::posix::ovectors&lt;3&gt; v;
v.push_back("ovectors", 8);
v.push_back(" in work", 8);
const char nl = '\n';
v.push_back(&amp;nl, 1);

// Prints:
// ovectors in work
__vic::posix::writev_all(1, v); // ::writev(1, v.ptr(), v.size());
</pre>





<h3 id="posix--total-iovec">
<span class="h3_num">2.53.2</span><tt>posix::total(iovec[])</tt>
</h3>


<pre class="code">
namespace posix {

size_t total(const ::iovec vec[], unsigned vec_len);
template&lt;unsigned vsize&gt; size_t total(const ::iovec (&amp;vec)[vsize]);

}
</pre>

<p>Подсчитывает суммарный размер буферов в массиве <tt>vec</tt>.</p>




<h3 id="posix--cut_prefix-iovec">
<span class="h3_num">2.53.3</span><tt>posix::cut_prefix(iovec[])</tt>
</h3>


<pre class="code">
void posix::cut_prefix(::iovec *&amp;vec, unsigned &amp;vec_len, size_t n);
</pre>

<p>Удаляет из вектора <tt>vec</tt> первые <tt>n</tt> байтов. Возвращает
указатель на модифицированный набор буферов и новую длину вектора. Если
<tt>n</tt> больше суммарной длины всех буферов вектора, то <tt>vec_len</tt>
станет <tt>0</tt>, значение <tt>vec</tt> при этом неопределенно.</p>

<p>Функция полезна для возобновления прерванного сигналом системного вызова,
если записалась только часть данных.</p>




<h3 id="posix--writev_all">
<span class="h3_num">2.53.4</span><tt>posix::writev_all()</tt>
</h3>


<pre class="code">
namespace posix {

void writev_all(int fd, ::iovec vec[], unsigned vec_len, size_t total);

template&lt;unsigned vsize&gt;
void writev_all(int fd, ovectors&lt;vsize&gt; &amp;vec);

}
</pre>

<p>Функции записывают всё содержимое вектора <tt>vec</tt> в файловый дескриптор
<tt>fd</tt>. Параметр <tt>total</tt> должен содержать суммарный размер буферов
вектора (может быть посчитан вызовом <tt>__vic::posix::total(vec,
vec_len)</tt> или <tt>__vic::posix::total(vec)</tt>). Функция не прерывается
сигналами. В случае ошибок бросаются исключения.</p>






<h2 id="posix.mutex.h">
<span class="h2_num">2.54</span><tt>__vic/posix/mutex.h</tt>
</h2>



<h3 id="posix--mutex">
<span class="h3_num">2.54.1</span><tt>posix::mutex</tt>
</h3>


<pre class="code">
class posix::mutex
{
public:
    constexpr mutex() noexcept;
    ~mutex();

    mutex(const mutex &amp; ) = delete;
    mutex &amp;operator=(const mutex &amp; ) = delete;

    void lock();
    bool try_lock();
    bool unlock() noexcept;

    // System-specific handle
    ::pthread_mutex_t *handle();
    const ::pthread_mutex_t *handle() const;
};
</pre>

<p>Обёртка для простого нерекурсивного <tt>pthread_mutex_t</tt>. См. замечания
по использованию в <a href="#mutex"><tt>mutex</tt></a>.</p>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">constexpr mutex() noexcept</pre>
<blockquote>

<p>Создаёт незаблокированный мьютекс.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~mutex()</pre>
<blockquote>

<p>Уничтожает мьютекс.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void lock()</pre>
<blockquote>

<p>Захватывает блокировку на мьютексе. Ждёт его освобождения, если он уже
захвачен другим потоком в данный момент.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool try_lock()</pre>
<blockquote>

<p>Пытается захватить мьютекс. Немедленно возвращает <tt>false</tt> без
ожидания, если он уже захвачен другим потоком.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool unlock() noexcept</pre>
<blockquote>

<p>Освобождает ранее захваченный мьютекс. Иногда может возвращать <tt>false</tt>
в случае ошибок, но в общем случае обнаружение ошибок не гарантируется.</p>
</blockquote>
</div>

<div>
<pre class="prototype">::pthread_mutex_t *handle()</pre>
<pre class="prototype">const ::pthread_mutex_t *handle() const</pre>
<blockquote>


<p>Возвращает системный дескриптор мьютекса.</p>
</blockquote>
</div>



<div class="section">Пример</div>
<p>См. <a href="#posix--mutex_lock"><tt>posix::mutex_lock</tt></a>.</p>





<h3 id="posix--mutex_lock">
<span class="h3_num">2.54.2</span><tt>posix::mutex_lock</tt>
</h3>


<pre class="code">
class posix::mutex_lock : private non_copyable, private non_heap_allocatable
{
public:
    enum adopt_t { adopt };

    explicit mutex_lock(posix::mutex &amp;mtx);
    mutex_lock(posix::mutex &amp;mtx, adopt_t);

    explicit mutex_lock(::pthread_mutex_t &amp;mtx);
    mutex_lock(::pthread_mutex_t &amp;mtx, adopt_t);

    ~mutex_lock() noexcept(false);
};
</pre>

<p>Управляет блокировкой на мьютексе. Снимает блокировку по окончании времени
жизни объекта. Способен работать как с <tt>posix::mutex</tt>, так и с системным
<tt>pthread_mutex_t</tt>.</p>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">adopt</pre>
<blockquote>

<p>Тэг конструктора, подавляет захват мьютекса.</p>
</blockquote>
</div>

<div>
<pre class="prototype">explicit mutex_lock(posix::mutex &amp;mtx)</pre>
<pre class="prototype">explicit mutex_lock(::pthread_mutex_t &amp;mtx)</pre>
<blockquote>


<p>Захватывает <tt>mtx</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~mutex_lock() noexcept(false)</pre>
<blockquote>

<p>Освобождает <tt>mtx</tt>. Может бросить исключение, если произошла ошибка
и нет другого активного исключения!</p>
</blockquote>
</div>

<div>
<pre class="prototype">mutex_lock(posix::mutex &amp;mtx, adopt_t)</pre>
<pre class="prototype">mutex_lock(::pthread_mutex_t &amp;mtx, adopt_t)</pre>
<blockquote>


<p>Принимает уже захваченный <tt>mtx</tt>. См. пример.</p>
</blockquote>
</div>



<div class="section">Пример</div>
<pre class="code">
// Типичное использование
void reentrant_function()
{
    static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
    __vic::posix::mutex_lock lock(mtx);
    // Критическая секция до конца этого блока
    ...
}

// Использование незахватывающего конструктора
__vic::posix::mutex mtx;
if(mtx.try_lock()) // Пытаемся захватить мьютекс
{
    // Мьютекс успешно захвачен
    using __vic::posix::mutex_lock;
    mutex_lock lock(mtx, mutex_lock::adopt);
    // Критическая секция до конца этого блока
    ...
}
else
{
    // Мьютекс удерживается другим потоком
    ...
}
</pre>







<h2 id="posix.pidfile.h">
<span class="h2_num">2.55</span><tt>__vic/posix/pidfile.h</tt>
</h2>


<h3 id="posix--pidfile">
<span class="h3_num">2.55.1</span><tt>posix::pidfile</tt>
</h3>


<pre class="code">
class posix::pidfile : private non_copyable
{
public:
    class already_exists; // : public std::exception

    explicit pidfile(std::string file_name);
    ~pidfile();

    void create();
    void prepare_to_daemon();
    void rewrite_pid();
};
</pre>

<p>Класс предназначен для работы с PID-файлами. То есть файлами, хранящими PID
процесса, обычно являющегося процессом-демоном. Механизм используется для
корректной остановки работы демона, а также для защиты от одновременного
запуска нескольких экземпляров процесса.</p>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">class already_exists</pre>
<blockquote>

<p>Исключение. См. описание <tt>create()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">explicit pidfile(std::string file_name)</pre>
<blockquote>

<p>Задаёт имя PID-файла.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~pidfile()</pre>
<blockquote>

<p>Удаляет PID-файл с диска.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void create()</pre>
<blockquote>

<p>Создаёт PID-файл с именем, указанным в конструкторе. Если такой PID-файл
уже создан другим экземпляром процесса, бросает <tt>already_exists</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void prepare_to_daemon()</pre>
<blockquote>

<p>Данную функцию необходимо вызывать перед системным вызовом
<tt>daemon()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void rewrite_pid()</pre>
<blockquote>

<p>Обновляет PID процесса в PID-файле. В частности PID меняется после
системного вызова <tt>daemon()</tt>.</p>
</blockquote>
</div>







<h2 id="posix.process.h">
<span class="h2_num">2.56</span><tt>__vic/posix/process.h</tt>
</h2>


<p>Инструменты для работы с процессами ОС.</p>


<h3 id="posix--daemon">
<span class="h3_num">2.56.1</span><tt>posix::daemon()</tt>
</h3>


<pre class="code">
void posix::daemon(bool nochdir, bool noclose = false);
</pre>

<p>Делает вызывающий процесс UNIX-демоном. Вызов является полным аналогом
одноимённого системного вызова из BSD и является просто редиректором к нему на
тех системах, где вызов реализован (*BSD, Linux, QNX). В случае ошибок функция
бросает исключения.</p>




<h3 id="posix--ignore_signals">
<span class="h3_num">2.56.2</span><tt>posix::ignore_signals()</tt>
</h3>


<pre class="code">
namespace posix {

void ignore_signals(const int sigs[], size_t sigs_len);
template&lt;size_t Size&gt; void ignore_signals(const int (&amp;sigs)[Size]);
// BEGIN C++11
void ignore_signals(std::initializer_list&lt;int&gt; sigs);
// END C++11

}
</pre>

<p>Игнорировать указанные сигналы (используется вызов <tt>sigaction()</tt>).</p>

<div class="section">Пример</div>
<pre class="code">
int sigs[] = { SIGINT, SIGQUIT, SIGTERM };
__vic::posix::ignore_signals(sigs);

// или в C++11 просто
__vic::posix::ignore_signals({SIGINT, SIGQUIT, SIGTERM});
</pre>





<h3 id="posix--process_alive">
<span class="h3_num">2.56.3</span><tt>posix::process_alive()</tt>
</h3>


<pre class="code">
bool posix::process_alive(pid_t pid);
</pre>

<p>Возвращает <tt>true</tt>, если процесс с указанным PID существует и не
является зомби.</p>






<h2 id="posix.sigset.h">
<span class="h2_num">2.57</span><tt>__vic/posix/sigset.h</tt>
</h2>


<h3 id="posix--sigset">
<span class="h3_num">2.57.1</span><tt>posix::sigset</tt>
</h3>


<pre class="code">
class posix::sigset
{
public:
    sigset() = default;
    sigset(const ::sigset_t &amp;set);
    template&lt;size_t Size&gt; sigset(const int (&amp;sigs)[Size]);
    // BEGIN C++11
    sigset(std::initializer_list&lt;int&gt; sigs);
    sigset &amp;operator=(std::initializer_list&lt;int&gt; sigs)
    // END C++11

    sigset &amp;assign(const int *sigs, size_t n);
    template&lt;size_t Size&gt;
    sigset &amp;operator=(const int (&amp;sigs)[Size]);

    sigset &amp;add(int signo);
    sigset &amp;del(int signo);
    sigset &amp;operator+=(int signo);
    sigset &amp;operator-=(int signo);
    sigset &amp;operator&lt;&lt;(int signo);
    sigset &amp;operator&gt;&gt;(int signo);

    sigset &amp;fill();
    sigset &amp;clear();

    static sigset full();
    static sigset empty();

    bool is_member(int signo) const;
    bool contains(int signo) const;

    operator ::sigset_t &amp;();
    operator const ::sigset_t &amp;() const;

    ::sigset_t *operator&amp;();
    const ::sigset_t *operator&amp;() const;
};
</pre>

<p>Удобная C++ обёртка для системного типа <tt>sigset_t</tt>. Набор операций
определён в виде C++-операторов и функций-членов.</p>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">sigset()</pre>
<blockquote>

<p>Создаёт неинициализированный объект.</p>
</blockquote>
</div>

<div>
<pre class="prototype">sigset(const ::sigset_t &amp;set)</pre>
<blockquote>

<p>Создаёт копию <tt>set</tt>. Неявный преобразователь из типа
<tt>sigset_t</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">sigset(std::initializer_list&lt;int&gt; sigs) <span class="sign">[C++11]</span></pre>
<pre class="prototype">template&lt;size_t Size&gt; sigset(const int (&amp;sigs)[Size])</pre>
<blockquote>


<p>Создаёт набор, заполненный сигналами из <tt>sigs</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">sigset &amp;operator=(std::initializer_list&lt;int&gt; sigs) <span class="sign">[C++11]</span></pre>
<pre class="prototype">template&lt;size_t Size&gt; sigset &amp;operator=(const int (&amp;sigs)[Size])</pre>
<pre class="prototype">sigset &amp;assign(const int *sigs, size_t n)</pre>
<blockquote>



<p>Вызывает <tt>clear()</tt> и заполняет набор сигналами из <tt>sigs</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">sigset &amp;add(int signo)</pre>
<pre class="prototype">sigset &amp;operator+=(int signo)</pre>
<pre class="prototype">sigset &amp;operator&lt;&lt;(int signo)</pre>
<blockquote>



<p>Добавляет сигнал к набору.</p>
</blockquote>
</div>

<div>
<pre class="prototype">sigset &amp;del(int signo)</pre>
<pre class="prototype">sigset &amp;operator-=(int signo)</pre>
<pre class="prototype">sigset &amp;operator&gt;&gt;(int signo)</pre>
<blockquote>



<p>Удаляет сигнал из набора.</p>
</blockquote>
</div>

<div>
<pre class="prototype">sigset &amp;fill()</pre>
<blockquote>

<p>Заполняет набор всеми сигналами (<tt>sigfillset()</tt>).</p>
</blockquote>
</div>

<div>
<pre class="prototype">sigset &amp;clear()</pre>
<blockquote>

<p>Очищает набор - удаляет все сигналы из набора (<tt>sigemptyset()</tt>).</p>
</blockquote>
</div>

<div>
<pre class="prototype">static sigset full()</pre>
<blockquote>

<p>Создаёт полный набор сигналов.</p>
</blockquote>
</div>

<div>
<pre class="prototype">static sigset empty()</pre>
<blockquote>

<p>Создаёт пустой набор сигналов.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool is_member(int signo)</pre>
<pre class="prototype">bool contains(int signo)</pre>
<blockquote>


<p>Проверяет, содержит ли набор <tt>signo</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">operator ::sigset_t &amp;()</pre>
<pre class="prototype">operator const ::sigset_t &amp;() const</pre>
<blockquote>


<p>Неявный преобразователь в <tt>sigset_t</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">::sigset_t *operator&amp;()</pre>
<pre class="prototype">const ::sigset_t *operator&amp;() const</pre>
<blockquote>


<p>Перегруженный оператор адреса.</p>
</blockquote>
</div>



<div class="section">Пример</div>
<pre class="code">
using __vic::posix::sigset;
namespace this_thread = __vic::posix::this_thread;

// Ожидаем все сигналы, кроме SIGTERM и SIGQUIT
int sig = this_thread::sigwait( sigset::full() &gt;&gt; SIGTERM &gt;&gt; SIGQUIT );

// Ждём Ctrl+C
this_thread::sigwait( sigset::empty() &lt;&lt; SIGINT );
// или в C++11
this_thread::sigwait( sigset{ SIGINT } );
</pre>






<h2 id="posix.thread.h">
<span class="h2_num">2.58</span><tt>__vic/posix/thread.h</tt>
</h2>


<p>C++ обёртки для Pthreads.</p>


<h3 id="posix--this_thread">
<span class="h3_num">2.58.1</span><tt>posix::this_thread</tt>
</h3>


<pre class="code">
namespace posix::this_thread { ... }
</pre>

<p>Набор функций для управления текущим потоком.</p>




<h3 id="posix--this_thread--sigwait">
<span class="h3_num">2.58.2</span><tt>posix::this_thread::sigwait()</tt>,
       <tt>posix::this_thread::sigwait_at_most()</tt>
</h3>


<pre class="code">
namespace posix::this_thread
{
    int sigwait(const ::sigset_t &amp;set);

    int sigwait_at_most(const ::sigset_t &amp;set, const ::timespec &amp;timeout);
}
</pre>

<p><tt>sigwait()</tt> приостанавливает текущий поток до получения сигнала из
набора <tt>set</tt>. Полученный сигнал возвращается в качестве результата.</p>

<p><tt>sigwait_at_most()</tt> - то же самое, но ждёт не дольше указанного
таймаута. Возвращает <tt>0</tt> в случае таймаута, либо в случае прывания
сигналом не из указанного набора.</p>




<h3 id="posix--this_thread--sigwaitinfo">
<span class="h3_num">2.58.3</span><tt>posix::this_thread::sigwaitinfo()</tt>,
       <tt>posix::this_thread::sigwaitinfo_at_most()</tt>
</h3>


<pre class="code">
namespace posix::this_thread
{
    ::siginfo_t sigwaitinfo(const ::sigset_t &amp;set);

    bool sigwaitinfo_at_most(const ::sigset_t &amp;set,
        const ::timespec &amp;timeout, ::siginfo_t &amp;res);
}
</pre>

<p><tt>sigwaitinfo()</tt> - аналог <tt>sigwait()</tt>, но возвращает
дополнительную информацию о полученном сигнале. Сам сигнал возвращается в поле
<tt>si_signo</tt>.</p>

<div>
<u><b>Замечание</b></u>: Функция не прерывается сигналами, в отличие от одноимённого системного
вызова.</div>

<p><tt>sigwaitinfo_at_most()</tt> - то же самое, но ждёт не дольше указанного
таймаута. Возвращает <tt>false</tt> в случае таймаута, либо в случае прывания
сигналом не из указанного набора. Если вернула <tt>true</tt>, то <tt>res</tt>
содержит заполненную структуру <tt>siginfo_t</tt>.</p>

<div>
<u><b>Замечание</b></u>: Перед использованием любой из этих функций, для каждого сигнала из
<tt>set</tt> должна быть вызвана <tt>::sigaction()</tt> с <tt>sa_flags</tt>
содержащим <tt>SA_SIGINFO</tt>! В противном случае возвращаемое в
<tt>siginfo_t</tt> значение будет содержать мусор!</div>




<h3 id="posix--this_thread--block_signals">
<span class="h3_num">2.58.4</span><tt>posix::this_thread::block_signals()</tt>,
       <tt>posix::this_thread::unblock_signals()</tt>,
       <tt>posix::this_thread::set_sigmask()</tt>
</h3>


<pre class="code">
namespace posix::this_thread
{
    void block_signals(const ::sigset_t &amp;mask,
                                ::sigset_t *oldmask = nullptr);
    void unblock_signals(const ::sigset_t &amp;mask,
                                ::sigset_t *oldmask = nullptr);
    void set_sigmask(const ::sigset_t &amp;mask, ::sigset_t *oldmask = nullptr);
}
</pre>

<p><tt>block_signals()</tt> добавляет сигналы из набора к блокируемым в текущем
потоке.</p>

<p><tt>unblock_signals()</tt> удаляет сигналы из набора блокируемых в текущем
потоке.</p>

<p><tt>set_sigmask()</tt> устанавливает маску блокируемых сигналов для текущего
потока. Все сигналы из набора блокируются, остальные - нет.</p>






<h2 id="posix.time.h">
<span class="h2_num">2.59</span><tt>__vic/posix/time.h</tt>
</h2>


<p>Утилиты POSIX для работы со временем.</p>


<h3 id="posix--time_spec">
<span class="h3_num">2.59.1</span><tt>posix::time_spec</tt>
</h3>


<pre class="code">
struct posix::time_spec : ::timespec
{
    // Unit tags
    enum sec_units { sec };
    enum msec_units { msec };
    enum usec_units { usec };
    enum nsec_units { nsec };

    time_spec() = default;
    time_spec(time_t secs, long nsecs);

    time_spec(time_t secs, sec_units);
    time_spec(time_t msecs, msec_units);
    time_spec(time_t usecs, usec_units);
    time_spec(time_t nsecs, nsec_units);

    // BEGIN C++11
    template&lt;class Rep, class Period&gt;
    time_spec(std::chrono::duration&lt;Rep,Period&gt; d);

    operator std::chrono::nanoseconds() const;

    template&lt;class Rep, class Period&gt;
    time_spec &amp;operator+=(std::chrono::duration&lt;Rep,Period&gt; t2);
    template&lt;class Rep, class Period&gt;
    time_spec &amp;operator-=(std::chrono::duration&lt;Rep,Period&gt; t2);
    // END C++11

    time_spec &amp;operator+=(time_spec t2);
    time_spec &amp;operator-=(time_spec t2);
};

bool operator==(time_spec t1, time_spec t2);
bool operator!=(time_spec t1, time_spec t2);
bool operator&lt; (time_spec t1, time_spec t2);
bool operator&gt; (time_spec t1, time_spec t2);
bool operator&lt;=(time_spec t1, time_spec t2);
bool operator&gt;=(time_spec t1, time_spec t2);

time_spec operator+(time_spec t1, time_spec t2);
time_spec operator-(time_spec t1, time_spec t2);
</pre>

<p>Удобная С++ обёртка для манипуляций с системным типом <tt>timespec</tt>.
Позволяет задавать время в различных единицах, а также складывать, отнимать и
сравнивать значения с использованием операторов C++.</p>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">enum sec_units { sec }</pre>
<pre class="prototype">enum msec_units { msec }</pre>
<pre class="prototype">enum usec_units { usec }</pre>
<pre class="prototype">enum nsec_units { nsec }</pre>
<blockquote>




<p>Тэги конструкторов для указания единиц измерения.</p>
</blockquote>
</div>

<div>
<pre class="prototype">time_spec()</pre>
<blockquote>

<p>Создаёт неинициализированный объект.</p>
</blockquote>
</div>

<div>
<pre class="prototype">time_spec(time_t secs, long nsecs)</pre>
<blockquote>

<p>Заполняет поля структуры указанными значениями.</p>
</blockquote>
</div>

<div>
<pre class="prototype">time_spec(time_t secs, sec_units)</pre>
<pre class="prototype">time_spec(time_t msecs, msec_units)</pre>
<pre class="prototype">time_spec(time_t usecs, usec_units)</pre>
<pre class="prototype">time_spec(time_t nsecs, nsec_units)</pre>
<blockquote>




<p>Задаёт время в секундах, миллисекундах, микросекундах и наносекундах,
соответсвенно.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class Rep, class Period&gt;
time_spec(std::chrono::duration&lt;Rep,Period&gt; d) <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Создаёт <tt>time_spec</tt> из <tt>std::chrono::duration</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">operator std::chrono::nanoseconds() const <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Преобразует значение в наносекунды.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class Rep, class Period&gt;
time_spec &amp;operator+=(std::chrono::duration&lt;Rep,Period&gt; t2) <span class="sign">[C++11]</span></pre>
<pre class="prototype">time_spec &amp;operator+=(time_spec t2)</pre>
<pre class="prototype">time_spec operator+(time_spec t1, time_spec t2)</pre>
<blockquote>



<p>Складывает два значения.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class Rep, class Period&gt;
time_spec &amp;operator-=(std::chrono::duration&lt;Rep,Period&gt; t2) <span class="sign">[C++11]</span></pre>
<pre class="prototype">time_spec &amp;operator-=(time_spec t2)</pre>
<pre class="prototype">time_spec operator-(time_spec t1, time_spec t2)</pre>
<blockquote>



<p>Вычисляет разность двух значений.</p>
<div>
<u>Предусловие</u>: <tt>t2 &lt;= t1</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool operator==(time_spec t1, time_spec t2)</pre>
<pre class="prototype">bool operator!=(time_spec t1, time_spec t2)</pre>
<pre class="prototype">bool operator&lt; (time_spec t1, time_spec t2)</pre>
<pre class="prototype">bool operator&gt; (time_spec t1, time_spec t2)</pre>
<pre class="prototype">bool operator&lt;=(time_spec t1, time_spec t2)</pre>
<pre class="prototype">bool operator&gt;=(time_spec t1, time_spec t2)</pre>
<blockquote>






<p>Операторы сравнения.</p>
</blockquote>
</div>



<div class="section">Пример</div>
<pre class="code">
__vic::posix::time_spec t(5, __vic::posix::time_spec::sec);
::nanosleep(&amp;t, nullptr); // sleep for 5 sec
</pre>





<h3 id="posix--nanoseconds_since_epoch">
<span class="h3_num">2.59.2</span><tt>posix::nanoseconds_since_epoch()</tt>
</h3>


<pre class="code">
posix::time_spec posix::nanoseconds_since_epoch();
</pre>

<p>Возвращает текущее количество секунд и наносекунд, прошедшее с наступления
эпохи UNIX. Использует <tt>posix::realtime_clock::get_time()</tt> для получения
значения, если он доступен. Реальная точность зависит от используемой платформы.
</p>




<h3 id="posix--realtime_clock">
<span class="h3_num">2.59.3</span><tt>posix::realtime_clock</tt>, <tt>posix::monotonic_clock</tt>
</h3>


<pre class="code">
#if _POSIX_TIMERS &gt; 0

class posix::realtime_clock
{
public:
    static constexpr clockid_t id = CLOCK_REALTIME;
    static constexpr bool is_steady = false;
    // BEGIN C++11
    using duration   = std::chrono::nanoseconds;
    using period     = duration::period;
    using rep        = duration::rep;
    using time_point = std::chrono::time_point&lt;realtime_clock, duration&gt;;

    static time_point now();
    // END C++11

    static posix::time_spec get_time();
};
#ifdef _POSIX_MONOTONIC_CLOCK
class posix::monotonic_clock
{
public:
    static constexpr clockid_t id = CLOCK_MONOTONIC;
    static constexpr bool is_steady = true;
    // BEGIN C++11
    using duration   = std::chrono::nanoseconds;
    using period     = duration::period;
    using rep        = duration::rep;
    using time_point = std::chrono::time_point&lt;monotonic_clock, duration&gt;;

    static time_point now();
    // END C++11

    static posix::time_spec get_time();
};
#endif

#endif
</pre>

<p>Системные часы POSIX (<tt>clock_gettime()</tt>) с интерфейсом часов
<tt>&lt;chrono&gt;</tt>. Отсутсвуют в системах, которые их не поддерживают
(проверяется макросом <tt>_POSIX_TIMERS</tt>). Дополнительно,
<tt>monotonic_clock</tt> доступен только, если определён макрос
<tt>_POSIX_MONOTONIC_CLOCK</tt>.</p>

<div class="section">Члены класса</div>

<div>
<pre class="prototype">static constexpr clockid_t id</pre>
<blockquote>

<p>Системный ID часов.</p>
</blockquote>
</div>

<div>
<pre class="prototype">static time_spec get_time()</pre>
<blockquote>

<p>Возвращает текущее время в виде <tt>posix::time_spec</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">static time_point now() <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Возвращает текущее время в виде <tt>time_point</tt>.</p>
</blockquote>
</div>










<h1 id="build">
<span class="h1_num">3</span>Сборка и установка</h1>

<p>Для сборки библиотеки требуется один из поддерживаемых компиляторов C++ и
утилита <a href="https://www.gnu.org/software/make">GNU Make</a> версии
3.82 или выше доступные в Вашем окружении командной строки (shell).</p>

<p>На текущий момент поддерживаются следующие компиляторы:</p>
<ul>
<li>GNU C++ v 4.7+ [<tt>gcc</tt>]</li>
<li>Clang v 3.4+ [<tt>clang</tt>]</li>
</ul>

<p>Перейдите в подкаталог <tt>src</tt> и наберите:</p>
<pre class="code">
$ gmake
</pre>
<p>Файл библиотеки будет собран.</p>

<p>По умолчанию используется C++17, но используя параметр <tt>std</tt> можно
задать версию явно. Например для сборки в режиме C++98 наберите:</p>
<pre class="code">
$ gmake std=98
</pre>

<p>Доступные значения включают: 98, 11, 14, 17, 20 и 23.</p>

<p>Также можно вручную выбрать используемый компилятор:</p>
<pre class="code">
$ gmake compiler=gcc
</pre>

<p>Для генерации position-independent code (PIC), который позволяет компоновать
библиотеку с shared object, наберите:</p>
<pre class="code">
$ gmake pic=1
</pre>

<p>Для сборки на FreeBSD 10+ вместо gmake может использоваться утилита
<a href="https://www.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1">
bmake</a>:</p>
<pre class="code">
$ make -f Makefile.freebsd
</pre>

<p>После всего этого нужно скопировать получившийся файл библиотеки и содержимое
подкаталога <tt>include</tt> туда, где компилятор/компоновщик смогут их найти,
например в <tt>/usr/local/include</tt> и <tt>/usr/local/lib</tt>.</p>



</div></body>
</html>
