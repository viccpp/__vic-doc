<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>__vic's C++ library (Windows)</title>
<style type="text/css">
body {
	font-family: verdana, sans-serif;
	font-size: 10pt;
	background-color: #777777;
	margin: 0;
}
div.page-wrap {
	background-color: white;
	width: 210mm; /* A4 */
	margin: 0 auto;
	padding: 2mm 5mm;
}
p, div {
	margin-top: 6pt;
	margin-bottom: 0;
}
h1, h2, h3, h4, h5, h6 {
	font-weight: bold;
	margin-top: 9pt;
	margin-bottom: 12pt;
	margin-left: 0;
}
h1 { font-size: 16pt; }
h2 { font-size: 13pt; }
h3 { font-size: 11pt; }
h4 { font-size: 11pt; }
span.h1_num, span.h2_num {
	margin-right: 2em;
	font-family: sans-serif;
}
span.h3_num, span.h4_num {
	margin-right: 2em;
	font-weight: normal;
	font-size: smaller;
}
h1.main-title {
	font-size: 2em;
	font-weight: bold;
}
caption.toc {
	text-align: left;
	font-weight: bold;
	font-size: 13pt;
	margin-top: 9pt;
	margin-bottom: 12pt;
	margin-left: 0;
}
td.toc-chapter-no {
	padding-right: 1ex;
	vertical-align: top;
}
a { text-decoration: none; }
a:hover { text-decoration: underline; }
pre.code {
	background-color: #EEE;
	border: 1px solid #CCCCCC;
	padding-top: 6pt;
	padding-bottom: 6pt;
	padding-left: 2pt;
	font-family: monospace;
	font-size: 10pt;
	width: 17.3cm; /* 80ch */
}
pre.prototype {
	font-family: monospace;
	margin-top: 0;
	margin-bottom: 0;
}
div.section {
	font-weight: bold;
}
div.todo {
	color: red;
	font-weight: bold;
}
span.ver {
	font-size: smaller;
	color: #C0C0C0;
}
span.nonterminal {
	font-family: monospace;
	font-style: italic;
}
span.sign {
	color: #C0C0C0;
	font-family: monospace;
	font-size: 9pt;
	font-weight: bold;
}
blockquote {
	margin-top: 6pt;
	margin-bottom: 0;
	margin-right: 0;
}
blockquote * {
	margin-top: 0;
	margin-bottom: 0;
}
</style>
</head>
<body><div class="page-wrap">
<h1 class="main-title">__vic's C++ library (Windows)<span class="ver"> v1.0 [Draft]</span>
</h1>
<table style="font-size:10pt;" cellspacing="0" cellpadding="0">
<caption class="toc">Contents</caption>
<tr>
<td class="toc-chapter-no">1</td>
<td><a href="#intro">Introduction</a></td>
</tr>
<tr>
<td class="toc-chapter-no">1.1</td>
<td><a href="#why">Why this library was created?</a></td>
</tr>
<tr>
<td class="toc-chapter-no">1.2</td>
<td><a href="#general-structure">General structure and usage</a></td>
</tr>
<tr><td colspan="2" style="font-size:5pt;"> </td></tr>
<tr>
<td class="toc-chapter-no">2</td>
<td><a href="#components-reference">Library components reference</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1</td>
<td><a href="#defs.h"><tt>__vic/defs.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1.1</td>
<td style="padding-left:4ex"><a href="#nullptr"><tt>nullptr</tt> <span class="sign">[C++98 only]</span></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1.2</td>
<td style="padding-left:4ex"><a href="#noexcept"><tt>noexcept</tt> <span class="sign">[C++98 only]</span></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1.3</td>
<td style="padding-left:4ex"><a href="#array_size"><tt>array_size()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1.4</td>
<td style="padding-left:4ex"><a href="#non_copyable"><tt>non_copyable</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1.5</td>
<td style="padding-left:4ex"><a href="#non_heap_allocatable"><tt>non_heap_allocatable</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1.6</td>
<td style="padding-left:4ex"><a href="#std--move"><tt>std::move()</tt>, <tt>std::forward()</tt>, <tt>std::swap()</tt>
<span class="sign">[C++11]</span></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1.7</td>
<td style="padding-left:4ex"><a href="#VIC_SWAP_HEADER"><tt>__VIC_SWAP_HEADER</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.1.8</td>
<td style="padding-left:4ex"><a href="#platform-dependent-macros">Platform-dependent macros</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.2</td>
<td><a href="#algorithm.h"><tt>__vic/algorithm.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.2.1</td>
<td style="padding-left:4ex"><a href="#skip_if_front"><tt>skip_if_front()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.2.2</td>
<td style="padding-left:4ex"><a href="#skip_if_back"><tt>skip_if_back()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.3</td>
<td><a href="#ascii.h"><tt>__vic/ascii.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.3.1</td>
<td style="padding-left:4ex"><a href="#ascii--is-functions"><tt>ascii::is</tt>-functions</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.3.2</td>
<td style="padding-left:4ex"><a href="#ascii--todigit"><tt>ascii::todigit()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.3.3</td>
<td style="padding-left:4ex"><a href="#ascii--toxdigit"><tt>ascii::toxdigit_upper()</tt>, <tt>ascii::toxdigit_lower()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.3.4</td>
<td style="padding-left:4ex"><a href="#ascii--digit_to_number"><tt>ascii::digit_to_number()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.3.5</td>
<td style="padding-left:4ex"><a href="#ascii--xdigit_to_number"><tt>ascii::xdigit_to_number()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.3.6</td>
<td style="padding-left:4ex"><a href="#ascii--tolower-char"><tt>ascii::tolower(char)</tt>, <tt>ascii::toupper(char)</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.3.7</td>
<td style="padding-left:4ex"><a href="#ascii--equal_icase-char"><tt>ascii::equal_icase(char,char)</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.4</td>
<td><a href="#ascii_string.h"><tt>__vic/ascii_string.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.4.1</td>
<td style="padding-left:4ex"><a href="#ascii--tolower-str"><tt>ascii::tolower()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.4.2</td>
<td style="padding-left:4ex"><a href="#ascii--toupper-str"><tt>ascii::toupper()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.4.3</td>
<td style="padding-left:4ex"><a href="#ascii--equal_icase-str"><tt>ascii::equal_icase()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5</td>
<td><a href="#base16.h"><tt>__vic/base16.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.1</td>
<td style="padding-left:4ex"><a href="#base16"><tt>base16</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.2</td>
<td style="padding-left:4ex"><a href="#base16--bad_format"><tt>base16::bad_format</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.3</td>
<td style="padding-left:4ex"><a href="#base16--bad_digit"><tt>base16::bad_digit</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.4</td>
<td style="padding-left:4ex"><a href="#base16--bad_length"><tt>base16::bad_length</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.5</td>
<td style="padding-left:4ex"><a href="#base16--status"><tt>base16::status</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.6</td>
<td style="padding-left:4ex"><a href="#base16--encode_upper"><tt>base16::encode_upper()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.7</td>
<td style="padding-left:4ex"><a href="#base16--encode_lower"><tt>base16::encode_lower()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.8</td>
<td style="padding-left:4ex"><a href="#base16--encode_byte_lower"><tt>base16::encode_byte_lower()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.9</td>
<td style="padding-left:4ex"><a href="#base16--encode_byte_upper"><tt>base16::encode_byte_upper()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.10</td>
<td style="padding-left:4ex"><a href="#base16--decode"><tt>base16::decode()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.5.11</td>
<td style="padding-left:4ex"><a href="#base16--try_decode"><tt>base16::try_decode()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6</td>
<td><a href="#base64.h"><tt>__vic/base64.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.1</td>
<td style="padding-left:4ex"><a href="#base64"><tt>base64</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.2</td>
<td style="padding-left:4ex"><a href="#base64--bad_format"><tt>base64::bad_format</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.3</td>
<td style="padding-left:4ex"><a href="#base64--bad_digit"><tt>base64::bad_digit</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.4</td>
<td style="padding-left:4ex"><a href="#base64--bad_length"><tt>base64::bad_length</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.5</td>
<td style="padding-left:4ex"><a href="#base64--status"><tt>base64::status</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.6</td>
<td style="padding-left:4ex"><a href="#base64--encode"><tt>base64::encode()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.7</td>
<td style="padding-left:4ex"><a href="#base64--decode"><tt>base64::decode()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.8</td>
<td style="padding-left:4ex"><a href="#base64--try_decode"><tt>base64::try_decode()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.9</td>
<td style="padding-left:4ex"><a href="#base64--encoded_length"><tt>base64::encoded_length()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.6.10</td>
<td style="padding-left:4ex"><a href="#base64--max_decoded_length"><tt>base64::max_decoded_length()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.7</td>
<td><a href="#bin_file.h"><tt>__vic/bin_file.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.7.1</td>
<td style="padding-left:4ex"><a href="#bin_file"><tt>bin_file</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8</td>
<td><a href="#bits.h"><tt>__vic/bits.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.1</td>
<td style="padding-left:4ex"><a href="#lo_nibble"><tt>lo_nibble()</tt>, <tt>hi_nibble()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.2</td>
<td style="padding-left:4ex"><a href="#msb_ones"><tt>msb_ones()</tt>, <tt>lsb_ones()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.3</td>
<td style="padding-left:4ex"><a href="#get_lsbs"><tt>get_lsbs()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.4</td>
<td style="padding-left:4ex"><a href="#ord"><tt>ord()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.5</td>
<td style="padding-left:4ex"><a href="#popcount"><tt>popcount()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.6</td>
<td style="padding-left:4ex"><a href="#msb_position"><tt>msb_position()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.7</td>
<td style="padding-left:4ex"><a href="#ispow2"><tt>ispow2()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.8</td>
<td style="padding-left:4ex"><a href="#ceil2"><tt>ceil2()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.9</td>
<td style="padding-left:4ex"><a href="#floor2"><tt>floor2()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.10</td>
<td style="padding-left:4ex"><a href="#ceil_log2"><tt>ceil_log2()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.11</td>
<td style="padding-left:4ex"><a href="#floor_log2"><tt>floor_log2()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.12</td>
<td style="padding-left:4ex"><a href="#rotl"><tt>rotl()</tt>, <tt>rotr()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.8.13</td>
<td style="padding-left:4ex"><a href="#swapped_nibbles"><tt>swapped_nibbles()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.9</td>
<td><a href="#date_time.h"><tt>__vic/date_time.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.9.1</td>
<td style="padding-left:4ex"><a href="#is_leap_year"><tt>is_leap_year()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.9.2</td>
<td style="padding-left:4ex"><a href="#days_in_month"><tt>days_in_month()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.9.3</td>
<td style="padding-left:4ex"><a href="#days_between_years"><tt>days_between_years()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.9.4</td>
<td style="padding-left:4ex"><a href="#invalid_date"><tt>invalid_date</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.9.5</td>
<td style="padding-left:4ex"><a href="#validate_date_time"><tt>validate_date()</tt>, <tt>validate_time()</tt>,
<tt>validate_date_time()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.10</td>
<td><a href="#endian.h"><tt>__vic/endian.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.10.1</td>
<td style="padding-left:4ex"><a href="#endianness"><tt>endianness</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.10.2</td>
<td style="padding-left:4ex"><a href="#endian--from"><tt>endian::from_...()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.10.3</td>
<td style="padding-left:4ex"><a href="#endian--to"><tt>endian::to_...()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.10.4</td>
<td style="padding-left:4ex"><a href="#swab"><tt>swab16()</tt>, <tt>swab32()</tt>, <tt>swab64()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.11</td>
<td><a href="#error.h"><tt>__vic/error.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.11.1</td>
<td style="padding-left:4ex"><a href="#exception"><tt>exception</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.11.2</td>
<td style="padding-left:4ex"><a href="#libc_error"><tt>libc_error</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.12</td>
<td><a href="#fixed_vector.h"><tt>__vic/fixed_vector.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.12.1</td>
<td style="padding-left:4ex"><a href="#fixed_vector"><tt>fixed_vector</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13</td>
<td><a href="#fs.h"><tt>__vic/fs.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.1</td>
<td style="padding-left:4ex"><a href="#path_exists"><tt>path_exists()</tt>, <tt>file_exists()</tt>, <tt>dir_exists()</tt>
</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.2</td>
<td style="padding-left:4ex"><a href="#mkdir"><tt>mkdir()</tt>, <tt>mkdir_if_absent()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.3</td>
<td style="padding-left:4ex"><a href="#rmdir"><tt>rmdir()</tt>, <tt>rmdir_if_exists()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.4</td>
<td style="padding-left:4ex"><a href="#get_current_dir"><tt>get_current_dir()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.5</td>
<td style="padding-left:4ex"><a href="#remove_file"><tt>remove_file()</tt>, <tt>remove_file_if_exists()</tt>,
<tt>remove_file_nt()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.6</td>
<td style="padding-left:4ex"><a href="#copy_file"><tt>copy_file()</tt>, <tt>copy_file_if_exists()</tt>,
<tt>copy_file_replace()</tt>, <tt>copy_file_replace_if_exists()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.7</td>
<td style="padding-left:4ex"><a href="#move_file"><tt>move_file()</tt>, <tt>move_file_if_exists()</tt>,
<tt>move_file_replace()</tt>, <tt>move_file_replace_if_exists()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.8</td>
<td style="padding-left:4ex"><a href="#rename_file"><tt>rename_file()</tt>, <tt>rename_file_if_exists()</tt>,
    <tt>rename_file_replace()</tt>, <tt>rename_file_replace_if_exists()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.13.9</td>
<td style="padding-left:4ex"><a href="#file_size"><tt>file_size()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.14</td>
<td><a href="#iterator.h"><tt>__vic/iterator.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.14.1</td>
<td style="padding-left:4ex"><a href="#begin-array"><tt>begin(T[])</tt>, <tt>end(T[])</tt>, <tt>cbegin(T[])</tt>,
<tt>cend(T[])</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.14.2</td>
<td style="padding-left:4ex"><a href="#advance"><tt>advance()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.14.3</td>
<td style="padding-left:4ex"><a href="#next"><tt>next()</tt>, <tt>prev()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.15</td>
<td><a href="#logger.h"><tt>__vic/logger.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.15.1</td>
<td style="padding-left:4ex"><a href="#logger"><tt>logger</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.16</td>
<td><a href="#memory.h"><tt>__vic/memory.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.16.1</td>
<td style="padding-left:4ex"><a href="#load_unaligned"><tt>load_unaligned()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.16.2</td>
<td style="padding-left:4ex"><a href="#store_unaligned"><tt>store_unaligned()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.17</td>
<td><a href="#mutex.h"><tt>__vic/mutex.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.17.1</td>
<td style="padding-left:4ex"><a href="#mutex"><tt>mutex</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.17.2</td>
<td style="padding-left:4ex"><a href="#mutex_lock"><tt>mutex_lock</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.18</td>
<td><a href="#packon.h"><tt>__vic/packon.h</tt> &amp; <tt>__vic/packoff.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.19</td>
<td><a href="#readers"><tt>__vic/readers/</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.19.1</td>
<td style="padding-left:4ex"><a href="#reader-concept"><tt>Reader</tt> concept</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.19.2</td>
<td style="padding-left:4ex"><a href="#iterator_reader"><tt>iterator_reader</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.19.3</td>
<td style="padding-left:4ex"><a href="#iterator_reader_n"><tt>iterator_reader_n</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.19.4</td>
<td style="padding-left:4ex"><a href="#container_reader"><tt>container_reader</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.19.5</td>
<td style="padding-left:4ex"><a href="#cstring_reader"><tt>cstring_reader</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.19.6</td>
<td style="padding-left:4ex"><a href="#string_reader"><tt>string_reader</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.19.7</td>
<td style="padding-left:4ex"><a href="#cstream_reader"><tt>cstream_reader</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.20</td>
<td><a href="#readonly_cstring.h"><tt>__vic/readonly_cstring.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.20.1</td>
<td style="padding-left:4ex"><a href="#readonly_cstring"><tt>readonly_cstring</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.21</td>
<td><a href="#set_of_chars.h"><tt>__vic/set_of_chars.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.21.1</td>
<td style="padding-left:4ex"><a href="#set_of_chars"><tt>set_of_chars</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.22</td>
<td><a href="#stdint.h"><tt>__vic/stdint.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.22.1</td>
<td style="padding-left:4ex"><a href="#intN_t">Exact-width integer types</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.22.2</td>
<td style="padding-left:4ex"><a href="#int_leastN_t">Minimum-width integer types</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.22.3</td>
<td style="padding-left:4ex"><a href="#int_fastN_t">Fastest minimum-width integer types</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.22.4</td>
<td style="padding-left:4ex"><a href="#intmax_t">Greatest-width integer types</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.22.5</td>
<td style="padding-left:4ex"><a href="#intptr_t">Integer types capable of holding object pointers</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.22.6</td>
<td style="padding-left:4ex"><a href="#int_exactly_bytes"><tt>int_exactly_bytes&lt;&gt;</tt>, <tt>uint_exactly_bytes&lt;&gt;</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.23</td>
<td><a href="#stdio_file.h"><tt>__vic/stdio_file.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.23.1</td>
<td style="padding-left:4ex"><a href="#stdio_file"><tt>stdio_file</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.23.2</td>
<td style="padding-left:4ex"><a href="#read-FILE-char"><tt>read(std::FILE, char&amp;)</tt>,
    <tt>read(std::FILE, unsigned char&amp;)</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.23.3</td>
<td style="padding-left:4ex"><a href="#write-FILE-char"><tt>write(std::FILE, char)</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.23.4</td>
<td style="padding-left:4ex"><a href="#getline-FILE"><tt>getline(std::FILE)</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.24</td>
<td><a href="#str2num.h"><tt>__vic/str2num.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.24.1</td>
<td style="padding-left:4ex"><a href="#decimal_to_number"><tt>decimal_to_number()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.24.2</td>
<td style="padding-left:4ex"><a href="#decimal_to_number_range"><tt>decimal_to_number_range()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.24.3</td>
<td style="padding-left:4ex"><a href="#decimal_parser"><tt>decimal_parser</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.24.4</td>
<td style="padding-left:4ex"><a href="#number_parse_status"><tt>number_parse_status</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.25</td>
<td><a href="#string_buffer.h"><tt>__vic/string_buffer.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.25.1</td>
<td style="padding-left:4ex"><a href="#string_buffer"><tt>string_buffer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.26</td>
<td><a href="#string_ref.h"><tt>__vic/string_ref.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.26.1</td>
<td style="padding-left:4ex"><a href="#string_ref"><tt>string_ref</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.27</td>
<td><a href="#string_utils.h"><tt>__vic/string_utils.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.27.1</td>
<td style="padding-left:4ex"><a href="#trim"><tt>trim</tt> functions</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.27.2</td>
<td style="padding-left:4ex"><a href="#sift"><tt>sift()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.27.3</td>
<td style="padding-left:4ex"><a href="#sift_if"><tt>sift_if()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.27.4</td>
<td style="padding-left:4ex"><a href="#pad_front"><tt>pad_front()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.27.5</td>
<td style="padding-left:4ex"><a href="#pad_back"><tt>pad_back()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.27.6</td>
<td style="padding-left:4ex"><a href="#starts_with"><tt>starts_with()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.27.7</td>
<td style="padding-left:4ex"><a href="#ends_with"><tt>ends_with()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28</td>
<td><a href="#tchar.h"><tt>__vic/tchar.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.1</td>
<td style="padding-left:4ex"><a href="#tchar--length"><tt>tchar::length()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.2</td>
<td style="padding-left:4ex"><a href="#tchar--empty"><tt>tchar::empty()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.3</td>
<td style="padding-left:4ex"><a href="#tchar--end"><tt>tchar::end()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.4</td>
<td style="padding-left:4ex"><a href="#tchar--compare"><tt>tchar::compare()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.5</td>
<td style="padding-left:4ex"><a href="#tchar--equal"><tt>tchar::equal()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.6</td>
<td style="padding-left:4ex"><a href="#tchar--copy"><tt>tchar::copy()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.7</td>
<td style="padding-left:4ex"><a href="#tchar--move"><tt>tchar::move()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.8</td>
<td style="padding-left:4ex"><a href="#tchar--concat"><tt>tchar::concat()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.9</td>
<td style="padding-left:4ex"><a href="#tchar--find"><tt>tchar::find()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.10</td>
<td style="padding-left:4ex"><a href="#tchar--rfind"><tt>tchar::rfind()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.11</td>
<td style="padding-left:4ex"><a href="#tchar--find_if"><tt>tchar::find_if()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.12</td>
<td style="padding-left:4ex"><a href="#tchar--find_if_not"><tt>tchar::find_if_not()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.13</td>
<td style="padding-left:4ex"><a href="#tchar--rfind_if"><tt>tchar::rfind_if()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.14</td>
<td style="padding-left:4ex"><a href="#tchar--rfind_if_not"><tt>tchar::rfind_if_not()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.15</td>
<td style="padding-left:4ex"><a href="#tchar--find_first_of"><tt>tchar::find_first_of()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.16</td>
<td style="padding-left:4ex"><a href="#tchar--find_first_not_of"><tt>tchar::find_first_not_of()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.17</td>
<td style="padding-left:4ex"><a href="#tchar--find_last_of"><tt>tchar::find_last_of()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.18</td>
<td style="padding-left:4ex"><a href="#tchar--find_last_not_of"><tt>tchar::find_last_not_of()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.28.19</td>
<td style="padding-left:4ex"><a href="#tchar--skip"><tt>tchar::skip()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.29</td>
<td><a href="#thread.h"><tt>__vic/thread.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.29.1</td>
<td style="padding-left:4ex"><a href="#thread"><tt>thread</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.29.2</td>
<td style="padding-left:4ex"><a href="#thread--id"><tt>thread::id</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.29.3</td>
<td style="padding-left:4ex"><a href="#this_thread"><tt>this_thread</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.30</td>
<td><a href="#throw_errno.h"><tt>__vic/throw_errno.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.30.1</td>
<td style="padding-left:4ex"><a href="#throw_errno"><tt>throw_errno()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.31</td>
<td><a href="#to_text.h"><tt>__vic/to_text.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.31.1</td>
<td style="padding-left:4ex"><a href="#to_text_append"><tt>to_text_append()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32</td>
<td><a href="#type_traits.h"><tt>__vic/type_traits.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.1</td>
<td style="padding-left:4ex"><a href="#integral_constant"><tt>integral_constant</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.2</td>
<td style="padding-left:4ex"><a href="#true_type"><tt>true_type</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.3</td>
<td style="padding-left:4ex"><a href="#false_type"><tt>false_type</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.4</td>
<td style="padding-left:4ex"><a href="#is_same"><tt>is_same</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.5</td>
<td style="padding-left:4ex"><a href="#is_const"><tt>is_const</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.6</td>
<td style="padding-left:4ex"><a href="#is_signed_integer"><tt>is_signed_integer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.7</td>
<td style="padding-left:4ex"><a href="#is_unsigned_integer"><tt>is_unsigned_integer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.8</td>
<td style="padding-left:4ex"><a href="#conjunction"><tt>conjunction</tt> <span class="sign">[C++11]</span></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.9</td>
<td style="padding-left:4ex"><a href="#disjunction"><tt>disjunction</tt> <span class="sign">[C++11]</span></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.10</td>
<td style="padding-left:4ex"><a href="#negation"><tt>negation</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.11</td>
<td style="padding-left:4ex"><a href="#remove_const"><tt>remove_const</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.12</td>
<td style="padding-left:4ex"><a href="#remove_volatile"><tt>remove_volatile</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.13</td>
<td style="padding-left:4ex"><a href="#remove_cv"><tt>remove_cv</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.14</td>
<td style="padding-left:4ex"><a href="#remove_reference"><tt>remove_reference</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.15</td>
<td style="padding-left:4ex"><a href="#remove_cvref"><tt>remove_cvref</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.16</td>
<td style="padding-left:4ex"><a href="#remove_pointer"><tt>remove_pointer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.17</td>
<td style="padding-left:4ex"><a href="#conditional"><tt>conditional</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.18</td>
<td style="padding-left:4ex"><a href="#enable_if"><tt>enable_if</tt>, <tt>disable_if</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.32.19</td>
<td style="padding-left:4ex"><a href="#index_sequence"><tt>index_sequence</tt>, <tt>make_index_sequence</tt> <span class="sign">[C++11]</span></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.33</td>
<td><a href="#unicode.h"><tt>__vic/unicode.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.33.1</td>
<td style="padding-left:4ex"><a href="#unicode_t"><tt>unicode_t</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.33.2</td>
<td style="padding-left:4ex"><a href="#utf_transcode"><tt>utf_transcode()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.33.3</td>
<td style="padding-left:4ex"><a href="#unicode_code_point_constants"><tt>Code point constants</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.34</td>
<td><a href="#utf8.status.h"><tt>__vic/utf8/status.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.34.1</td>
<td style="padding-left:4ex"><a href="#utf8--status"><tt>utf8::status</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.34.2</td>
<td style="padding-left:4ex"><a href="#utf8--is_error"><tt>utf8::is_error()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.34.3</td>
<td style="padding-left:4ex"><a href="#utf8--throw_if_error"><tt>utf8::throw_if_error()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.35</td>
<td><a href="#utf8.exceptions.h"><tt>__vic/utf8/exceptions.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.36</td>
<td><a href="#utf8.reader.h"><tt>__vic/utf8/reader.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.36.1</td>
<td style="padding-left:4ex"><a href="#utf8--reader"><tt>utf8::reader</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.37</td>
<td><a href="#utf8.writer.h"><tt>__vic/utf8/writer.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.37.1</td>
<td style="padding-left:4ex"><a href="#utf8--writer"><tt>utf8::writer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.38</td>
<td><a href="#utf16.defs.h"><tt>__vic/utf16/defs.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.38.1</td>
<td style="padding-left:4ex"><a href="#utf16--code_unit_t"><tt>utf16::code_unit_t</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.39</td>
<td><a href="#utf16.status.h"><tt>__vic/utf16/status.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.39.1</td>
<td style="padding-left:4ex"><a href="#utf16--status"><tt>utf16::status</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.39.2</td>
<td style="padding-left:4ex"><a href="#utf16--is_error"><tt>utf16::is_error()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.39.3</td>
<td style="padding-left:4ex"><a href="#utf16--throw_if_error"><tt>utf16::throw_if_error()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.40</td>
<td><a href="#utf16.exceptions.h"><tt>__vic/utf16/exceptions.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.41</td>
<td><a href="#utf16.reader.h"><tt>__vic/utf16/reader.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.41.1</td>
<td style="padding-left:4ex"><a href="#utf16--reader"><tt>utf16::reader</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.42</td>
<td><a href="#utf16.writer.h"><tt>__vic/utf16/writer.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.42.1</td>
<td style="padding-left:4ex"><a href="#utf16--writer"><tt>utf16::writer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.43</td>
<td><a href="#waitable_event.h"><tt>__vic/waitable_event.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.43.1</td>
<td style="padding-left:4ex"><a href="#waitable_event"><tt>waitable_event</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.44</td>
<td><a href="#writers"><tt>__vic/writers/</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.44.1</td>
<td style="padding-left:4ex"><a href="#writer-concept"><tt>Writer</tt> concept</a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.44.2</td>
<td style="padding-left:4ex"><a href="#null_writer"><tt>null_writer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.44.3</td>
<td style="padding-left:4ex"><a href="#push_back_writer"><tt>push_back_writer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.44.4</td>
<td style="padding-left:4ex"><a href="#iterator_writer"><tt>iterator_writer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.44.5</td>
<td style="padding-left:4ex"><a href="#string_writer"><tt>string_writer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.44.6</td>
<td style="padding-left:4ex"><a href="#cstream_writer"><tt>cstream_writer</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.45</td>
<td><a href="#windows.bitmap.h"><tt>__vic/windows/bitmap.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.45.1</td>
<td style="padding-left:4ex"><a href="#windows--Bitmap"><tt>windows::Bitmap</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.46</td>
<td><a href="#windows.critical_section.h"><tt>__vic/windows/critical_section.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.46.1</td>
<td style="padding-left:4ex"><a href="#windows--CriticalSection"><tt>windows::CriticalSection</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.46.2</td>
<td style="padding-left:4ex"><a href="#windows--CSGuard"><tt>windows::CSGuard</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.47</td>
<td><a href="#windows.dc.h"><tt>__vic/windows/dc.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.47.1</td>
<td style="padding-left:4ex"><a href="#windows--DC"><tt>windows::DC</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.47.2</td>
<td style="padding-left:4ex"><a href="#windows--ClientDC"><tt>windows::ClientDC</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.47.3</td>
<td style="padding-left:4ex"><a href="#windows--PaintDC"><tt>windows::PaintDC</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.48</td>
<td><a href="#windows.error.h"><tt>__vic/windows/error.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.48.1</td>
<td style="padding-left:4ex"><a href="#windows--error"><tt>windows::error</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.49</td>
<td><a href="#windows.event.h"><tt>__vic/windows/event.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.49.1</td>
<td style="padding-left:4ex"><a href="#windows--Event"><tt>windows::Event</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.50</td>
<td><a href="#windows.find_file.h"><tt>__vic/windows/find_file.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.50.1</td>
<td style="padding-left:4ex"><a href="#windows--FindFile"><tt>windows::FindFile</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.51</td>
<td><a href="#windows.handle.h"><tt>__vic/windows/handle.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.51.1</td>
<td style="padding-left:4ex"><a href="#windows--Handle"><tt>windows::Handle</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.51.2</td>
<td style="padding-left:4ex"><a href="#windows--WaitAbandoned"><tt>windows::WaitAbandoned</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.52</td>
<td><a href="#windows.shadow_dc.h"><tt>__vic/windows/shadow_dc.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.52.1</td>
<td style="padding-left:4ex"><a href="#windows--ShadowDC"><tt>windows::ShadowDC</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.53</td>
<td><a href="#windows.throw_last_error.h"><tt>__vic/windows/throw_last_error.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.53.1</td>
<td style="padding-left:4ex"><a href="#windows--throw_last_error"><tt>windows::throw_last_error()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.54</td>
<td><a href="#windows.wait_cursor.h"><tt>__vic/windows/wait_cursor.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.54.1</td>
<td style="padding-left:4ex"><a href="#windows--WaitCursor"><tt>windows::WaitCursor</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.55</td>
<td><a href="#windows.wchar.h"><tt>__vic/windows/wchar.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.55.1</td>
<td style="padding-left:4ex"><a href="#windows--wstring"><tt>windows::wstring</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.55.2</td>
<td style="padding-left:4ex"><a href="#windows--utf8to16"><tt>windows::utf8to16()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.55.3</td>
<td style="padding-left:4ex"><a href="#windows--utf16to8"><tt>windows::utf16to8()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.56</td>
<td><a href="#windows.window.h"><tt>__vic/windows/window.h</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.56.1</td>
<td style="padding-left:4ex"><a href="#windows--Window"><tt>windows::Window</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.56.2</td>
<td style="padding-left:4ex"><a href="#windows--Window--Class"><tt>windows::Window::Class</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.56.3</td>
<td style="padding-left:4ex"><a href="#windows--Window--CreateParams"><tt>windows::Window::CreateParams</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.56.4</td>
<td style="padding-left:4ex"><a href="#windows--MsgBox"><tt>windows::MsgBox()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.56.5</td>
<td style="padding-left:4ex"><a href="#windows--MessageLoop"><tt>windows::MessageLoop()</tt></a></td>
</tr>
<tr>
<td class="toc-chapter-no">2.56.6</td>
<td style="padding-left:4ex"><a href="#windows--ProcessMessages"><tt>windows::ProcessMessages()</tt></a></td>
</tr>
<tr><td colspan="2" style="font-size:5pt;"> </td></tr>
<tr>
<td class="toc-chapter-no">3</td>
<td><a href="#build">Build and install</a></td>
</tr>
<tr><td colspan="2" style="font-size:5pt;"> </td></tr>
</table>




<h1 id="intro">
<span class="h1_num">1</span>Introduction</h1>

<h2 id="why">
<span class="h2_num">1.1</span>Why this library was created?</h2>


<p>This library contains the features I'm missing in the Standard C++
library. It's a kind of my personal
<a href="http://www.boost.org/">Boost</a>.</p>

<p>Additionally, it's an abstraction layer that hides implementation details,
quirks and idiosyncrasies of OS'es, compilers and the standard library
implementations.</p>



<h2 id="general-structure">
<span class="h2_num">1.2</span>General structure and usage</h2>


<p>The topmost structural units of the library are headers and the library file
(or archive) - <tt>lib__vic.a</tt> or <tt>__vic.lib</tt>. Usually the library
file has some suffix like <tt>lib__vic14.a</tt>. All the headers
are located in the <tt>__vic/</tt> subdirectory. One should include them like
this:</p>

<pre class="code">
#include &lt;__vic/<span class="nonterminal">header.h</span>&gt;
</pre>

<p>Where <tt><span class="nonterminal">header.h</span></tt> is a name of the desired header.</p>

<p>Almost all the code is placed within <tt>__vic</tt> namespace, including
other namespaces.</p>

<p>During program linking, the library file must be given to the linker.
Example:</p>

<pre class="code">
$ g++ -std=c++14 prog.cpp -l__vic14
</pre>

<p>The library can be built using one of the ISO C++ standards: C++98, C++11,
C++14, C++17, C++20 or C++23. The standard suffix is used as a suffix for the
library file (archive).</p>

<p>Some features require a specific minimal standard version to be available,
e.g. many of them require at least C++11. These features are marked with
<span class="sign">[C++11]</span> sign that means "C++11 or later".</p>

<p>Some features are available only in particular standard mode and not
available otherwise. Such features are marked with <span class="sign">[C++98 only]</span>
sign.</p>

<p>Detailed description of the library components is provided in the subsequent
chapters. Descriptions are grouped by headers. C++23 language syntax is mainly
used as a more complete and expressive one.</p>





<h1 id="components-reference">
<span class="h1_num">2</span>Library components reference</h1>

<h2 id="defs.h">
<span class="h2_num">2.1</span><tt>__vic/defs.h</tt>
</h2>

<p>Misc. fundamental definitions.</p>


<h3 id="nullptr">
<span class="h3_num">2.1.1</span><tt>nullptr</tt> <span class="sign">[C++98 only]</span>
</h3>


<p>Null pointer literal. Can be used instead of <tt>NULL</tt> or <tt>0</tt>.
In ISO C++ 98 mode defined as</p>

<pre class="code">
const int nullptr = 0;
</pre>

<p>This definition allows to write C++11-style code using C++98 standard.</p>

<p>It is one of the few global definitions inroduced by the library. Definition
can be prevented by definition <tt>__VIC_NO_NULLPTR_DEF</tt> macro before
inclusion.</p>

<div class="section">Example</div>
<pre class="code">
int *p = nullptr;
pthread_create(&amp;tid, nullptr, thread_func, nullptr);
</pre>





<h3 id="noexcept">
<span class="h3_num">2.1.2</span><tt>noexcept</tt> <span class="sign">[C++98 only]</span>
</h3>


<p>A macro in C++98 mode, synonym for <tt>throw()</tt>. In other standard modes
the definition is absent.</p>




<h3 id="array_size">
<span class="h3_num">2.1.3</span><tt>array_size()</tt>
</h3>


<pre class="code">
template&lt;class T, size_t N&gt;
constexpr size_t array_size(T (&amp;array)[N]);
</pre>

<p>Returns number of elements in the array. Can be used as a compile-time
expression.</p>

<div class="section">Example</div>
<pre class="code">
int m[] = { 1, 2, 3, 5, 7 };

size_t n = __vic::array_size(m); // n == 5

int *dup = new int[n];
</pre>





<h3 id="non_copyable">
<span class="h3_num">2.1.4</span><tt>non_copyable</tt>
</h3>


<pre class="code">
class non_copyable
{
    non_copyable(const non_copyable &amp;) = delete;
    non_copyable &amp;operator=(const non_copyable &amp;) = delete;
protected:
    non_copyable() = default;
};
</pre>

<p>Inheriting of this class suppresses generation of copy constructor and
copy assignment. Same as <tt>boost::noncopyable</tt>.</p>

<div class="section">Example</div>
<pre class="code">
class C : private __vic::non_copyable
{
};

C c1;
C c2 = c1; // Error! Non-copyable object
</pre>





<h3 id="non_heap_allocatable">
<span class="h3_num">2.1.5</span><tt>non_heap_allocatable</tt>
</h3>


<pre class="code">
class non_heap_allocatable
{
    void *operator new(std::size_t ) = delete;
    void *operator new(std::size_t , const std::nothrow_t &amp; ) = delete;
    void *operator new[](std::size_t ) = delete;
    void *operator new[](std::size_t , const std::nothrow_t &amp; ) = delete;
protected:
    non_heap_allocatable() = default;
};
</pre>

<p>Inheriting of this class prevents creation of the class object on a free
store using operator <tt>new</tt>.</p>

<div class="section">Example</div>
<pre class="code">
class C : private __vic::non_heap_allocatable
{
};

C c; // Ok. Allocation on stack
C *p = new C; // Error! Attempt to allocate on heap
</pre>





<h3 id="std--move">
<span class="h3_num">2.1.6</span><tt>std::move()</tt>, <tt>std::forward()</tt>, <tt>std::swap()</tt>
<span class="sign">[C++11]</span>
</h3>


<p>The header always includes this utilities in C++11 mode.</p>




<h3 id="VIC_SWAP_HEADER">
<span class="h3_num">2.1.7</span><tt>__VIC_SWAP_HEADER</tt>
</h3>


<p>A macro for <tt>#include</tt>. Expands to the header name that contains
<tt>std::swap()</tt> definition, dependig on the used language standard.</p>

<div class="section">Example</div>
<pre class="code">
#include __VIC_SWAP_HEADER
</pre>





<h3 id="platform-dependent-macros">
<span class="h3_num">2.1.8</span>Platform-dependent macros</h3>


<p>The library provides set of compiler-independent macros that help to
determine the target platform and some platform-specific traits by checking
macro presence using <tt>#ifdef</tt>.</p>

<p>List of hardware platforms (processors):</p>
<ul>
<li>
<tt>__VIC_X86__</tt> - Intel x86 (IA32)</li>
<li>
<tt>__VIC_X64__</tt> - x64 aka AMD 64</li>
<li>
<tt>__VIC_IA64__</tt> - Intel IA64</li>
<li>
<tt>__VIC_POWERPC__</tt> - PowerPC</li>
</ul>

<p>Other macros:</p>
<ul><li>
<tt>__VIC_STRICT_RAM_ALIGNMENT__</tt> - attempt to read unaligned
        data will cause bus error</li></ul>






<h2 id="algorithm.h">
<span class="h2_num">2.2</span><tt>__vic/algorithm.h</tt>
</h2>


<p>Generic algorithms.</p>


<h3 id="skip_if_front">
<span class="h3_num">2.2.1</span><tt>skip_if_front()</tt>
</h3>


<pre class="code">
template&lt;
    std::forward_iterator Iter,
    std::predicate&lt;std::iter_value_t&lt;Iter&gt;&gt; Pred
&gt;
Iter skip_if_front(Iter begin, Iter end, Pred pred);
</pre>

<p>Skips all leading elements that match the given predicate and returns new
begin iterator.</p>




<h3 id="skip_if_back">
<span class="h3_num">2.2.2</span><tt>skip_if_back()</tt>
</h3>


<pre class="code">
template&lt;
    std::bidirectional_iterator Iter,
    std::predicate&lt;std::iter_value_t&lt;Iter&gt;&gt; Pred
&gt;
Iter skip_if_back(Iter begin, Iter end, Pred pred);
</pre>

<p>Skips all trailing elements that match the given predicate and returns new
end iterator.</p>






<h2 id="ascii.h">
<span class="h2_num">2.3</span><tt>__vic/ascii.h</tt>
</h2>


<p>Fast, compact and locale-independent tools for ASCII-characters
processing. All the tools are located within <tt>__vic::ascii</tt>
namespace.</p>


<h3 id="ascii--is-functions">
<span class="h3_num">2.3.1</span><tt>ascii::is</tt>-functions</h3>


<pre class="code">
namespace ascii {

constexpr bool isdigit(char c);
constexpr bool isxdigit(char c);
constexpr bool islower(char c);
constexpr bool isupper(char c);
constexpr bool isalpha(char c);
constexpr bool isalnum(char c);
constexpr bool isspace(char c);
constexpr bool isblank(char c);
constexpr bool isprint(char c);
constexpr bool isgraph(char c);
constexpr bool ispunct(char c);
constexpr bool iscntrl(char c);
constexpr bool isascii(char c);

}
</pre>

<p>Counterparts of the corresponding <tt>&lt;cctype&gt;</tt> functions.</p>




<h3 id="ascii--todigit">
<span class="h3_num">2.3.2</span><tt>ascii::todigit()</tt>
</h3>


<pre class="code">
constexpr char ascii::todigit(int d);
</pre>

<p>Converts integer value from 0 to 9 to the decimal digit. The result is
undefined if the input value goes beyond the range.</p>
<div>
<u>Precondition</u>: <tt>0 &lt;= d &amp;&amp; d &lt;= 9</tt>
</div>




<h3 id="ascii--toxdigit">
<span class="h3_num">2.3.3</span><tt>ascii::toxdigit_upper()</tt>, <tt>ascii::toxdigit_lower()</tt>
</h3>


<pre class="code">
namespace ascii {

constexpr char toxdigit_upper(int d);
constexpr char toxdigit_lower(int d);

}
</pre>

<p>Converts integer value from 0 to 15 to the hexadecimal digit. The first one
uses upper case for <tt>A</tt>-<tt>F</tt>, the latter - lower. The result
is undefined if the input value goes beyond the range.</p>
<div>
<u>Precondition</u>: <tt>0 &lt;= d &amp;&amp; d &lt;= 15</tt>
</div>




<h3 id="ascii--digit_to_number">
<span class="h3_num">2.3.4</span><tt>ascii::digit_to_number()</tt>
</h3>


<pre class="code">
constexpr int ascii::digit_to_number(char d);
</pre>

<p>Converts the given decimal digit to the number if <tt>ascii::isdigit(d)</tt>.
<tt>-1</tt> is returned otherwise.</p>




<h3 id="ascii--xdigit_to_number">
<span class="h3_num">2.3.5</span><tt>ascii::xdigit_to_number()</tt>
</h3>


<pre class="code">
constexpr int ascii::xdigit_to_number(char d);
</pre>

<p>Converts the given hexadecimal digit to the number if
<tt>ascii::isxdigit(d)</tt>. <tt>-1</tt> is returned otherwise.</p>




<h3 id="ascii--tolower-char">
<span class="h3_num">2.3.6</span><tt>ascii::tolower(char)</tt>, <tt>ascii::toupper(char)</tt>
</h3>


<pre class="code">
namespace ascii {

constexpr char tolower(char c);
constexpr char toupper(char c);
constexpr char upper_to_lower(char upper);
constexpr char lower_to_upper(char lower);

}
</pre>

<div>
<pre class="prototype">constexpr char tolower(char c)</pre>
<pre class="prototype">constexpr char toupper(char c)</pre>
<blockquote>


<p>Counterparts of the corresponding <tt>&lt;cctype&gt;</tt> functions.</p>
</blockquote>
</div>

<div>
<pre class="prototype">constexpr char upper_to_lower(char upper)</pre>
<blockquote>

<p>More restricted counterpart of <tt>tolower()</tt>. The result is undefined
if the argument is not an ASCII capital letter.</p>
<div>
<u>Precondition</u>: <tt>ascii::isupper(upper)</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">constexpr char lower_to_upper(char lower)</pre>
<blockquote>

<p>More restricted counterpart of <tt>toupper()</tt>. The result is undefined
if the argument is not an ASCII small letter.</p>
<div>
<u>Precondition</u>: <tt>ascii::islower(lower)</tt>
</div>
</blockquote>
</div>




<h3 id="ascii--equal_icase-char">
<span class="h3_num">2.3.7</span><tt>ascii::equal_icase(char,char)</tt>
</h3>


<pre class="code">
constexpr bool ascii::equal_icase(char ch1, char ch2);
</pre>

<p>Checks equality of the two ASCII-characters ignoring the case.</p>






<h2 id="ascii_string.h">
<span class="h2_num">2.4</span><tt>__vic/ascii_string.h</tt>
</h2>


<p>ASCII-strings processing tools.</p>


<h3 id="ascii--tolower-str">
<span class="h3_num">2.4.1</span><tt>ascii::tolower()</tt>
</h3>


<pre class="code">
namespace ascii {

char *tolower(char *str);
std::string &amp;tolower(std::string &amp;str);

}
</pre>

<p>Translates all Latin capital letters of <tt>str</tt> to the small ones.
Returns <tt>str</tt>. C-string must not be <tt>nullptr</tt>!</p>




<h3 id="ascii--toupper-str">
<span class="h3_num">2.4.2</span><tt>ascii::toupper()</tt>
</h3>


<pre class="code">
namespace ascii {

char *toupper(char *str);
std::string &amp;toupper(std::string &amp;str);

}
</pre>

<p>Translates all Latin small letters of <tt>str</tt> to the capital ones.
Returns <tt>str</tt>. C-string must not be <tt>nullptr</tt>!</p>




<h3 id="ascii--equal_icase-str">
<span class="h3_num">2.4.3</span><tt>ascii::equal_icase()</tt>
</h3>


<pre class="code">
namespace ascii {

bool equal_icase(const char *s1, const char *s2);
bool equal_icase(const char *s1, size_t s1_len,
                 const char *s2, size_t s2_len);

#if __cpp_lib_string_view // C++17

bool equal_icase(std::string_view s1, std::string_view s2);

#else // until C++17

bool equal_icase(const std::string &amp;s1, const std::string &amp;s2);
bool equal_icase(const std::string &amp;s1, const char *s2);
bool equal_icase(const char *s1, const std::string &amp;s2);

#endif
}
</pre>

<p>Checks equality of two ASCII-strings ignoring the case. The pointers must not
be <tt>nullptr</tt>!</p>






<h2 id="base16.h">
<span class="h2_num">2.5</span><tt>__vic/base16.h</tt>
</h2>


<p>Base16 encoder and decoder.</p>


<h3 id="base16">
<span class="h3_num">2.5.1</span><tt>base16</tt>
</h3>


<p>A class used as a namespace. Contains only types, constants and static
functions. No objects of this class are supposed to be created.</p>




<h3 id="base16--bad_format">
<span class="h3_num">2.5.2</span><tt>base16::bad_format</tt>
</h3>


<pre class="code">
struct base16::bad_format : public std::exception {};
</pre>

<p>Abstract base exception class.</p>




<h3 id="base16--bad_digit">
<span class="h3_num">2.5.3</span><tt>base16::bad_digit</tt>
</h3>


<pre class="code">
struct base16::bad_digit : public base16::bad_format
{
    const char *what() const noexcept;
};
</pre>

<p>Exception class thrown by <a href="#base16--decode"><tt>base16::decode()</tt></a> when the input sequence
contains character that is not a valid HEX digit.</p>




<h3 id="base16--bad_length">
<span class="h3_num">2.5.4</span><tt>base16::bad_length</tt>
</h3>


<pre class="code">
struct base16::bad_length : public base16::bad_format
{
    const char *what() const noexcept;
};
</pre>

<p>Exception class thrown by <a href="#base16--decode"><tt>base16::decode()</tt></a> when the input sequence
length is odd.</p>




<h3 id="base16--status">
<span class="h3_num">2.5.5</span><tt>base16::status</tt>
</h3>


<pre class="code">
enum class base16::status
{
    ok,
    invalid_length,
    invalid_digit
};
using base16::status_t = base16::status; // for C++98
</pre>

<p>Input sequence parsing outcome status codes returned by
<a href="#base16--try_decode"><tt>base16::try_decode()</tt></a>.</p>




<h3 id="base16--encode_upper">
<span class="h3_num">2.5.6</span><tt>base16::encode_upper()</tt>
</h3>


<pre class="code">
// Bytes -&gt; Text
template&lt;class ByteReader, class CharWriter&gt;
void base16::encode_upper(ByteReader reader, CharWriter writer);
</pre>

<p>Encodes bytes from <tt>reader</tt> and writes the resulting characters to
<tt>writer</tt>. Upper case is used for hexadecimal digits.</p>

<p><tt>ByteReader</tt> has to model <tt>Reader&lt;unsigned char&gt;</tt> concept.
See <a href="#readers"><tt>__vic/readers/</tt></a>.</p>

<p><tt>CharWriter</tt> has to model <tt>Writer&lt;char&gt;</tt> concept.
See <a href="#writers"><tt>__vic/writers/</tt></a>.</p>


<div class="section">Example</div>
<pre class="code">
#include&lt;__vic/readers/string.h&gt;
#include&lt;__vic/writers/string.h&gt;

using bytes = std::string;
using bytes_reader = __vic::string_reader;

std::string encode_base16(const bytes &amp;s)
{
    std::string res;
    res.reserve(s.length() * 2);
    __vic::base16::encode_upper(bytes_reader(s), __vic::string_writer(res));
    return res;
}
</pre>





<h3 id="base16--encode_lower">
<span class="h3_num">2.5.7</span><tt>base16::encode_lower()</tt>
</h3>


<pre class="code">
// Bytes -&gt; Text
template&lt;class ByteReader, class CharWriter&gt;
void base16::encode_lower(ByteReader reader, CharWriter writer);
</pre>

<p>Same as <a href="#base16--encode_upper"><tt>base16::encode_upper()</tt></a> but lower case is used for
hexadecimal digits.</p>




<h3 id="base16--encode_byte_lower">
<span class="h3_num">2.5.8</span><tt>base16::encode_byte_lower()</tt>
</h3>


<pre class="code">
// Byte -&gt; Text
template&lt;class CharWriter&gt;
void base16::encode_byte_lower(unsigned char byte, CharWriter writer);
</pre>

<p>Same as <a href="#base16--encode_lower"><tt>base16::encode_lower()</tt></a> but encodes only single byte.</p>




<h3 id="base16--encode_byte_upper">
<span class="h3_num">2.5.9</span><tt>base16::encode_byte_upper()</tt>
</h3>


<pre class="code">
// Byte -&gt; Text
template&lt;class CharWriter&gt;
void base16::encode_byte_upper(unsigned char byte, CharWriter writer);
</pre>

<p>Same as <a href="#base16--encode_upper"><tt>base16::encode_upper()</tt></a> but encodes only single byte.</p>




<h3 id="base16--decode">
<span class="h3_num">2.5.10</span><tt>base16::decode()</tt>
</h3>


<pre class="code">
// Text -&gt; Bytes
template&lt;class CharReader, class ByteWriter&gt;
void base16::decode(CharReader reader, ByteWriter writer);
</pre>

<p>Decodes characters from <tt>reader</tt> and writes the resulting bytes to
<tt>writer</tt>. Exception derived from <a href="#base16--bad_format"><tt>base16::bad_format</tt></a> is
thrown if the input sequence has invalid Base16 format.</p>

<p><tt>CharReader</tt> has to model <tt>Reader&lt;char&gt;</tt> concept.
See <a href="#readers"><tt>__vic/readers/</tt></a>.</p>

<p><tt>ByteWriter</tt> has to model <tt>Writer&lt;unsigned char&gt;</tt> concept.
See <a href="#writers"><tt>__vic/writers/</tt></a>.</p>

<div class="section">Example</div>
<pre class="code">
#include&lt;__vic/readers/string.h&gt;
#include&lt;__vic/writers/string.h&gt;

using bytes = std::string;
using bytes_writer = __vic::string_writer;

bytes decode_base16(const std::string &amp;s)
{
    bytes res;
    res.reserve(s.length() / 2);
    __vic::base16::decode(__vic::string_reader(s), bytes_writer(res));
    return res;
}
</pre>





<h3 id="base16--try_decode">
<span class="h3_num">2.5.11</span><tt>base16::try_decode()</tt>
</h3>


<pre class="code">
// Text -&gt; Bytes
template&lt;class CharReader, class ByteWriter&gt;
base16::status_t base16::try_decode(CharReader reader, ByteWriter writer);
</pre>

<p>Same as <a href="#base16--decode"><tt>base16::decode()</tt></a> but returns <a href="#base16--status"><tt>base16::status</tt></a>
different from <tt>base16::status::ok</tt> in case of invalid input sequence
instead of throwing exception.</p>






<h2 id="base64.h">
<span class="h2_num">2.6</span><tt>__vic/base64.h</tt>
</h2>


<p>Base64 encoder and decoder.</p>


<h3 id="base64">
<span class="h3_num">2.6.1</span><tt>base64</tt>
</h3>


<p>A class used as a namespace. Contains only types, constants and static
functions. No objects of this class are supposed to be created.</p>




<h3 id="base64--bad_format">
<span class="h3_num">2.6.2</span><tt>base64::bad_format</tt>
</h3>


<pre class="code">
struct base64::bad_format : public std::exception {};
</pre>

<p>Abstract base exception class.</p>




<h3 id="base64--bad_digit">
<span class="h3_num">2.6.3</span><tt>base64::bad_digit</tt>
</h3>


<pre class="code">
struct base64::bad_digit : public base64::bad_format
{
    const char *what() const noexcept;
};
</pre>

<p>Exception class thrown by <a href="#base64--decode"><tt>base64::decode()</tt></a> when the input sequence
contains character that is not a valid Base64 digit.</p>




<h3 id="base64--bad_length">
<span class="h3_num">2.6.4</span><tt>base64::bad_length</tt>
</h3>


<pre class="code">
struct base64::bad_length : public base64::bad_format
{
    const char *what() const noexcept;
};
</pre>

<p>Exception class thrown by <a href="#base64--decode"><tt>base64::decode()</tt></a> when the input sequence
length is not a multiple of 4.</p>




<h3 id="base64--status">
<span class="h3_num">2.6.5</span><tt>base64::status</tt>
</h3>


<pre class="code">
enum class base64::status
{
    ok,
    invalid_length,
    invalid_digit
};
using base64::status_t = base64::status; // for C++98
</pre>

<p>Input sequence parsing outcome status codes returned by
<a href="#base64--try_decode"><tt>base64::try_decode()</tt></a>.</p>




<h3 id="base64--encode">
<span class="h3_num">2.6.6</span><tt>base64::encode()</tt>
</h3>


<pre class="code">
// Bytes -&gt; Text
template&lt;class ByteReader, class CharWriter&gt;
void base64::encode(ByteReader reader, CharWriter writer);
</pre>

<p>Encodes bytes from <tt>reader</tt> and writes the resulting characters to
<tt>writer</tt>.</p>

<p><tt>ByteReader</tt> has to model <tt>Reader&lt;unsigned char&gt;</tt> concept.
See <a href="#readers"><tt>__vic/readers/</tt></a>.</p>

<p><tt>CharWriter</tt> has to model <tt>Writer&lt;char&gt;</tt> concept.
See <a href="#writers"><tt>__vic/writers/</tt></a>.</p>

<div class="section">Example</div>
<pre class="code">
#include&lt;__vic/readers/string.h&gt;
#include&lt;__vic/writers/string.h&gt;

using bytes = std::string;
using bytes_reader = __vic::string_reader;

std::string encode_base64(const bytes &amp;s)
{
    std::string res;
    res.reserve(__vic::base64::encoded_length(s.length()));
    __vic::base64::encode(bytes_reader(s), __vic::string_writer(res));
    return res;
}
</pre>





<h3 id="base64--decode">
<span class="h3_num">2.6.7</span><tt>base64::decode()</tt>
</h3>


<pre class="code">
// Text -&gt; Bytes
template&lt;class CharReader, class ByteWriter&gt;
void base64::decode(CharReader reader, ByteWriter writer);
</pre>

<p>Decodes characters form <tt>reader</tt> and writes the resulting bytes to
<tt>writer</tt>. Exception derived from <a href="#base64--bad_format"><tt>base64::bad_format</tt></a> is
thrown if the input sequence has invalid Base64 format.</p>

<p><tt>CharReader</tt> has to model <tt>Reader&lt;char&gt;</tt> concept.
See <a href="#readers"><tt>__vic/readers/</tt></a>.</p>

<p><tt>ByteWriter</tt> has to model <tt>Writer&lt;unsigned char&gt;</tt> concept.
See <a href="#writers"><tt>__vic/writers/</tt></a>.</p>

<div class="section">Example</div>
<pre class="code">
#include&lt;__vic/readers/string.h&gt;
#include&lt;__vic/writers/string.h&gt;

using bytes = std::string;
using bytes_writer = __vic::string_writer;

bytes decode_base64(const std::string &amp;s)
{
    bytes res;
    res.reserve(__vic::base64::max_decoded_length(s.length()));
    __vic::base64::decode(__vic::string_reader(s), bytes_writer(res));
    return res;
}
</pre>





<h3 id="base64--try_decode">
<span class="h3_num">2.6.8</span><tt>base64::try_decode()</tt>
</h3>


<pre class="code">
// Text -&gt; Bytes
template&lt;class CharReader, class ByteWriter&gt;
base64::status_t base64::try_decode(CharReader reader, ByteWriter writer);
</pre>

<p>Same as <a href="#base64--decode"><tt>base64::decode()</tt></a> but returns <a href="#base64--status"><tt>base64::status</tt></a>
different from <tt>base64::status::ok</tt> in case of invalid input sequence
instead of throwing exception.</p>




<h3 id="base64--encoded_length">
<span class="h3_num">2.6.9</span><tt>base64::encoded_length()</tt>
</h3>


<pre class="code">
constexpr size_t base64::encoded_length(size_t orig_len);
</pre>

<p>Calculates the length of encoded sequence of characters using the original
length of the bytes sequence.</p>




<h3 id="base64--max_decoded_length">
<span class="h3_num">2.6.10</span><tt>base64::max_decoded_length()</tt>
</h3>


<pre class="code">
constexpr size_t base64::max_decoded_length(size_t orig_len);
</pre>

<p>Estimates the maximum length of decoded sequence of bytes using the original
length of the characters sequence. The actual value depends on trailing
<tt>'='</tt> in the encoded value.</p>






<h2 id="bin_file.h">
<span class="h2_num">2.7</span><tt>__vic/bin_file.h</tt>
</h2>


<h3 id="bin_file">
<span class="h3_num">2.7.1</span><tt>bin_file</tt>
</h3>


<pre class="code">
class bin_file : private non_copyable
{
public:
    enum in_t { in };
    enum out_t { out };
    enum append_t { append };

    bin_file();
    bin_file(const char *fname, in_t);
    bin_file(const char *fname, out_t);
    bin_file(const char *fname, append_t);
    ~bin_file();

    // BEGIN C++11
    bin_file(bin_file &amp;&amp;o) noexcept;
    bin_file &amp;operator=(bin_file &amp;&amp;o) noexcept;
    // END C++11

    bool open_in(const char *fname);
    bool open_out(const char *fname);
    bool open_append(const char *fname);

    size_t read_max(void *buf, size_t n);
    size_t read_some(void *buf, size_t n);

    void write_all(const void *buf, size_t n);

    bool is_open() const;
    void close();
    bool close_nt() noexcept;

    void swap(bin_file &amp;o) noexcept;

    [[noreturn]] void throw_last_error(const char *msg);
    void throw_if_closed(const char *msg);
};
</pre>

<p>Unbuffered binary file. OS-independent wrapper for low-level system API.</p>

<p>Following open modes are available:</p>
<ul>
<li>
<tt>in</tt> - open existing file for reading;</li>
<li>
<tt>out</tt> - create new file for writing, overwrite if exists;</li>
<li>
<tt>append</tt> - open existing file for appending (writing at end of
        file), create if does not exist.</li>
</ul>

<div class="section">Class members</div>

<div>
<pre class="prototype">enum in_t { in }</pre>
<pre class="prototype">enum out_t { out }</pre>
<pre class="prototype">enum append_t { append }</pre>
<blockquote>



<p>Constructor tags.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bin_file()</pre>
<blockquote>

<div>
<u>Postcondition</u>: <tt>is_open() == false()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bin_file(const char *fname, in_t)</pre>
<pre class="prototype">bin_file(const char *fname, out_t)</pre>
<pre class="prototype">bin_file(const char *fname, append_t)</pre>
<blockquote>



<p>Call <tt>open_in(fname)</tt>, <tt>open_out(fname)</tt> or
<tt>open_append(fname)</tt>, correspondingly. <tt>is_open()</tt> or
<tt>throw_if_closed()</tt> has to be called then to check the result.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~bin_file()</pre>
<blockquote>

<p>Closes the file if <tt>is_open() == true</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bin_file(bin_file &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<pre class="prototype">bin_file &amp;operator=(bin_file &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Move operations for C++11 mode.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool open_in(const char *fname)</pre>
<pre class="prototype">bool open_out(const char *fname)</pre>
<pre class="prototype">bool open_append(const char *fname)</pre>
<blockquote>



<p>Open file for reading, writing or appending, correspondingly. Return
<tt>is_open()</tt>.</p>
<div>
<u>Precondition</u>: <tt>is_open() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool is_open() const</pre>
<blockquote>

<p>Returns <tt>true</tt> if file is open.</p>
</blockquote>
</div>

<div>
<pre class="prototype">size_t read_max(void *buf, size_t n)</pre>
<blockquote>

<p>Tries to read <tt>n</tt> bytes to the specified buffer. Returns number of
bytes read. Returned value can be less than requested only when end of file
was reached. Throws on error.</p>
<div>
<u>Precondition</u>: <tt>is_open() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">size_t read_some(void *buf, size_t n)</pre>
<blockquote>

<p>Reads no more than <tt>n</tt> bytes to the specified buffer. Returns number
of bytes read or <tt>0</tt> in case of end-of-file. The function returns after
first chunk of any size was successfully received. Throws on error.</p>
<div>
<u>Precondition</u>: <tt>is_open() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void write_all(const void *buf, size_t n)</pre>
<blockquote>

<p>Writes the whole buffer to the file. Throws on error.</p>
<div>
<u>Precondition</u>: <tt>is_open() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void close()</pre>
<blockquote>

<p>Closes the file. Throws on error.</p>
<div>
<u>Precondition</u>: <tt>is_open() == true</tt>
</div>
<div>
<u>Postcondition</u>: <tt>is_open() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool close_nt() noexcept</pre>
<blockquote>

<p>A counterpart of <tt>close()</tt> but never throws, returns <tt>false</tt>
instead in case of error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void swap(bin_file &amp;o) noexcept</pre>
<blockquote>

<p>Swaps the value with <tt>o</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">[[noreturn]] void throw_last_error(const char *msg)</pre>
<blockquote>

<p>Throws exception with the last error description if available.
<tt>what()</tt> will contain <tt>msg</tt> as a substring anyway.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void throw_if_closed(const char *msg)</pre>
<blockquote>

<p>Calls <tt>throw_last_error(msg)</tt> if <tt>!is_open()</tt>.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
// Copy file
__vic::bin_file in("file", __vic::bin_file::in);
in.throw_if_closed("Cannot open file")
__vic::bin_file out("file.copy", __vic::bin_file::out);
out.throw_if_closed("Cannot create file")

char buf[512];
while(size_t n = in.read_some(buf, sizeof buf))
    out.write_all(buf, n);

out.close();
// in will be closed by destructor
</pre>






<h2 id="bits.h">
<span class="h2_num">2.8</span><tt>__vic/bits.h</tt>
</h2>


<p>Bits and bytes manipulation tools.</p>


<h3 id="lo_nibble">
<span class="h3_num">2.8.1</span><tt>lo_nibble()</tt>, <tt>hi_nibble()</tt>
</h3>


<pre class="code">
constexpr uint8_t lo_nibble(uint8_t byte);
constexpr uint8_t hi_nibble(uint8_t byte);
</pre>

<p>Return the value of the low-order/high-order half-byte (tetrad),
respectively.</p>




<h3 id="msb_ones">
<span class="h3_num">2.8.2</span><tt>msb_ones()</tt>, <tt>lsb_ones()</tt>
</h3>


<pre class="code">
template&lt;class T&gt; constexpr T lsb_ones(unsigned bits_num);
template&lt;class T&gt; constexpr T msb_ones(unsigned bits_num);
</pre>

<p>Return the value of the type <tt>T</tt> with all least/most significant
<tt>bits_num</tt> bits filled with <tt>1</tt>, respectively. All other bits
are set to <tt>0</tt>.</p>




<h3 id="get_lsbs">
<span class="h3_num">2.8.3</span><tt>get_lsbs()</tt>
</h3>


<pre class="code">
template&lt;class T&gt; constexpr T get_lsbs(T v, unsigned bits_num);
</pre>

<p>Returns <tt>bits_num</tt> least significant bits of <tt>v</tt>. In other
words, zeroes all but <tt>bits_num</tt> least significant bits.</p>




<h3 id="ord">
<span class="h3_num">2.8.4</span><tt>ord()</tt>
</h3>


<pre class="code">
constexpr int ord(char ch);
</pre>

<p>Returns the character code from 0 to 255.</p>
<div>
<u>Postcondition</u>: ord(ch) &gt;= 0</div>




<h3 id="popcount">
<span class="h3_num">2.8.5</span><tt>popcount()</tt>
</h3>


<pre class="code">
unsigned popcount(unsigned v);
unsigned popcount(unsigned long v);
unsigned popcount(unsigned long long v);
unsigned popcount(unsigned short v);
unsigned popcount(unsigned char v);
</pre>

<p>Returns the number of one bits in the given value.</p>




<h3 id="msb_position">
<span class="h3_num">2.8.6</span><tt>msb_position()</tt>
</h3>


<pre class="code">
unsigned msb_position(unsigned v)
unsigned msb_position(unsigned long v);
unsigned msb_position(unsigned long long v);
unsigned msb_position(unsigned short v);
unsigned msb_position(unsigned char v);
</pre>

<div>
<u>Precondition</u>: <tt>v != 0</tt>
</div>

<p>Returns the position of the most significant 1-bit. The result is unspecified
if <tt>v == 0</tt>.</p>




<h3 id="ispow2">
<span class="h3_num">2.8.7</span><tt>ispow2()</tt>
</h3>


<pre class="code">
template&lt;class UInt&gt;
bool ispow2(UInt n);
</pre>

<div>
<u>Precondition</u>: <tt>UInt</tt> is an unsigned integer type</div>

<p>Returns <tt>true</tt> if <tt>n</tt> is an integral power of 2.</p>




<h3 id="ceil2">
<span class="h3_num">2.8.8</span><tt>ceil2()</tt>
</h3>


<pre class="code">
template&lt;class UInt&gt;
UInt ceil2(UInt n);
</pre>

<div>
<u>Precondition</u>: <tt>UInt</tt> is an unsigned integer type</div>

<p>Returns the minimal value <tt>m</tt> such that <tt>ispow2(m) &amp;&amp;
m &gt;= n</tt>. If <tt>m</tt> is not representable as a value of type
<tt>UInt</tt>, the result is an unspecified value.</p>




<h3 id="floor2">
<span class="h3_num">2.8.9</span><tt>floor2()</tt>
</h3>


<pre class="code">
template&lt;class UInt&gt;
UInt floor2(UInt n);
</pre>

<div>
<u>Precondition</u>: <tt>UInt</tt> is an unsigned integer type</div>

<p>If <tt>n != 0</tt> returns the maximal value <tt>m</tt> such that
<tt>ispow2(m) &amp;&amp; m &lt;= n</tt>. Otherwise <tt>0</tt> is returned.</p>




<h3 id="ceil_log2">
<span class="h3_num">2.8.10</span><tt>ceil_log2()</tt>
</h3>


<pre class="code">
template&lt;class UInt&gt;
unsigned ceil_log2(UInt n);
</pre>

<div>
<u>Precondition</u>: <tt>UInt</tt> is an unsigned integer type</div>

<p>Returns <tt>ceil(log2(n))</tt> if <tt>n != 0</tt> or 0 otherwise.</p>




<h3 id="floor_log2">
<span class="h3_num">2.8.11</span><tt>floor_log2()</tt>
</h3>


<pre class="code">
template&lt;class UInt&gt;
unsigned floor_log2(UInt n);
</pre>

<div>
<u>Precondition</u>: <tt>UInt</tt> is an unsigned integer type</div>

<p>Returns <tt>floor(log2(n))</tt> if <tt>n != 0</tt> or 0 otherwise.</p>




<h3 id="rotl">
<span class="h3_num">2.8.12</span><tt>rotl()</tt>, <tt>rotr()</tt>
</h3>


<pre class="code">
unsigned long long rotl(unsigned long long v, int shift);
unsigned long      rotl(unsigned long v, int shift);
unsigned           rotl(unsigned v, int shift);
unsigned short     rotl(unsigned short v, int shift);
unsigned char      rotl(unsigned char v, int shift);

unsigned long long rotr(unsigned long long v, int shift);
unsigned long      rotr(unsigned long v, int shift);
unsigned           rotr(unsigned v, int shift);
unsigned short     rotr(unsigned short v, int shift);
unsigned char      rotr(unsigned char v, int shift);
</pre>

<p>The functions perform circular left (<tt>rotl</tt>) or right
(<tt>rotr</tt>) bitwise shift (rotation).</p>
<div>
<u>Precondition</u>: <tt>0 &lt;= shift &amp;&amp; shift &lt; sizeof(v)*CHAR_BIT</tt>
</div>




<h3 id="swapped_nibbles">
<span class="h3_num">2.8.13</span><tt>swapped_nibbles()</tt>
</h3>


<pre class="code">
constexpr uint8_t swapped_nibbles(uint8_t b);
</pre>

<p>Swaps a low-order half-byte with a high-order one and returns the value.</p>






<h2 id="date_time.h">
<span class="h2_num">2.9</span><tt>__vic/date_time.h</tt>
</h2>


<p>Date and time utilies.</p>


<h3 id="is_leap_year">
<span class="h3_num">2.9.1</span><tt>is_leap_year()</tt>
</h3>


<pre class="code">
constexpr bool is_leap_year(int year);
</pre>

<p>Determines if the year is a leap year according to Gregorian calendar.</p>




<h3 id="days_in_month">
<span class="h3_num">2.9.2</span><tt>days_in_month()</tt>
</h3>


<pre class="code">
int days_in_month(int month, int year);
</pre>

<p>Returns number of days in the month. Month is a number from 1 to 12.
The second parameter is used only if the month is 2 (february), otherwise
is just ignored.</p>




<h3 id="days_between_years">
<span class="h3_num">2.9.3</span><tt>days_between_years()</tt>
</h3>


<pre class="code">
long days_between_years(unsigned year1, unsigned year2);
</pre>

<p>Returns the difference in days between the beginning of the 2nd year and
the beginning of the 1st year.</p>




<h3 id="invalid_date">
<span class="h3_num">2.9.4</span><tt>invalid_date</tt>
</h3>


<pre class="code">
class invalid_date; // : public std::exception
</pre>

<p>The exception thrown when the value of the date or time element is
invalid.</p>




<h3 id="validate_date_time">
<span class="h3_num">2.9.5</span><tt>validate_date()</tt>, <tt>validate_time()</tt>,
<tt>validate_date_time()</tt>
</h3>


<pre class="code">
void validate_date(int yy, int mm, int dd);
void validate_time(int hh, int mi, int ss);
void validate_date_time(int yy, int mm, int dd, int hh, int mi, int ss);
</pre>

<p>Checks if the date/time value is valid. Following constraints are checked:
</p>
<ul>
<li>
<tt>yy</tt> (year) - cannot be <tt>0</tt>,</li>
<li>
<tt>mm</tt> (month) - <tt>1..12</tt>,</li>
<li>
<tt>dd</tt> (day of the month) - <tt>1..{28..31}</tt>, depending
        on the month,</li>
<li>
<tt>hh</tt> (hour) - <tt>0..23</tt>,</li>
<li>
<tt>mi</tt> (minute) - <tt>0..59</tt>,</li>
<li>
<tt>ss</tt> (second) - <tt>0..59</tt>.</li>
</ul>

<p><tt>invalid_date</tt> is thrown in case of the constraint violation.</p>

<div>
<u><b>Note</b></u>: Specific time values as <tt>24:00:00</tt> (midnight at the end of a
day) or <tt>59:60</tt> (leap second) are considered as invalid!</div>






<h2 id="endian.h">
<span class="h2_num">2.10</span><tt>__vic/endian.h</tt>
</h2>


<p>Byte order-related utilities.</p>


<h3 id="endianness">
<span class="h3_num">2.10.1</span><tt>endianness</tt>
</h3>


<pre class="code">
namespace endian {
enum endianness
{
    unknown = 0,
    little  = 1234,
    big     = 4321,
    pdp     = 3412,
    native  = <span class="nonterminal">&lt;one-of-the-above&gt;</span>
};
} // namespace

using endian::endianness;
</pre>

<p>Byte order constants. <tt>endian::native</tt> is set equal to one of the
constants and represents the byte order used on the current platform (like
<tt>__BYTE_ORDER__</tt> macro on UNIX-like platforms). The values are supposed
to be used for template specializations or for compile-time checks (e.g. in
<tt>static_assert</tt>).</p>

<div class="section">Examples</div>
<pre class="code">
template&lt;__vic::endianness &gt; struct some_algo; // not implemented

// Implementation for little-endian
template&lt;&gt; struct some_algo&lt;__vic::endian::little&gt;
{
    static void doit() { ... }
};
// Implementation for big-endian
template&lt;&gt; struct some_algo&lt;__vic::endian::big&gt;
{
    static void doit() { ... }
};

// Automatically choose an appropriate implementation for the used platform
some_algo&lt;__vic::endian::native&gt;::doit();
</pre>

<pre class="code">
static_assert(__vic::endian::native == __vic::endian:little,
    "Litte-endian is expected");
</pre>





<h3 id="endian--from">
<span class="h3_num">2.10.2</span><tt>endian::from_...()</tt>
</h3>


<pre class="code">
template&lt;class T&gt; [[nodiscard]] constexpr T endian::from_little(T v);
template&lt;class T&gt; [[nodiscard]] constexpr T endian::from_big(T v);
</pre>

<p>Return a value represented in native byte order converted from litte/big
endian if appropriate.</p>

<p><tt>T</tt> can be any integral type or enum with size up to
<tt>sizeof(long long)</tt>.</p>

<div class="section">Example</div>
<pre class="code">
uint16_t v;
read_bytes(&amp;v, 2); // serialized as big endian
std::cout &lt;&lt; "The value is " &lt;&lt; __vic::endian::from_big(v) &lt;&lt; '\n';
</pre>





<h3 id="endian--to">
<span class="h3_num">2.10.3</span><tt>endian::to_...()</tt>
</h3>


<pre class="code">
template&lt;class T&gt; [[nodiscard]] constexpr T endian::to_little(T v);
template&lt;class T&gt; [[nodiscard]] constexpr T endian::to_big(T v);
</pre>

<p>Return a value represented in litte/big endian byte order.</p>

<p><tt>T</tt> can be any integral type or enum with size up to
<tt>sizeof(long long)</tt>.</p>

<div class="section">Example</div>
<pre class="code">
uint16_t v = __vic::endian::to_big(...);
write_bytes(&amp;v, 2); // serialize as big endian
</pre>





<h3 id="swab">
<span class="h3_num">2.10.4</span><tt>swab16()</tt>, <tt>swab32()</tt>, <tt>swab64()</tt>
</h3>


<pre class="code">
[[nodiscard]] constexpr uint16_t swab16(uint16_t v);
[[nodiscard]] constexpr uint32_t swab32(uint32_t v);
[[nodiscard]] constexpr uint64_t swab64(uint64_t v);
</pre>

<p>Fast utilities to reverse byte order (usually implemented using
compiler-specific intrinsics).</p>

<div class="section">Example</div>
<pre class="code">
static_assert(__vic::swab32(0x01020304) == 0x04030201);
</pre>







<h2 id="error.h">
<span class="h2_num">2.11</span><tt>__vic/error.h</tt>
</h2>


<p>Error handling tools.</p>


<h3 id="exception">
<span class="h3_num">2.11.1</span><tt>exception</tt>
</h3>


<pre class="code">
class exception : public std::exception
{
public:
    exception();
    explicit exception(const char *message);
    const char *what() const noexcept;
protected:
    void set_message(const char *message);
};
</pre>

<p>Small extension of <tt>std::exception</tt> - the object carries message
specified in the constructor, <tt>what()</tt> returns this message. Can be used
either as a base or a concrete exception class. Does not use/depend on
<tt>std::string</tt> as opposed to <tt>std::logic_error</tt> and
<tt>std::runtime_error</tt>. You also don't have to decide which one of them
you should use in the particular case.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">exception()</pre>
<blockquote>

<p>Creates the object with an empty message.</p>
</blockquote>
</div>

<div>
<pre class="prototype">explicit exception(const char *message)</pre>
<blockquote>

<p>Creates the object with the specified message.</p>
</blockquote>
</div>

<div>
<pre class="prototype">const char *what() const noexcept</pre>
<blockquote>

<p>Returns the message specified before.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void set_message(const char *message)</pre>
<blockquote>

<p>Sets a new message.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
struct custom_exception : public __vic::exception
{
    explicit custom_exception(const char *msg) : __vic::exception(msg) {}
};

throw custom_exception("Error condition description");
</pre>





<h3 id="libc_error">
<span class="h3_num">2.11.2</span><tt>libc_error</tt>
</h3>


<pre class="code">
class libc_error : public std::exception
{
public:
    explicit libc_error(int err_no = errno);
    explicit libc_error(const char *prompt, int err_no = errno);

    const char *what() const noexcept;
    int code() const;
    int get_errno() const;
};
</pre>

<p>This class is an easy and straightforward replacement of the standard error
handling machinery used in the C-world - <tt>errno</tt>, with exceptions. The
class is also suitable for usage in the multithread environment instead of
not always reentrant call <tt>std::strerror()</tt>.</p>
<p>Below you can see typical C code:</p>

<pre class="code">
// C:

int fd;
if((fd = open("qqqq", O_RDONLY)) == -1)
{
    perror("open");
    if(errno == ENOENT) exit(1);
}
</pre>

<p>If the file is not found, the message like this</p>
<pre class="code">
open: No such file or directory
</pre>
<p>is printed to <tt>stderr</tt> and the program exits with the status
<tt>1</tt>.</p>

<p>What issues are inherent in this code? Firstly, not every program has
<tt>stderr</tt>, so a library function is not allowed to print error messages
there. Secondly, the value of the global variable <tt>errno</tt> can be
rewritten by any subsequent call unless the value is saved explicitly right
after the call. Thirdly, the decision about termination of the process can only
be made by the application. An ordinary library function is not allowed to do
this. Fourthly, in general case C++ program cannot call <tt>std::exit()</tt>,
because destructors of the live objects allocated on the stack won't be
called, and program's logic can be corrupted.</p>

<p>The example adapted for C++ using our class:</p>

<pre class="code">
// C++:

try
{
    int fd = open("qqqq", O_RDONLY);
    if(fd == -1) throw __vic::libc_error("open");
    // or just
    // if(fd == -1) throw __vic::libc_error();
}
catch(const __vic::libc_error &amp;ex)
{
    std::cerr &lt;&lt; ex.what() &lt;&lt; '\n';
    if(ex.code() == ENOENT) return 1;
}
</pre>

<p>As it can be seen, the function handles erroneous situation correctly and
reports it to the caller. Afterwards the caller can handle the error
appropriately. In the elementary case it acts as the former C-program: prints
the message to the standard error output stream and terminates. Moreover,
error code is now saved in the exception and cannot be rewritten by accident.
</p>

<div>
<u><b>Note</b></u>: Usually exceptions of this class shouldn't be thrown explicitly! Use
<a href="#throw_errno"><tt>throw_errno()</tt></a> instead.</div>

<div class="section">Class members</div>

<div>
<pre class="prototype">explicit libc_error(int err_no = errno)</pre>
<blockquote>

<p><tt>err_no</tt> - error code.</p>
<div>
<u>Postcondition</u>: <tt>code() == err_no</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">explicit libc_error(const char *prompt, int err_no = errno)</pre>
<blockquote>

<p><tt>prompt</tt> - a title of the error message. The parameter has the same
meaning as the parameter of <tt>std::perror()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">const char *what() const noexcept</pre>
<blockquote>

<p>Returns error description in the <tt>std::perror()</tt> format.</p>
</blockquote>
</div>

<div>
<pre class="prototype">int code() const</pre>
<pre class="prototype">int get_errno() const</pre>
<blockquote>


<p>Returns stored error code.</p>
</blockquote>
</div>








<h2 id="fixed_vector.h">
<span class="h2_num">2.12</span><tt>__vic/fixed_vector.h</tt>
</h2>


<h3 id="fixed_vector">
<span class="h3_num">2.12.1</span><tt>fixed_vector</tt>
</h3>

<pre class="code">
template&lt;class T&gt;
class fixed_vector : private non_copyable
{
public:
    using value_type     = T;
    using iterator       = <span class="nonterminal">&lt;implementation-defined&gt;</span>;
    using const_iterator = <span class="nonterminal">&lt;implementation-defined&gt;</span>;

    fixed_vector();
    explicit fixed_vector(size_t max_size);
    ~fixed_vector();

    // BEGIN C++11
    fixed_vector(fixed_vector &amp;&amp;o) noexcept;
    fixed_vector &amp;operator=(fixed_vector &amp;&amp;o) noexcept;
    template&lt;class... Args&gt; T &amp;emplace_back(Args &amp;&amp;... args)
    // END C++11

    // size in objects
    size_t size() const;
    size_t capacity() const;
    bool full() const;
    bool empty() const;

    void recreate(size_t new_max_size, bool size_exact = false);
    void *alloc(); // returns pointer to memory for object allocation
    void push_allocated(); // adds last allocated object to the container
    void pop_back();
    void clear();
    void swap(fixed_vector &amp;o) noexcept;

    // element access
    T &amp;operator[](size_t i);
    iterator begin();
    iterator end();
    T &amp;front();
    T &amp;back();

    const T &amp;operator[](size_t i) const;
    const_iterator begin() const;
    const_iterator end() const;
    const_iterator cbegin() const;
    const_iterator cend() const;
    const T &amp;front() const;
    const T &amp;back() const;
};
template&lt;class T&gt;
void swap(fixed_vector&lt;T&gt; &amp;o1, fixed_vector&lt;T&gt; &amp;o2) noexcept;
</pre>

<p>The standard containers in C++98 don't allow to store non-copiable elements.
Even in C++11 elements of containers like <tt>std::vector</tt> have to be at
least noexcept movable. This class solves the problem. It is a dynamic array
for non-copyable objects or just <tt>std::vector</tt> without autogrowing
<tt>capacity()</tt>.</p>

<p>Without <tt>emplace_back()</tt> it is impossible to create arbitrary new
object right in the container's memory. C++98 lacks forwarding references so it
is ear impossible to pass arbitrary parameters to the element's constructor.
<tt>fixed_vector</tt> overcomes this problem using the following mechanism.
The new element is created using several phases:</p>
<ol>
<li>Requesting memory for the new element in the container -
        <tt>alloc()</tt>,</li>
<li>Creation of the object using placement new -
        <tt>new(ptr) type(...)</tt>,</li>
<li>Fixation of the newly created object in the container -
        <tt>push_allocated()</tt>.</li>
</ol>
<p>See the example at the end of the article.</p>

<p>Maximum capacity is specified on creation of the container. Later it
can be changed but all the elements has to be destroyed before. In other words,
the container can be recreated (<tt>recreate()</tt> function).</p>

<p>When available, <tt>emplace_back()</tt> must be used for elements creation.
If not, the unsafe interface described above must be used with care. It is very
ugly and error-prone but solves the task. After the element is created in the
container, you operate with it almost as easy as with any other copyable object
in the standard container. Anyway, it is more efficient and convenient to use
in general than alternative approaches like creating the objects on the free
store and placing only pointers to the container, even if we have
<tt>std::unique_ptr</tt> to manage lifetime of the objects.</p>

<p>Fundamental differences from <tt>std::vector</tt>:</p>
<ol>
<li>Elements don't have to be copyable or movable (<tt>std::vector</tt>
        requires at least noexcept-movability);</li>
<li>Elements have stable addresses after addition of new element;</li>
<li>
<tt>emplace_back()</tt> has precondition (<tt>!full()</tt>).</li>
</ol>

<div class="section">Class members</div>

<div>
<pre class="prototype">typename value_type</pre>
<blockquote>

<p>Type of the elements.</p>
</blockquote>
</div>

<div>
<pre class="prototype">typename iterator</pre>
<pre class="prototype">typename const_iterator</pre>
<blockquote>


<p>Iterators.</p>
</blockquote>
</div>

<div>
<pre class="prototype">fixed_vector()</pre>
<blockquote>

<p>Create the object without memory allocation.</p>
<div>
<u>Postcondition</u>: <tt>capacity() == 0</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">explicit fixed_vector(size_t max_size)</pre>
<blockquote>

<p>Allocates memory for <tt>max_size</tt> elements.</p>
<div>
<u>Postcondition</u>: <tt>capacity() == max_size</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">~fixed_vector()</pre>
<blockquote>

<p>Calls <tt>clear()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">fixed_vector(fixed_vector &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<pre class="prototype">fixed_vector &amp;operator=(fixed_vector &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Move operations for C++11 mode.</p>
</blockquote>
</div>

<div>
<pre class="prototype">size_t size() const</pre>
<pre class="prototype">size_t capacity() const</pre>
<blockquote>


<p>Current size and capacity of the container.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool empty() const</pre>
<blockquote>

<p>Returns <tt>size() == 0</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool full() const</pre>
<blockquote>

<p>Returns <tt>size() == capacity()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void recreate(size_t new_max_size, bool size_exact = false)</pre>
<blockquote>

<p>Recreates the container. At first calls <tt>clear()</tt>, then reallocates
memory buffer if <tt>new_max_size &gt; capacity()</tt> or <tt>size_exact</tt> is
<tt>true</tt> and <tt>new_max_size != capacity()</tt>.</p>
<div>
<u>Postcondition</u>: <tt>capacity() &gt;= new_max_size &amp;&amp; empty() == true</tt>
(if <tt>size_exact == true</tt> then <tt>capacity() == new_max_size &amp;&amp;
empty() == true</tt>)</div>
</blockquote>
</div>

<div>
<pre class="prototype">void *alloc()</pre>
<blockquote>

<p>Returns the raw memory block where new instance of <tt>value_type</tt>
can be allocated.</p>
<div>
<u>Precondition</u>: <tt>!full()</tt>
</div>
<div>
<u>Note</u>: Use <tt>emplace_back()</tt> in C++11 mode.</div>
</blockquote>
</div>

<div>
<pre class="prototype">void push_allocated()</pre>
<blockquote>

<p>This call right after <tt>alloc()</tt> adds the just created object to the
container.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class... Args&gt; T &amp;emplace_back(Args &amp;&amp;... args) <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Constructs new object and adds it to the container (<tt>alloc()</tt> +
<tt>new</tt> + <tt>push_allocated()</tt> with a single call). A reference to
the new object is returned.</p>
<div>
<u>Precondition</u>: <tt>!full()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void pop_back()</pre>
<blockquote>

<p>Remove the last element from the container.</p>
<div>
<u>Precondition</u>: <tt>!empty()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void clear()</pre>
<blockquote>

<p>Destroys the elements in the reverse order they were created.</p>
<div>
<u>Postcondition</u>: <tt>size() == 0</tt> (<tt>empty() == true</tt>)</div>
</blockquote>
</div>

<div>
<pre class="prototype">void swap(fixed_vector &amp;o)</pre>
<pre class="prototype">template&lt;class T&gt; void swap(fixed_vector&lt;T&gt; &amp;o1, fixed_vector&lt;T&gt; &amp;o2) noexcept</pre>
<blockquote>


<p>Swaps the value with <tt>o</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">T &amp;operator[](size_t i)</pre>
<pre class="prototype">const T &amp;operator[](size_t i) const</pre>
<blockquote>


<p>Access to the elements by index.</p>
<div>
<u>Precondition</u>: <tt>i &lt; size()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">T &amp;front()</pre>
<pre class="prototype">const T &amp;front() const</pre>
<pre class="prototype">T &amp;back()</pre>
<pre class="prototype">const T &amp;back() const</pre>
<blockquote>




<p>Access to the first and the last elements.</p>
<div>
<u>Precondition</u>: <tt>!empty()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">iterator begin()</pre>
<pre class="prototype">const_iterator begin() const</pre>
<pre class="prototype">const_iterator cbegin() const</pre>
<pre class="prototype">iterator end()</pre>
<pre class="prototype">const_iterator end() const</pre>
<pre class="prototype">const_iterator cend() const</pre>
<blockquote>






<p>Access to the elements via iterators.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
// Creating vector for 2 objects of class C
__vic::fixed_vector&lt;C&gt; v(2);

// Creating new object in C++98 mode:
new(v.alloc()) C(...); // Request memory and construct the object
v.push_allocated();    // Fixate successfully created object in the container

// Creating new object in C++11 mode:
v.emplace_back(...);
</pre>






<h2 id="fs.h">
<span class="h2_num">2.13</span><tt>__vic/fs.h</tt>
</h2>


<p>Filesystem utilities.</p>

<div>
<u><b>Note</b></u>: All paths are expected to be UTF-8 encoded!</div>


<h3 id="path_exists">
<span class="h3_num">2.13.1</span><tt>path_exists()</tt>, <tt>file_exists()</tt>, <tt>dir_exists()</tt>
</h3>


<pre class="code">
bool path_exists(const char *path);
bool path_exists(const std::string &amp;path);

bool file_exists(const char *path);
bool file_exists(const std::string &amp;path);

bool dir_exists(const char *path);
bool dir_exists(const std::string &amp;path);
</pre>

<p><tt>path_exists()</tt> checks whether the path exists in the system. Second
and third functions additionally check, besides the presence, if the path
references to a regular file or to a directory, respectively.</p>




<h3 id="mkdir">
<span class="h3_num">2.13.2</span><tt>mkdir()</tt>, <tt>mkdir_if_absent()</tt>
</h3>


<pre class="code">
void mkdir(const char *path);
void mkdir(const std::string &amp;path);

bool mkdir_if_absent(const char *path);
bool mkdir_if_absent(const std::string &amp;path);
</pre>

<p>Creates a directory. Throws exception in case of failure.
<tt>mkdir_if_absent()</tt> returns <tt>false</tt> instead of throwing if
the directory already exists.</p>




<h3 id="rmdir">
<span class="h3_num">2.13.3</span><tt>rmdir()</tt>, <tt>rmdir_if_exists()</tt>
</h3>


<pre class="code">
void rmdir(const char *path);
void rmdir(const std::string &amp;path);

bool rmdir_if_exists(const char *path);
bool rmdir_if_exists(const std::string &amp;path);
</pre>

<p>Deletes an empty directory. Throws exception in case of failure.
<tt>rmdir_if_exists()</tt> returns <tt>false</tt> instead of throwing if
the directory doesn't exist.</p>




<h3 id="get_current_dir">
<span class="h3_num">2.13.4</span><tt>get_current_dir()</tt>
</h3>


<pre class="code">
std::string get_current_dir();
</pre>

<p>Returns current working directory.</p>




<h3 id="remove_file">
<span class="h3_num">2.13.5</span><tt>remove_file()</tt>, <tt>remove_file_if_exists()</tt>,
<tt>remove_file_nt()</tt>
</h3>


<pre class="code">
void remove_file(const char *path);
void remove_file(const std::string &amp;path);

bool remove_file_if_exists(const char *path);
bool remove_file_if_exists(const std::string &amp;path);

bool remove_file_nt(const char *path) noexcept;
bool remove_file_nt(const std::string &amp;path) noexcept;
</pre>

<p>Deletes the file. Throws exception in case of failure.</p>

<p><tt>remove_file_if_exists()</tt> returns <tt>false</tt> instead of throwing
if the file doesn't exist.</p>

<p><tt>remove_file_nt()</tt> doestn't throw any exceptions at all,
<tt>false</tt> is returned  in case of failure.</p>




<h3 id="copy_file">
<span class="h3_num">2.13.6</span><tt>copy_file()</tt>, <tt>copy_file_if_exists()</tt>,
<tt>copy_file_replace()</tt>, <tt>copy_file_replace_if_exists()</tt>
</h3>


<pre class="code">
void copy_file(
    const char *src_path, const char *dest_path, bool replace = false);
void copy_file(
    const std::string &amp;src_path, const std::string &amp;dest_path,
    bool replace = false);

bool copy_file_if_exists(
    const char *src_path, const char *dest_path, bool replace = false);
bool copy_file_if_exists(
    const std::string &amp;src_path, const std::string &amp;dest_path,
    bool replace = false);

void copy_file_replace(
    const char *src_path, const char *dest_path);
void copy_file_replace(
    const std::string &amp;src_path, const std::string &amp;dest_path);

bool copy_file_replace_if_exists(
    const char *src_path, const char *dest_path);
bool copy_file_replace_if_exists(
    const std::string &amp;src_path, const std::string &amp;dest_path);
</pre>

<p>Creates a new file <tt>dest_path</tt> which is a copy of a file
<tt>src_path</tt>. If the new file exists and <tt>replace == false</tt>,
the functions fail.</p>

<p><tt>copy_file_if_exists()</tt> returns <tt>false</tt> instead of throwing
if <tt>src_path</tt> doesn't exist.</p>

<p><tt>copy_file_replace()</tt> is the same as <tt>copy_file(..., true)</tt>.
</p>

<p><tt>copy_file_replace_if_exists()</tt> is the same as
<tt>copy_file_if_exists(..., true)</tt>.</p>




<h3 id="move_file">
<span class="h3_num">2.13.7</span><tt>move_file()</tt>, <tt>move_file_if_exists()</tt>,
<tt>move_file_replace()</tt>, <tt>move_file_replace_if_exists()</tt>
</h3>


<pre class="code">
void move_file(const char *src_path, const char *dest_path);
void move_file(const std::string &amp;src_path, const std::string &amp;dest_path);

bool move_file_if_exists(const char *src_path, const char *dest_path);
bool move_file_if_exists(
    const std::string &amp;src_path, const std::string &amp;dest_path);

void move_file_replace(const char *src_path, const char *dest_path);
void move_file_replace(
    const std::string &amp;src_path, const std::string &amp;dest_path);

bool move_file_replace_if_exists(
    const char *src_path, const char *dest_path);
bool move_file_replace_if_exists(
    const std::string &amp;src_path, const std::string &amp;dest_path);
</pre>

<p>Moves a file <tt>src_path</tt> to new location specified by
<tt>dest_path</tt>.</p>

<p>The functions with <tt>_replace</tt> suffix overwrite existing destination
file if exists, others - fail in such case.</p>

<p><tt>move_file_if_exists()</tt> returns <tt>false</tt> instead of throwing
if <tt>src_path</tt> doesn't exist.</p>




<h3 id="rename_file">
<span class="h3_num">2.13.8</span><tt>rename_file()</tt>, <tt>rename_file_if_exists()</tt>,
    <tt>rename_file_replace()</tt>, <tt>rename_file_replace_if_exists()</tt>
</h3>


<pre class="code">
void rename_file(const char *src_name, const char *dest_name);
void rename_file(const std::string &amp;src_name, const std::string &amp;dest_name);

bool rename_file_if_exists(const char *src_name, const char *dest_name);
bool rename_file_if_exists(
    const std::string &amp;src_name, const std::string &amp;dest_name);

void rename_file_replace(const char *src_name, const char *dest_name);
void rename_file_replace(
    const std::string &amp;src_name, const std::string &amp;dest_name);

bool rename_file_replace_if_exists(
    const char *src_name, const char *dest_name);
bool rename_file_replace_if_exists(
    const std::string &amp;src_name, const std::string &amp;dest_name);
</pre>

<p>Renames a file <tt>src_path</tt> to <tt>dest_path</tt>. The new path
has to be located within the same physical filesystem.</p>

<p>As opposed to <tt>std::rename()</tt>, the functions without
<tt>_replace</tt> suffix fail if <tt>dest_path</tt> exists.</p>

<p><tt>rename_file_if_exists()</tt> returns <tt>false</tt> instead of throwing
if <tt>src_path</tt> doesn't exist.</p>




<h3 id="file_size">
<span class="h3_num">2.13.9</span><tt>file_size()</tt>
</h3>


<pre class="code">
uintmax_t file_size(const char *path);
uintmax_t file_size(const std::string &amp;path);
</pre>

<p>Returns file size in bytes.</p>






<h2 id="iterator.h">
<span class="h2_num">2.14</span><tt>__vic/iterator.h</tt>
</h2>


<p>Iterators-related utilities.</p>


<h3 id="begin-array">
<span class="h3_num">2.14.1</span><tt>begin(T[])</tt>, <tt>end(T[])</tt>, <tt>cbegin(T[])</tt>,
<tt>cend(T[])</tt>
</h3>


<pre class="code">
template&lt;class T, size_t N&gt; constexpr T *begin(T (&amp;arr)[N]);
template&lt;class T, size_t N&gt; constexpr T *end(T (&amp;arr)[N]);

template&lt;class T, size_t N&gt; constexpr const T *cbegin(T (&amp;arr)[N]);
template&lt;class T, size_t N&gt; constexpr const T *cend(T (&amp;arr)[N]);
</pre>

<p>Return a pointer to the beginning and past-the-end of the array.</p>

<div class="section">Example</div>
<pre class="code">
int vals[] = { 1, 2, 3 };
std::list&lt;int&gt; lst(__vic::begin(vals), __vic::end(vals));
assert(lst.size() == 3);
</pre>





<h3 id="advance">
<span class="h3_num">2.14.2</span><tt>advance()</tt>
</h3>


<pre class="code">
template&lt;class Iter&gt;
void advance(Iter &amp;it, Iter end, size_t n);
</pre>

<p>A counterpart of <tt>std::advance()</tt> but differs in parameters and
behaviour:</p>
<ol>
<li>Allows only forward movement (<tt>++</tt>),</li>
<li>Checks the range bounds. Returns immediately if <tt>end</tt> is
        reached.</li>
</ol>




<h3 id="next">
<span class="h3_num">2.14.3</span><tt>next()</tt>, <tt>prev()</tt>
</h3>


<pre class="code">
template&lt;class ForwardIterator&gt;
ForwardIterator next(ForwardIterator it);

template&lt;class ForwardIterator&gt;
ForwardIterator next(ForwardIterator it, size_t n);

template&lt;class BidirectionalIterator&gt;
BidirectionalIterator prev(BidirectionalIterator it);

template&lt;class BidirectionalIterator&gt;
BidirectionalIterator prev(BidirectionalIterator it, size_t n);
</pre>

<p><tt>next()</tt> returns an iterator advanced by <tt>n</tt> positions.
<tt>prev()</tt> does the same but in reverse order. As opposed to C++11 STL
functions of the same name, the offset cannot be negative. The versions with
single parameter just call <tt>++it</tt>/<tt>--it</tt> and return the result.
</p>

<div class="section">Example</div>
<pre class="code">
template&lt;class Container&gt;
void f(const Container &amp;c)
{
    // Begin a traversal starting from the second element
    // v.begin() + 1 works only with RandomAccessIterator
    // ++v.begin() may cause a compile error
    for(auto it = __vic::next(c.begin()); it != c.end(); ++it) ...;
}
</pre>







<h2 id="logger.h">
<span class="h2_num">2.15</span><tt>__vic/logger.h</tt>
</h2>


<h3 id="logger">
<span class="h3_num">2.15.1</span><tt>logger</tt>
</h3>


<pre class="code">
class logger : private non_copyable
{
public:
    enum class severity : unsigned char
    {
        trace,
        debug,
        info,
        notice,
        warning,
        error,
        fatal
    };
    using severity_t = severity; // use this alias as a type name
    struct output
    {
        virtual void publish_record(severity_t , const char * , size_t ) = 0;
    protected:
        ~output() = default;
    };
    class settings_t
    {
        struct output &amp;output() const;
        severity_t level() const;
    };
    class record;

    explicit logger(output &amp;out, severity_t = severity::info);
    explicit logger(settings_t s);
    ~logger();

    severity_t level() const;
    void level(severity_t new_level);
    settings_t settings() const;
    output &amp;reset_output(output &amp;out);
    output &amp;get_output();
    const output &amp;get_output() const;

    static constexpr size_t min_buffer_size = ...;
    void shrink_buffer(size_t limit);

    void message(severity_t severity, const char *msg, size_t msg_len);
#if __cpp_lib_string_view // C++17
    void message(severity_t severity, std::string_view msg);

    void trace(std::string_view msg);
    void debug(std::string_view msg);
    void info(std::string_view msg);
    void notice(std::string_view msg);
    void warning(std::string_view msg);
    void error(std::string_view msg);
    void fatal(std::string_view msg);
#else // until C++17
    void message(severity_t severity, const char *msg);
    void message(severity_t severity, const std::string &amp;msg);

    void trace(const char *msg);
    void debug(const char *msg);
    void info(const char *msg);
    void notice(const char *msg);
    void warning(const char *msg);
    void error(const char *msg);
    void fatal(const char *msg);

    void trace(const std::string &amp;msg);
    void debug(const std::string &amp;msg);
    void info(const std::string &amp;msg);
    void notice(const std::string &amp;msg);
    void warning(const std::string &amp;msg);
    void error(const std::string &amp;msg);
    void fatal(const std::string &amp;msg);
#endif

#if __cpp_lib_format &gt;= 202106L // C++20 + P2508
    template&lt;class... Args&gt;
    void format(severity_t s,
        std::format_string&lt;Args...&gt; fmt, Args&amp;&amp;... args);

    template&lt;class Arg1, class... Args&gt;
    void trace(
        std::format_string&lt;Arg1,Args...&gt; fmt, Arg1 &amp;&amp;arg1, Args&amp;&amp;... args);
    template&lt;class Arg1, class... Args&gt;
    void debug(
        std::format_string&lt;Arg1,Args...&gt; fmt, Arg1 &amp;&amp;arg1, Args&amp;&amp;... args);
    template&lt;class Arg1, class... Args&gt;
    void info(
        std::format_string&lt;Arg1,Args...&gt; fmt, Arg1 &amp;&amp;arg1, Args&amp;&amp;... args);
    template&lt;class Arg1, class... Args&gt;
    void notice(
        std::format_string&lt;Arg1,Args...&gt; fmt, Arg1 &amp;&amp;arg1, Args&amp;&amp;... args);
    template&lt;class Arg1, class... Args&gt;
    void warning(
        std::format_string&lt;Arg1,Args...&gt; fmt, Arg1 &amp;&amp;arg1, Args&amp;&amp;... args);
    template&lt;class Arg1, class... Args&gt;
    void error(
        std::format_string&lt;Arg1,Args...&gt; fmt, Arg1 &amp;&amp;arg1, Args&amp;&amp;... args);
    template&lt;class Arg1, class... Args&gt;
    void fatal(
        std::format_string&lt;Arg1,Args...&gt; fmt, Arg1 &amp;&amp;arg1, Args&amp;&amp;... args);
#endif

    record trace();
    record debug();
    record info();
    record notice();
    record warning();
    record error();
    record fatal();

    bool trace_visible() const;
    bool debug_visible() const;
    bool info_visible() const;
    bool notice_visible() const;
    bool warning_visible() const;
    bool error_visible() const;
    bool fatal_visible() const;
};
class logger::record
{
public:
    record(logger &amp;log, severity_t sev);
    ~record();

    record append(const char *str, size_t str_len);

    template&lt;class T&gt; record operator&lt;&lt;(const T &amp;v);
};
const char *to_string(logger::severity_t s);
#if __cpp_lib_string_view // C++17
constexpr std::string_view to_string_view(logger::severity s);
#endif
</pre>

<p>Logging front-end. Provides building of the
log records using operator <tt>&lt;&lt;</tt>, like <tt>iostream</tt>. Each log
record has the associated severity. The logger itself can filter out the
records by severity. There are 7 predefined levels of the severity (in
ascending order):</p>
<ol>
<li>TRACE - detailed debug,</li>
<li>DEBUG - debug,</li>
<li>INFO - informational,</li>
<li>NOTICE - normal but significant event,</li>
<li>WARNING - insignificant error or suspicious situation,</li>
<li>ERROR - severe error but the application can continue,</li>
<li>FATAL - critical unrecoverable error, the application can't
        continue.</li>
</ol>

<p>INFO is the default logging level but any other can be chosen. If severity
of the log message (record) is below the logging level, it will be ignored and
will not be published in the log's output.</p>

<p>For creation of messages with the required severity, the set of functions
with the same name as the severity is available. For instance <tt>info()</tt>
for INFO messages. Or alternatively the universal function <tt>message()</tt>
can be used, in which the severity is the argument. Usually the specific
functions should be used.</p>

<p>There are two ways of logging. The first is plain and common:</p>
<pre class="code">
log.trace("Trace message");
log.debug("Debug message");
log.info("Info message");
log.notice("Notice");
log.warning("Warning");
log.error("Recoverable error");
log.fatal("Fatal error");
</pre>

<p>The second is slightly more complex but provides more capabilities:</p>
<pre class="code">
log.error() &lt;&lt; "Cannot open file " &lt;&lt; filename &lt;&lt; '!';
log.warning() &lt;&lt; "Loop iteration no " &lt;&lt; i;
</pre>

<p>The call without parameters creates the object of type
<tt>logger::record</tt> with the corresponding severity. Futher, the message
is formed using operators <tt>&lt;&lt;</tt>. The message will be output to the
log at the end of the full-expression (term from the Standard).</p>

<p>If the message can't or shouldn't be formed with a single expression,
the named object of type <tt>logger::record</tt> has to be created, and parts
of the message have to be written to it. The resulting message will be output
to the log by it's destructor:</p>
<pre class="code">
{
    logger::record rec = log.info(); // Begin new record
    rec &lt;&lt; "List elements: ";
    for(auto el : list) rec &lt;&lt; el &lt;&lt; ", ";
    // Constructed record will be printed to the log when the block exits
}
</pre>

<div>
<u><b>Note</b></u>: In order to optimize the performace, use the plain functional notation
when the complete message is available:</div>
<pre class="code">
log.info("Message");
// but not
log.info() &lt;&lt; "Message";
</pre>

<p>Output of the records with the severities DEBUG and TRACE is usually disabled.
Such records will not be published in the log but the program will waste
time to format it. Therefore before creating any debug message using operator
<tt>&lt;&lt;</tt> one should check if debug is enabled using
<tt>debug_visible()</tt> or <tt>trace_visible()</tt> call:</p>
<pre class="code">
if(log.debug_visible())
    log.debug() &lt;&lt; ...; // build the message
</pre>
<p>This advice doesn't cover plain calls <tt>debug(msg)</tt> and
<tt>trace(msg)</tt>, which have a prepared message already and don't perform any
formatting.</p>

<p>To use <tt>logger</tt> one has to implement abstract base class
<tt>logger::output</tt> (override <tt>publish_record()</tt>). The implementation
has to output the passed record somewhere, e.g. to file, terminal or DB. The
output specified during <tt>logger</tt> construction can be replaced later
using <tt>reset_output()</tt>.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">severity::trace</pre>
<pre class="prototype">severity::debug</pre>
<pre class="prototype">severity::info</pre>
<pre class="prototype">severity::notice</pre>
<pre class="prototype">severity::warning</pre>
<pre class="prototype">severity::error</pre>
<pre class="prototype">severity::fatal</pre>
<blockquote>







<p>Severity constants. Use this form for both C++11 and C++98 mode.</p>
</blockquote>
</div>

<div>
<pre class="prototype">typename severity_t</pre>
<blockquote>

<p>Use this identifier as a type name if your code has to be C++98-compatible.
Since C++11 it is just a synonym for <tt>severity</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">class output</pre>
<blockquote>

<p>Logging back-end interface.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void output::publish_record(severity_t sev, const char *buf, size_t buf_len)</pre>
<blockquote>

<p>The implementaion of this pure virtual function has to output the content of
<tt>buf</tt> to the log as one record. <tt>buf_len</tt> is the length of
<tt>buf</tt>. The function is always called with <tt>sev &gt;= level()</tt>.
The implementation can rely on it.</p>
</blockquote>
</div>

<div>
<pre class="prototype">class settings_t</pre>
<blockquote>

<p>Keeps the logger settings: logging level and reference to output
(<tt>level()</tt> + <tt>get_output()</tt>).</p>
</blockquote>
</div>

<div>
<pre class="prototype">explicit logger(output &amp;out, severity_t level = severity::info)</pre>
<blockquote>

<p>Creates logger with the specified output and logging level. The output object
must outlive the logger object!</p>
<div>
<u>Postcondition</u>: <tt>this-&gt;level() == level &amp;&amp; &amp;this-&gt;get_output() == &amp;out</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">explicit logger(settings_t s)</pre>
<blockquote>

<p>Creates logger using the specified settings.</p>
</blockquote>
</div>

<div>
<pre class="prototype">severity_t level() const</pre>
<blockquote>

<p>Returns current logging level.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void level(severity_t new_level)</pre>
<blockquote>

<p>Sets the logging level.</p>
<div>
<u>Postcondition</u>: <tt>level() == new_level</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">settings_t settings() const</pre>
<blockquote>

<p>Returns current logging settings.</p>
</blockquote>
</div>

<div>
<pre class="prototype">output &amp;reset_output(output &amp;out)</pre>
<blockquote>

<p>Sets new output and returns the previous one.</p>
<div>
<u>Postcondition</u>: <tt>&amp;get_output() == &amp;out</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">output &amp;get_output()</pre>
<pre class="prototype">const output &amp;get_output() const</pre>
<blockquote>


<p>Returns reference to the current logging output.</p>
</blockquote>
</div>

<div>
<pre class="prototype">static constexpr size_t min_buffer_size</pre>
<blockquote>

<p>Minimal size of the internal buffer in bytes.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void shrink_buffer(size_t limit)</pre>
<blockquote>

<p>Sets the internal buffer size to <tt>min_buffer_size</tt> if it is more than
<tt>limit</tt> bytes. Allows to restrict the buffer growth when long records
are formed.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void message(severity_t severity, const char *msg, size_t msg_len)</pre>
<pre class="prototype">void message(severity_t severity, std::string_view msg) <span class="sign">[C++17]</span></pre>
<pre class="prototype">void message(severity_t severity, const char *msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void message(severity_t severity, const std::string &amp;msg) <span class="sign">[until C++17]</span></pre>
<blockquote>




<p>Writes the message with the specified severity.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void trace(std::string_view msg) <span class="sign">[C++17]</span></pre>
<pre class="prototype">void trace(const char *msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void trace(const std::string &amp;msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void debug(std::string_view msg) <span class="sign">[C++17]</span></pre>
<pre class="prototype">void debug(const char *msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void debug(const std::string &amp;msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void info(std::string_view msg) <span class="sign">[C++17]</span></pre>
<pre class="prototype">void info(const char *msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void info(const std::string &amp;msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void notice(std::string_view msg) <span class="sign">[C++17]</span></pre>
<pre class="prototype">void notice(const char *msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void notice(const std::string &amp;msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void warning(std::string_view msg) <span class="sign">[C++17]</span></pre>
<pre class="prototype">void warning(const char *msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void warning(const std::string &amp;msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void error(std::string_view msg) <span class="sign">[C++17]</span></pre>
<pre class="prototype">void error(const char *msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void error(const std::string &amp;msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void fatal(std::string_view msg) <span class="sign">[C++17]</span></pre>
<pre class="prototype">void fatal(const char *msg) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">void fatal(const std::string &amp;msg) <span class="sign">[until C++17]</span></pre>
<blockquote>





















<p>Writes the message with the corresponding severity.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class... Args&gt;
void format(severity_t s,
    std::format_string&lt;Args...&gt; fmt, Args&amp;&amp;... args) <span class="sign">[C++20]</span></pre>
<blockquote>

<p>Formats the message using the specified format string and arguments (like
<tt>std::format</tt> does) then writes it with the specified severity.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class Arg1, class... Args&gt;
void trace(std::format_string&lt;Arg1,Args...&gt; fmt, Arg1 &amp;&amp;arg1, Args&amp;&amp;... args) <span class="sign">[C++20]</span></pre>
<pre class="prototype">template&lt;class Arg1, class... Args&gt;
void debug(std::format_string&lt;Arg1,Args...&gt; fmt, Arg1 &amp;&amp;arg1, Args&amp;&amp;... args) <span class="sign">[C++20]</span></pre>
<pre class="prototype">template&lt;class Arg1, class... Args&gt;
void info(std::format_string&lt;Arg1,Args...&gt; fmt, Arg1 &amp;&amp;arg1, Args&amp;&amp;... args) <span class="sign">[C++20]</span></pre>
<pre class="prototype">template&lt;class Arg1, class... Args&gt;
void notice(std::format_string&lt;Arg1,Args...&gt; fmt, Arg1 &amp;&amp;arg1, Args&amp;&amp;... args) <span class="sign">[C++20]</span></pre>
<pre class="prototype">template&lt;class Arg1, class... Args&gt;
void warning(std::format_string&lt;Arg1,Args...&gt; fmt, Arg1 &amp;&amp;arg1, Args&amp;&amp;... args) <span class="sign">[C++20]</span></pre>
<pre class="prototype">template&lt;class Arg1, class... Args&gt;
void error(std::format_string&lt;Arg1,Args...&gt; fmt, Arg1 &amp;&amp;arg1, Args&amp;&amp;... args) <span class="sign">[C++20]</span></pre>
<pre class="prototype">template&lt;class Arg1, class... Args&gt;
void fatal(std::format_string&lt;Arg1,Args...&gt; fmt, Arg1 &amp;&amp;arg1, Args&amp;&amp;... args) <span class="sign">[C++20]</span></pre>
<blockquote>







<p>Formats the message using the specified format string and arguments (like
<tt>std::format</tt> does) then writes it with the corresponding severity.</p>
</blockquote>
</div>

<div>
<pre class="prototype">logger::record trace()</pre>
<pre class="prototype">logger::record debug()</pre>
<pre class="prototype">logger::record info()</pre>
<pre class="prototype">logger::record notice()</pre>
<pre class="prototype">logger::record warning()</pre>
<pre class="prototype">logger::record error()</pre>
<pre class="prototype">logger::record fatal()</pre>
<blockquote>







<p>Creates new record with the corresponding severity. Message parts can be
added using operators <tt>&lt;&lt;</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool trace_visible() const</pre>
<pre class="prototype">bool debug_visible() const</pre>
<pre class="prototype">bool info_visible() const</pre>
<pre class="prototype">bool notice_visible() const</pre>
<pre class="prototype">bool warning_visible() const</pre>
<pre class="prototype">bool error_visible() const</pre>
<pre class="prototype">bool fatal_visible() const</pre>
<blockquote>







<p>Returns <tt>true</tt> if a record with the corresponding severity will be
published. Usage of this functions enables to avoid formatting of the
messages which eventually will not be published.</p>
</blockquote>
</div>

<div>
<pre class="prototype">record::record(logger &amp;log, severity_t sev)</pre>
<blockquote>

<p>Creates the log record with the specified severity. Usually the <tt>logger</tt>'s
functions like <tt>info()</tt> without parameters should be used instead.</p>
</blockquote>
</div>

<div>
<pre class="prototype">record::~record()</pre>
<blockquote>

<p>Outputs the constructed record to the log.</p>
</blockquote>
</div>

<div>
<pre class="prototype">record record::append(const char *str, size_t str_len)</pre>
<blockquote>

<p>Appends the string to the message.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class T&gt; record record::operator&lt;&lt;(const T &amp;v)</pre>
<blockquote>

<p>The set of inserters for various data types. Call <tt>sb &lt;&lt; v</tt>
where type of <tt>sb</tt> is <tt>__vic::string_buffer</tt>.</p>
</blockquote>
</div>



<div class="section">Free functions</div>

<div>
<pre class="prototype">const char *to_string(logger::severity_t s)</pre>
<pre class="prototype">constexpr std::string_view to_string_view(logger::severity s) <span class="sign">[C++17]</span></pre>
<blockquote>


<p>Returns text label for the specified severity that can be printed to the
log. For example, <tt>"DEBUG"</tt> will be returned for
<tt>severity::debug</tt>.</p>
</blockquote>
</div>



<div class="section">Example</div>

<pre class="code">
/////////////////////////////////////////////////////////////////////////////
// Output messages to std::clog with the severity label
class coutput : public __vic::logger::output
{
public:
    void publish_record(__vic::logger::severity_t s,
                            const char *rec, size_t rec_n)
    {
        std::clog &lt;&lt; to_string(s) &lt;&lt; ": ";
        std::clog.write(rec, rec_n) &lt;&lt; std::endl;
    }
};
/////////////////////////////////////////////////////////////////////////////

int main()
{
    coutput log_output:
    __vic::logger log(log_output, __vic::logger::severity::debug);

    log.info("Application is started");

    for(int i = 0; i &lt; 5; i++)
        log.debug() &lt;&lt; "Loop i = " &lt;&lt; i;

    log.warning("Application end");
}
</pre>

<p>Output:</p>

<pre class="code">
INFO: Application is started
DEBUG: Loop i = 0
DEBUG: Loop i = 1
DEBUG: Loop i = 2
DEBUG: Loop i = 3
DEBUG: Loop i = 4
WARNING: Application end
</pre>







<h2 id="memory.h">
<span class="h2_num">2.16</span><tt>__vic/memory.h</tt>
</h2>


<p>Memory-related utilities.</p>


<h3 id="load_unaligned">
<span class="h3_num">2.16.1</span><tt>load_unaligned()</tt>
</h3>


<pre class="code">
template&lt;class T&gt;
T load_unaligned(const void *p);
</pre>

<p>Load value from potentially unaligned address without causing bus error
(<tt>SIGBUS</tt>).</p>

<div class="section">Example</div>
<pre class="code">
const void *p = ...;
// int data = *static_cast&lt;const int *&gt;(p); // potential bus error
int data = __vic::load_unaligned&lt;int&gt;(p);
</pre>





<h3 id="store_unaligned">
<span class="h3_num">2.16.2</span><tt>store_unaligned()</tt>
</h3>


<pre class="code">
template&lt;class T&gt;
void store_unaligned(void *p, T v);
</pre>

<p>Store value to potentially unaligned address without causing bus error
(<tt>SIGBUS</tt>).</p>

<div class="section">Example</div>
<pre class="code">
void *p = ...;
// *static_cast&lt;int *&gt;(p) = 123; // potential bus error
__vic::store_unaligned(p, 123);
</pre>







<h2 id="mutex.h">
<span class="h2_num">2.17</span><tt>__vic/mutex.h</tt>
</h2>



<h3 id="mutex">
<span class="h3_num">2.17.1</span><tt>mutex</tt>
</h3>


<pre class="code">
class mutex : private non_copyable
{
public:
    mutex();
    ~mutex();

    void lock();
    bool try_lock();
    bool unlock() noexcept;
};
</pre>

<p>Plain non-recursive mutex.</p>

<div class="section">Usage notes</div>
<p>In most cases explicit usage of <tt>lock()</tt> and <tt>unlock()</tt> should
be avoided. Use class <a href="#mutex_lock"><tt>mutex_lock</tt></a> to manage locks instead. It provides
exception safety and it's handy for usage.</p>
<p>In C++11 mode <tt>std::mutex</tt> can be a better alternative.</p>


<div class="section">Class members</div>

<div>
<pre class="prototype">mutex()</pre>
<blockquote>

<p>Creates unlocked mutex.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~mutex()</pre>
<blockquote>

<p>Destroys the mutex.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void lock()</pre>
<blockquote>

<p>Acquires the mutex. Waits until released if acquired by other
thread at the moment.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool try_lock()</pre>
<blockquote>

<p>Tries to acquire the mutex. Immediately returns <tt>false</tt> if it's
already acquired by another thread, without waiting.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool unlock() noexcept</pre>
<blockquote>

<p>Releases the mutex acquired before. In some cases can return <tt>false</tt>
in case of error, but in general error detection is not guaranteed.</p>
</blockquote>
</div>



<div class="section">Example</div>
<p>See <a href="#mutex_lock"><tt>mutex_lock</tt></a>.</p>





<h3 id="mutex_lock">
<span class="h3_num">2.17.2</span><tt>mutex_lock</tt>
</h3>


<pre class="code">
class mutex_lock : private non_copyable
{
public:
    enum adopt_t { adopt };

    explicit mutex_lock(mutex &amp;mtx);
    mutex_lock(mutex &amp;mtx, adopt_t);
    ~mutex_lock();
};
</pre>

<p>Manages the lock on a mutex. The lock exists while the object is alive.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">adopt</pre>
<blockquote>

<p>Constructor tag, suppresses the mutex acquisition.</p>
</blockquote>
</div>

<div>
<pre class="prototype">explicit mutex_lock(mutex &amp;mtx)</pre>
<blockquote>

<p>Acquires <tt>mtx</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~mutex_lock()</pre>
<blockquote>

<p>Releases <tt>mtx</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">mutex_lock(mutex &amp;mtx, adopt_t)</pre>
<blockquote>

<p>Adopts already acquired <tt>mtx</tt>. See the example.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
// Typical usage
__vic::mutex mtx;
void reentrant_function()
{
    __vic::mutex_lock lock(mtx);
    // Critical section code until the end of the block
    ...
}

// Usage of non-acquiring constructor
if(mtx.try_lock()) // Try to acquire the mutex
{
    // The mutex has been successfully acquired
    __vic::mutex_lock lock(mtx, __vic::mutex_lock::adopt);
    // Critical section code until the end of the block
    ...
}
else
{
    // The mutex is acquired by another thread
    ...
}
</pre>







<h2 id="packon.h">
<span class="h2_num">2.18</span><tt>__vic/packon.h</tt> &amp; <tt>__vic/packoff.h</tt>
</h2>


<p>Inclusion of the first file turns off struct members alignment. In other
words, turns on "structures packing" - size of the struct is strictly a sum of
its members sizes. Inclusion of the second one restores the default alignment.
So that the pair of <tt>#include</tt> directives forms a section in the source
file where structs alignment is disabled.</p>

<div>
<u><b>Note</b></u>: Each <tt>#include&lt;__vic/packon.h&gt;</tt> must have the corresponding
<tt>#include&lt;__vic/packoff.h&gt;</tt>.</div>

<div class="section">Example</div>
<pre class="code">
struct unpacked
{
    bool f1;
    int f2;
};
static_assert(sizeof(unpacked) &gt;= sizeof(bool) + sizeof(int),
    "Total struct size can exceed the sum of members sizes");

#include&lt;__vic/packon.h&gt; // alignment disabled starting from here

struct packed
{
    bool f1;
    int f2;
};
static_assert(sizeof(packed) == sizeof(bool) + sizeof(int),
    "Total struct size is exactly the sum of members sizes");

#include&lt;__vic/packoff.h&gt; // alignment enabled again
</pre>




<h2 id="readers">
<span class="h2_num">2.19</span><tt>__vic/readers/</tt>
</h2>



<h3 id="reader-concept">
<span class="h3_num">2.19.1</span><tt>Reader</tt> concept</h3>


<pre class="code">
template&lt;class ElementT&gt;
class <span class="nonterminal">Reader</span>
{
public:
    Reader(Reader &amp;&amp;o); or Reader(const Reader &amp;o);
    bool read(ElementT &amp;v); // throws on errors
};
</pre>

<p>A concept used by the library algorithms to read logical sequence of elements
of type <tt>ElementT</tt> element by element. It is a generalization and rework
of the <tt>InputIterator</tt> concept. In particular it handles streams,
NULL-terminated strings and other sequences where <tt>end</tt>-iterator is
meaningless or expensive to obtain better. At the same time, a traditional
[<tt>begin</tt>,<tt>end</tt>) pair of iterators is just a particular case and
fully and well handled by <tt>__vic::iterator_reader</tt> adapter.</p>

<p>When the particular class meets the requirements of this concept for some
<tt>ElementT = T</tt> it is said <b>to model</b> the <tt>Reader&lt;T&gt;</tt>
concept.</p>

<p>Each instance of the class has to be move- or copy-constructible.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">bool read(ElementT &amp;v)</pre>
<blockquote>

<p>Attempts to get the next element of the sequence. Returns <tt>true</tt> and
places the value to <tt>v</tt> on success. Returns <tt>false</tt> if no element
available (EOF). Throws an exception in other cases.</p>
</blockquote>
</div>






<h3 id="iterator_reader">
<span class="h3_num">2.19.2</span><tt>iterator_reader</tt>
</h3>


<pre class="code">
#include&lt;__vic/readers/iterator.h&gt;

template&lt;class InputIterator,
         class T = typename std::iterator_traits&lt;InputIterator&gt;::value_type&gt;
class iterator_reader
{
public:
    iterator_reader(InputIterator begin, InputIterator end);
    bool read(T &amp;v);
    InputIterator position() const;
};

template&lt;class InputIterator&gt; iterator_reader&lt;InputIterator&gt;
make_iterator_reader(InputIterator begin, InputIterator end);

template&lt;class T, class InputIterator&gt; iterator_reader&lt;InputIterator,T&gt;
make_iterator_reader_for(InputIterator begin, InputIterator end);
</pre>

<p>An adapter for a traditional [<tt>begin</tt>,<tt>end</tt>) pair of iterators.
</p>

<p>Additional <tt>position()</tt> function returns the current iterator
position.</p>

<p>Can be created using constructor or one of <tt>make_...</tt> functions.</p>




<h3 id="iterator_reader_n">
<span class="h3_num">2.19.3</span><tt>iterator_reader_n</tt>
</h3>


<pre class="code">
#include&lt;__vic/readers/iterator.h&gt;

template&lt;class InputIterator,
         class T = typename std::iterator_traits&lt;InputIterator&gt;::value_type&gt;
class iterator_reader_n
{
public:
    iterator_reader_n(InputIterator begin, size_t n);
    bool read(T &amp;v);
    InputIterator position() const;
};

template&lt;class InputIterator&gt; iterator_reader_n&lt;InputIterator&gt;
make_iterator_reader_n(InputIterator begin, size_t n);

template&lt;class T, class InputIterator&gt; iterator_reader_n&lt;InputIterator,T&gt;
make_iterator_reader_n_for(InputIterator begin, size_t n);
</pre>

<p>An adapter for iterator + elements counter.</p>

<p>Additional <tt>position()</tt> function returns the current iterator
position.</p>

<p>Can be created using constructor or one of <tt>make_...</tt> functions.</p>




<h3 id="container_reader">
<span class="h3_num">2.19.4</span><tt>container_reader</tt>
</h3>


<pre class="code">
#include&lt;__vic/readers/container.h&gt;

template&lt;class Cont, class T = typename Cont::value_type&gt;
class container_reader
{
public:
    explicit container_reader(const Cont &amp;c);
    bool read(T &amp;v);
    typename Cont::const_iterator position() const;
};

template&lt;class Cont&gt;
container_reader&lt;Cont&gt; make_container_reader(const Cont &amp;c);

template&lt;class T, class Cont&gt;
container_reader&lt;Cont,T&gt; make_container_reader_for(const Cont &amp;c);
</pre>

<p>An adapter for STL-style container classes with <tt>begin()</tt> and
<tt>end()</tt> members.</p>

<p>Additional <tt>position()</tt> function returns the current iterator
position.</p>

<p>Can be created using constructor or one of <tt>make_...</tt> functions.</p>




<h3 id="cstring_reader">
<span class="h3_num">2.19.5</span><tt>cstring_reader</tt>
</h3>


<pre class="code">
#include&lt;__vic/readers/cstring.h&gt;

template&lt;class charT&gt;
class basic_cstring_reader
{
public:
    explicit basic_cstring_reader(const charT *s);
    bool read(charT &amp;ch);
    const charT *position() const;
};

template&lt;&gt;
class basic_cstring_reader&lt;char&gt;
{
public:
    explicit basic_cstring_reader(const char *s);
    bool read(char &amp;ch);
    bool read(unsigned char &amp;ch);
    const char *position() const;
};
using cstring_reader = basic_cstring_reader&lt;char&gt;;

template&lt;class charT&gt;
basic_cstring_reader&lt;charT&gt; make_cstring_reader(const charT *s);
</pre>

<p>An adapter for NULL-terminated C-style strings.</p>

<p>Additional <tt>position()</tt> function returns the current pointer
position.</p>

<p><tt>char</tt> specialization models <tt>Reader&lt;unsigned char&gt;</tt> as
well as <tt>Reader&lt;char&gt;</tt>.</p>

<p>Can be created using constructor or <tt>make_...</tt> function.</p>




<h3 id="string_reader">
<span class="h3_num">2.19.6</span><tt>string_reader</tt>
</h3>


<pre class="code">
#include&lt;__vic/readers/string.h&gt;

template&lt;
    class charT,
    class Tr = std::char_traits&lt;charT&gt;,
    class Al = std::allocator&lt;charT&gt;
&gt;
class basic_string_reader
{
public:
    explicit basic_string_reader(const std::basic_string&lt;charT,Tr,Al&gt; &amp;s);
    bool read(charT &amp;ch);
    const charT *position() const;
};

template&lt;class Tr, class Al&gt;
class basic_string_reader&lt;char,Tr,Al&gt;
{
public:
    explicit basic_string_reader(const std::basic_string&lt;char,Tr,Al&gt; &amp;s);
    bool read(char &amp;ch);
    bool read(unsigned char &amp;ch);
    const char *position() const;
};
using string_reader = basic_string_reader&lt;char&gt;;

template&lt;class charT, class Tr, class Al&gt;
basic_string_reader&lt;charT,Tr,Al&gt;
    make_string_reader(const std::basic_string&lt;charT,Tr,Al&gt; &amp;s);
</pre>

<p>An adapter for <tt>std::basic_string</tt>.</p>

<p>Additional <tt>position()</tt> function returns the current pointer
position.</p>

<p><tt>char</tt> specialization models <tt>Reader&lt;unsigned char&gt;</tt> as
well as <tt>Reader&lt;char&gt;</tt>.</p>

<p>Can be created using constructor or <tt>make_...</tt> function.</p>




<h3 id="cstream_reader">
<span class="h3_num">2.19.7</span><tt>cstream_reader</tt>
</h3>


<pre class="code">
#include&lt;__vic/readers/cstream.h&gt;

class cstream_reader
{
public:
    explicit cstream_reader(std::FILE *fp);
    bool read(char &amp;ch) { return __vic::read(fp, ch); }
    bool read(unsigned char &amp;ch) { return __vic::read(fp, ch); }
};

cstream_reader make_cstream_reader(std::FILE *fp);
</pre>

<p>Models <tt>Reader&lt;char&gt;</tt> and <tt>Reader&lt;unsigned char&gt;</tt> for
<tt>std::FILE</tt>.</p>

<p>Can be created using constructor or <tt>make_...</tt> function.</p>






<h2 id="readonly_cstring.h">
<span class="h2_num">2.20</span><tt>__vic/readonly_cstring.h</tt>
</h2>


<h3 id="readonly_cstring">
<span class="h3_num">2.20.1</span><tt>readonly_cstring</tt>
</h3>


<pre class="code">
class readonly_cstring
{
public:
    readonly_cstring();
    readonly_cstring(const char *str);
    readonly_cstring(const char *begin, const char *end);
    readonly_cstring(const char *chars, size_t n);
    readonly_cstring(const readonly_cstring &amp;str);
    ~readonly_cstring() noexcept;

    // BEGIN C++11
    readonly_cstring(readonly_cstring &amp;&amp;str) noexcept;
    readonly_cstring &amp;operator=(readonly_cstring &amp;&amp;str) noexcept;
    // END C++11

    readonly_cstring &amp;operator=(const char *str);
    readonly_cstring &amp;operator=(const readonly_cstring &amp;str);
    readonly_cstring &amp;assign(const char *str);
    readonly_cstring &amp;assign(const char *chars, size_t n);
    readonly_cstring &amp;assign(const char *begin, const char *end);

    bool empty() const;
    const char *c_str() const;
    operator const char*() const;

    char *reserve(size_t n);
    void swap(readonly_cstring &amp;str) noexcept;
};

int compare(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2);
int compare(const readonly_cstring &amp;s1, const char *s2);
int compare(const char *s1, const readonly_cstring &amp;s2);

bool operator==(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2);
bool operator!=(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2);
bool operator&lt;(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2);
bool operator&gt;(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2);
bool operator&lt;=(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2);
bool operator&gt;=(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2);

bool operator==(const readonly_cstring &amp;s1, const char *s2);
bool operator!=(const readonly_cstring &amp;s1, const char *s2);
bool operator&lt;(const readonly_cstring &amp;s1, const char *s2);
bool operator&gt;(const readonly_cstring &amp;s1, const char *s2);
bool operator&lt;=(const readonly_cstring &amp;s1, const char *s2);
bool operator&gt;=(const readonly_cstring &amp;s1, const char *s2);

bool operator==(const char *s1, const readonly_cstring &amp;s2);
bool operator!=(const char *s1, const readonly_cstring &amp;s2);
bool operator&lt;(const char *s1, const readonly_cstring &amp;s2);
bool operator&gt;(const char *s1, const readonly_cstring &amp;s2);
bool operator&lt;=(const char *s1, const readonly_cstring &amp;s2);
bool operator&gt;=(const char *s1, const readonly_cstring &amp;s2);

void swap(readonly_cstring &amp;s1, readonly_cstring &amp;s2) noexcept;
</pre>

<p>The simple non-mutable null-terminated string class with automatic memory
management. Has simple and predictable structure that can be useful when
ABI compatibility/stability is required or when usage of <tt>std::string</tt>
is objectionable for some reason. The functionality provided by the class is
also minimal. It provides string copying and storing and read access to it.
One cannot modify string parts - only replace the whole value.</p>

<p>If one need to store a string value in a class, usage of this class may be a
good choice. It's easier-to-use, more clear and safer than array of chars
(<tt>char[]</tt>) and can be more efficient than <tt>std::string</tt>,
though, of course, less universal. If modifications of the string parts are
expected, usage of another string class should be considered, for instance,
<tt>__vic::string_buffer</tt>. Class <tt>readonly_cstring</tt> is not designed
for such purposes.</p>

<div class="section">Guarantees provided by the class design</div>
<ul>
<li>Null pointer value is treated as an empty string.</li>
<li>Cast to C-string (<tt>const char *</tt>) always returns valid
        pointer, never <tt>nullptr</tt>.</li>
<li>For each string value, exact amount of memory is allocated. No extra
        memory reserved.</li>
<li>Class contains single data member - pointer to the holded string,
        so the total object's size is likely one pointer.</li>
</ul>


<div class="section">Class members</div>

<div>
<pre class="prototype">readonly_cstring()</pre>
<blockquote>

<p>Creates an empty string.</p>
<div>
<u>Postcondition</u>: <tt>empty() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">readonly_cstring(const char *str)</pre>
<pre class="prototype">readonly_cstring(const readonly_cstring &amp;str)</pre>
<blockquote>


<p>Creates a copy of <tt>str</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">readonly_cstring(const char *chars, size_t n)</pre>
<pre class="prototype">readonly_cstring(const char *begin, const char *end)</pre>
<blockquote>


<p>Creates a string from characters range.</p>
</blockquote>
</div>

<div>
<pre class="prototype">readonly_cstring &amp;operator=(const char *str)</pre>
<pre class="prototype">readonly_cstring &amp;operator=(const readonly_cstring &amp;str)</pre>
<pre class="prototype">readonly_cstring &amp;assign(const char *str)</pre>
<blockquote>



<p>Assigns <tt>str</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">readonly_cstring(readonly_cstring &amp;&amp;str) noexcept <span class="sign">[C++11]</span></pre>
<pre class="prototype">readonly_cstring &amp;operator=(readonly_cstring &amp;&amp;str) noexcept <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Move operations for C++11 mode.</p>
</blockquote>
</div>

<div>
<pre class="prototype">readonly_cstring &amp;assign(const char *begin, const char *end)</pre>
<pre class="prototype">readonly_cstring &amp;assign(const char *chars, size_t n)</pre>
<blockquote>


<p>Assigns the string constructed from characters range.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool empty() const</pre>
<blockquote>

<p>Returns <tt>true</tt> if string is empty.</p>
</blockquote>
</div>

<div>
<pre class="prototype">const char *c_str() const</pre>
<pre class="prototype">operator const char*() const</pre>
<blockquote>


<p>Returns a pointer to the stored string. The pointer is never null.</p>
</blockquote>
</div>

<div>
<pre class="prototype">char *reserve(size_t n)</pre>
<blockquote>

<p>Allocates internal buffer for <tt>n</tt> chars and returns the pointer to
it. Can be useful in conjunction with functions like <tt>std::sprintf()</tt>.</p>
<div>
<u>Note</u>: Try to avoid this unsafe function!</div>
</blockquote>
</div>

<div>
<pre class="prototype">void swap(readonly_cstring &amp;str) noexcept</pre>
<blockquote>

<p>Swaps the value with <tt>str</tt>.</p>
</blockquote>
</div>



<div class="section">Free functions</div>

<div>
<pre class="prototype">int compare(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2)</pre>
<pre class="prototype">int compare(const readonly_cstring &amp;s1, const char *s2)</pre>
<pre class="prototype">int compare(const char *s1, const readonly_cstring &amp;s2)</pre>
<blockquote>



<p>Compares two strings as <tt>std::strcmp</tt> does.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool operator==(const readonly_cstring &amp;s1, const readonly_cstring &amp;s2)</pre>
<pre class="prototype">...</pre>
<pre class="prototype">bool operator&gt;=(const char *s1, const readonly_cstring &amp;s2)</pre>
<blockquote>



<p>Full set of comparators for <tt>readonly_cstring</tt> and <tt>const char *</tt>
in all combinations.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void swap(readonly_cstring &amp;s1, readonly_cstring &amp;s2) noexcept</pre>
<blockquote>

<p>Specialization of the standard algorithm.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
class C
{
    __vic::readonly_cstring st;
public:
    explicit C(const char *str) : st(str) {}
    const char *get_str() const { return st; }
};
</pre>






<h2 id="set_of_chars.h">
<span class="h2_num">2.21</span><tt>__vic/set_of_chars.h</tt>
</h2>


<h3 id="set_of_chars">
<span class="h3_num">2.21.1</span><tt>set_of_chars</tt>
</h3>


<pre class="code">
class set_of_chars
{
public:
    constexpr set_of_chars();
    template&lt;class Iter&gt; constexpr set_of_chars(Iter begin, Iter end);
    constexpr set_of_chars(std::initializer_list&lt;char&gt; set); // C++11
    constexpr set_of_chars(const char *c_str);

    constexpr bool contains(char ch) const;

    constexpr void add(char ch);
    constexpr void remove(char ch);

    template&lt;class Iter&gt; constexpr void add(Iter begin, Iter end);
    constexpr void add(const char *c_str);
    constexpr void add(std::initializer_list&lt;char&gt; set); // C++11

    template&lt;class Iter&gt; void assign(Iter begin, Iter end);
    void assign(const char *c_str)
    void assign(std::initializer_list&lt;char&gt; set); // C++11

    void clear();
};
</pre>

<p>Compact (only 32 bytes) and very fast implemetation of a set of chars. The
cost of the <tt>contains()</tt> operation is always constant regardles of the
argument and number of elements in the set.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">constexpr set_of_chars()</pre>
<blockquote>

<p>Creates an empty set.</p>
<div>
<u>Postcondition</u>: <tt>contains(char(ch)) == false</tt> for any char
</div>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class Iter&gt; constexpr set_of_chars(Iter begin, Iter end)</pre>
<pre class="prototype">constexpr set_of_chars(std::initializer_list&lt;char&gt; set) <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Creates a set filled with characters from the specified range of values.</p>
<div>
<u>Note</u>: <tt>constexpr</tt> since C++14 only!</div>
</blockquote>
</div>

<div>
<pre class="prototype">constexpr set_of_chars(const char *c_str)</pre>
<blockquote>

<p>Creates a set filled with characters from the specified C-string excluding
NULL-terminator.</p>
<div>
<u>Note</u>: <tt>constexpr</tt> since C++14 only!</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool contains(char ch) const</pre>
<blockquote>

<p>Checks whether the set contains <tt>ch</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">constexpr void add(char ch)</pre>
<blockquote>

<p>Adds <tt>ch</tt> to the set.</p>
<div>
<u>Postcondition</u>: <tt>contains(ch) == true</tt>
</div>
<div>
<u>Note</u>: <tt>constexpr</tt> since C++14 only!</div>
</blockquote>
</div>

<div>
<pre class="prototype">constexpr void remove(char ch)</pre>
<blockquote>

<p>Removes <tt>ch</tt> from the set.</p>
<div>
<u>Postcondition</u>: <tt>contains(ch) == false</tt>
</div>
<div>
<u>Note</u>: <tt>constexpr</tt> since C++14 only!</div>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class Iter&gt; constexpr void add(Iter begin, Iter end)</pre>
<pre class="prototype">constexpr void add(std::initializer_list&lt;char&gt; set) <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Calls <tt>add(ch)</tt> for each value in the range.</p>
<div>
<u>Note</u>: <tt>constexpr</tt> since C++14 only!</div>
</blockquote>
</div>

<div>
<pre class="prototype">constexpr void add(const char *c_str)</pre>
<blockquote>

<p>Calls <tt>add(ch)</tt> for each character in the C-string excluding
NULL-terminator.</p>
<div>
<u>Note</u>: <tt>constexpr</tt> since C++14 only!</div>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class Iter&gt; void assign(Iter begin, Iter end)</pre>
<pre class="prototype">void assign(const char *c_str)</pre>
<pre class="prototype">void assign(std::initializer_list&lt;char&gt; set) <span class="sign">[C++11]</span></pre>
<blockquote>



<p>Calls <tt>clear()</tt> then <tt>add()</tt> with the specified parameters.
</p>
</blockquote>
</div>

<div>
<pre class="prototype">void clear()</pre>
<blockquote>

<p>Removes all elements from the set.</p>
<div>
<u>Postcondition</u>: <tt>contains(char(ch)) == false</tt> for any char
</div>
</blockquote>
</div>







<h2 id="stdint.h">
<span class="h2_num">2.22</span><tt>__vic/stdint.h</tt>
</h2>


<p>ISO C99 <tt>&lt;stdint.h&gt;</tt> for C++98. Since C++11 - just a redirector to
<tt>&lt;cstdint&gt;</tt>.</p>
<p>Additionally, some metafunctions for template metaprogramming are provided.
</p>


<h3 id="intN_t">
<span class="h3_num">2.22.1</span>Exact-width integer types</h3>


<p>Following types are guaranteed to be available in the <b>global
namespace</b>:</p>
<ul>
<li><tt>int8_t</tt></li>
<li><tt>int16_t</tt></li>
<li><tt>int32_t</tt></li>
<li><tt>int64_t</tt></li>
<li><tt>uint8_t</tt></li>
<li><tt>uint16_t</tt></li>
<li><tt>uint32_t</tt></li>
<li><tt>uint64_t</tt></li>
</ul>




<h3 id="int_leastN_t">
<span class="h3_num">2.22.2</span>Minimum-width integer types</h3>


<p>Following types are guaranteed to be available in the <b>global
namespace</b>:</p>
<ul>
<li><tt>int_least8_t</tt></li>
<li><tt>int_least16_t</tt></li>
<li><tt>int_least32_t</tt></li>
<li><tt>int_least64_t</tt></li>
<li><tt>uint_least8_t</tt></li>
<li><tt>uint_least16_t</tt></li>
<li><tt>uint_least32_t</tt></li>
<li><tt>uint_least64_t</tt></li>
</ul>




<h3 id="int_fastN_t">
<span class="h3_num">2.22.3</span>Fastest minimum-width integer types</h3>


<p>Following types are guaranteed to be available in the <b>global
namespace</b>:</p>
<ul>
<li><tt>int_fast8_t</tt></li>
<li><tt>int_fast16_t</tt></li>
<li><tt>int_fast32_t</tt></li>
<li><tt>int_fast64_t</tt></li>
<li><tt>uint_fast8_t</tt></li>
<li><tt>uint_fast16_t</tt></li>
<li><tt>uint_fast32_t</tt></li>
<li><tt>uint_fast64_t</tt></li>
</ul>




<h3 id="intmax_t">
<span class="h3_num">2.22.4</span>Greatest-width integer types</h3>


<p>Following types are guaranteed to be available in the <b>global
namespace</b>:</p>
<ul>
<li><tt>intmax_t</tt></li>
<li><tt>uintmax_t</tt></li>
</ul>




<h3 id="intptr_t">
<span class="h3_num">2.22.5</span>Integer types capable of holding object pointers</h3>


<p>Following types are guaranteed to be available in the <b>global
namespace</b>:</p>
<ul>
<li><tt>intptr_t</tt></li>
<li><tt>uintptr_t</tt></li>
</ul>




<h3 id="int_exactly_bytes">
<span class="h3_num">2.22.6</span><tt>int_exactly_bytes&lt;&gt;</tt>, <tt>uint_exactly_bytes&lt;&gt;</tt>
</h3>


<pre class="code">
template&lt;unsigned SizeInBytes&gt;
struct int_exactly_bytes
{
    using type = <span class="nonterminal">&lt;signed-integer-type-of-the-corresponding-size&gt;</span>;
};

template&lt;unsigned SizeInBytes&gt;
struct uint_exactly_bytes
{
    using type = <span class="nonterminal">&lt;unsigned-integer-type-of-the-corresponding-size&gt;</span>;
};

// BEGIN C++11
template&lt;unsigned N&gt;
using int_exact_bytes = typename int_exactly_bytes&lt;N&gt;::type;

template&lt;unsigned N&gt;
using uint_exact_bytes = typename uint_exactly_bytes&lt;N&gt;::type;
// END C++11
</pre>

<p>Metafunctions returning the signed/unsigned interger type of the requested
exact size in bytes. Shorter aliases are available in C++11 mode and higher.
Valid <tt>SizeInBytes</tt> values are <tt>1</tt>, <tt>2</tt>, <tt>4</tt>,
<tt>8</tt>.</p>

<div class="section">Example</div>
<pre class="code">
typedef __vic::int_exactly_bytes&lt; sizeof(void *) &gt;::type my_intptr_t;
// or in C++11
using my_intptr_t = __vic::int_exact_bytes&lt; sizeof(void *) &gt;
assert( sizeof(my_intptr) == sizeof(intptr_t) );
</pre>







<h2 id="stdio_file.h">
<span class="h2_num">2.23</span><tt>__vic/stdio_file.h</tt>
</h2>


<p><tt>std::FILE</tt>-related C++ wrappers.</p>


<h3 id="stdio_file">
<span class="h3_num">2.23.1</span><tt>stdio_file</tt>
</h3>


<pre class="code">
class stdio_file : private non_copyable
{
public:
    explicit stdio_file(std::FILE *fp = nullptr);
    stdio_file(const char *name, const char *mode);
    ~stdio_file();

    // BEGIN C++11
    stdio_file(stdio_file &amp;&amp;o) noexcept;
    stdio_file &amp;operator=(stdio_file &amp;&amp;o) noexcept;
    // END C++11

    bool open(const char *name, const char *mode);
    bool is_open() const;
    void close();
    bool close_nt() noexcept;

    void swap(stdio_file &amp;o) noexcept;
    std::FILE *detach_handle() noexcept;
    std::FILE *attach_handle(std::FILE *fp) noexcept;
    std::FILE *handle() const;
    operator std::FILE*() const;
};
</pre>

<p>Thin RAII-wrapper for <tt>std::FILE *</tt>. Controls file's life time.
Automatic conversion to <tt>std::FILE *</tt> allows usage of the object
whereever the file pointer is allowed/required.</p>

<div>
<u><b>Note</b></u>: Although the class destructor closes the open file, it is more safe
to use explicit <tt>close()</tt> call. Errors can happen when closing file,
and <tt>close()</tt> can throw exception in such cases, while destructor -
can't, so the error will be unnoticed by the application.</div>

<div class="section">Class members</div>

<div>
<pre class="prototype">explicit stdio_file(std::FILE *fp = nullptr)</pre>
<blockquote>

<p>Wraps already existing stream pointer.</p>
<div>
<u>Precondition</u>: <tt>fp</tt> is either a pointer to the open file or
<tt>nullptr</tt>.</div>
</blockquote>
</div>

<div>
<pre class="prototype">stdio_file(const char *name, const char *mode)</pre>
<blockquote>

<p>Calls <tt>open(name, mode)</tt>. The result should be checked using
subsequent <tt>is_open()</tt> call!</p>
</blockquote>
</div>

<div>
<pre class="prototype">~stdio_file()</pre>
<blockquote>

<p>Calls <tt>std::fclose()</tt> if <tt>is_open() == true</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">stdio_file(stdio_file &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<pre class="prototype">stdio_file &amp;operator=(stdio_file &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Move operations for C++11 mode.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool open(const char *name, const char *mode)</pre>
<blockquote>

<p>Calls <tt>std::fopen(name, mode)</tt>. Returns <tt>true</tt> in case of
success.</p>
<div>
<u>Precondition</u>: <tt>is_open() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool is_open() const</pre>
<blockquote>

<p>Returns <tt>true</tt> if file is open.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void close()</pre>
<blockquote>

<p>Calls <tt>std::fclose()</tt>. No preliminary checks whether the file is open
are performed! Throws if <tt>std::fclose()</tt> fails.</p>
<div>
<u>Precondition</u>: <tt>is_open() == true</tt>
</div>
<div>
<u>Postcondition</u>: <tt>is_open() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool close_nt() noexcept</pre>
<blockquote>

<p>A counterpart of <tt>close()</tt> but never throws, returns <tt>false</tt>
instead in case of error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void swap(stdio_file &amp;o) noexcept</pre>
<blockquote>

<p>Swaps the value with <tt>o</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">std::FILE *detach_handle() noexcept</pre>
<blockquote>

<p>Releases the file out of the object's control.</p>
<div>
<u>Postcondition</u>: <tt>is_open() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">std::FILE *attach_handle(std::FILE *fp) noexcept</pre>
<blockquote>

<p>Takes <tt>fp</tt> under control and returns the previous handle value.</p>
<div>
<u>Precondition</u>: <tt>fp</tt> is either a poiner to the open file or
<tt>nullptr</tt>.</div>
<div>
<u>Postcondition</u>: <tt>handle() == fp</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">std::FILE *handle() const</pre>
<blockquote>

<p>Returns the held handle value.</p>
</blockquote>
</div>

<div>
<pre class="prototype">operator std::FILE*() const</pre>
<blockquote>

<p>Allows usage of the object as <tt>std::FILE *</tt>.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
__vic::stdio_file file("file.txt", "w");
if(!file.is_open()) throw __vic::exception("Cannot open file");
std::fprintf(file, "Message");
file.close();
// fclose() also will be called in case of exception by destructor
</pre>





<h3 id="read-FILE-char">
<span class="h3_num">2.23.2</span><tt>read(std::FILE, char&amp;)</tt>,
    <tt>read(std::FILE, unsigned char&amp;)</tt>
</h3>


<pre class="code">
bool read(std::FILE *fp, char &amp;ch);
bool read(std::FILE *fp, unsigned char &amp;ch);
</pre>

<p>Attempts to read a byte from the C-stream. Returns <tt>true</tt> on succes,
<tt>false</tt> on EOF or throws on error.</p>



<h3 id="write-FILE-char">
<span class="h3_num">2.23.3</span><tt>write(std::FILE, char)</tt>
</h3>


<pre class="code">
void write(std::FILE *fp, char ch);
</pre>

<p>Writes a byte to the C-stream. Throws on error.</p>



<h3 id="getline-FILE">
<span class="h3_num">2.23.4</span><tt>getline(std::FILE)</tt>
</h3>


<pre class="code">
bool getline(std::FILE *fp, std::string &amp;str, char delim = '\n');
</pre>

<p>A counterpart of <tt>std::getline</tt> but for C-stream. Returns
<tt>false</tt> if the end of the file was reached and nothing was read.</p>





<h2 id="str2num.h">
<span class="h2_num">2.24</span><tt>__vic/str2num.h</tt>
</h2>



<h3 id="decimal_to_number">
<span class="h3_num">2.24.1</span><tt>decimal_to_number()</tt>
</h3>


<pre class="code">
#if __cpp_lib_string_view // since C++17

void decimal_to_number(std::string_view s, long long &amp;res);
void decimal_to_number(std::string_view s, long &amp;res);
void decimal_to_number(std::string_view s, int &amp;res);
void decimal_to_number(std::string_view s, short &amp;res);
void decimal_to_number(std::string_view s, signed char &amp;res);

void decimal_to_number(std::string_view s, unsigned long long &amp;res);
void decimal_to_number(std::string_view s, unsigned long &amp;res);
void decimal_to_number(std::string_view s, unsigned &amp;res);
void decimal_to_number(std::string_view s, unsigned short &amp;res);
void decimal_to_number(std::string_view s, unsigned char &amp;res);

template&lt;class Integer&gt;
[[nodiscard]] Integer decimal_to_number(std::string_view s);

#else // until C++17

void decimal_to_number(const std::string &amp;s, long long &amp;res);
void decimal_to_number(const std::string &amp;s, long &amp;res);
void decimal_to_number(const std::string &amp;s, int &amp;res);
void decimal_to_number(const std::string &amp;s, short &amp;res);
void decimal_to_number(const std::string &amp;s, signed char &amp;res);

void decimal_to_number(const std::string &amp;s, unsigned long long &amp;res);
void decimal_to_number(const std::string &amp;s, unsigned long &amp;res);
void decimal_to_number(const std::string &amp;s, unsigned &amp;res);
void decimal_to_number(const std::string &amp;s, unsigned short &amp;res);
void decimal_to_number(const std::string &amp;s, unsigned char &amp;res);

void decimal_to_number(const char *s, long long &amp;res);
void decimal_to_number(const char *s, long &amp;res);
void decimal_to_number(const char *s, int &amp;res);
void decimal_to_number(const char *s, short &amp;res);
void decimal_to_number(const char *s, signed char &amp;res);

void decimal_to_number(const char *s, unsigned long long &amp;res);
void decimal_to_number(const char *s, unsigned long &amp;res);
void decimal_to_number(const char *s, unsigned &amp;res);
void decimal_to_number(const char *s, unsigned short &amp;res);
void decimal_to_number(const char *s, unsigned char &amp;res);

template&lt;class Integer&gt;
[[nodiscard]] Integer decimal_to_number(const std::string &amp;s);

template&lt;class Integer&gt;
[[nodiscard]] Integer decimal_to_number(const char *s);

#endif
</pre>

<p>The set of functions converts a string, that represents an integer in
decimal notation, to one of the standard C++ integer types. The string can be
a C-string as well as <tt>std::string</tt>.</p>

<p>As opposed to the standard converters, like <tt>std::strtol()</tt>, strict
validation of the format of the whole string and value range is performed. In
particular leading spaces and non-digit characters at the end are not allowed.
For unsigned types minus (<tt>'-'</tt>) is disallowed, which is happily accepted
by <tt>std::strtoul()</tt> by unknown reason.</p>

<p>In case of errors the following exceptions are thrown:</p>
<ul>
<li>
<tt>std::invalid_argument</tt> - the string is not a correct decimal
        integer;</li>
<li>
<tt>std::range_error</tt> - the string is probably correct but the
        result cannot be represented by the used type (integer overflow).</li>
</ul>

<p>There are two kinds of the function prototypes:</p>
<ol>
<li>The result is returned via additional output parameter and</li>
<li>The result is returned using the natural way, the type is specified
        using the template parameter.</li>
</ol>




<h3 id="decimal_to_number_range">
<span class="h3_num">2.24.2</span><tt>decimal_to_number_range()</tt>
</h3>


<pre class="code">
template&lt;class T, class InputIterator&gt;
void decimal_to_number_range(InputIterator begin, InputIterator end, T &amp;res);

template&lt;class T, class InputIterator&gt;
[[nodiscard]] T decimal_to_number_range(InputIterator begin, InputIterator end);
</pre>

<p>The functions are complete analogs of <tt>decimal_to_number()</tt> except
they work with generic ranges of characters instead of strings.</p>




<h3 id="decimal_parser">
<span class="h3_num">2.24.3</span><tt>decimal_parser</tt>
</h3>


<pre class="code">
template&lt;class T&gt;
class decimal_parser
{
    using status = number_parse_status; // for brevity only
public:
    template&lt;class InputIterator&gt;
    [[nodiscard]] status parse(InputIterator begin, InputIterator end);
#if __cpp_lib_string_view // since C++17
    [[nodiscard]] status parse(std::string_view str);
#else // until C++17
    [[nodiscard]] status parse(const std::string &amp;str);
    [[nodiscard]] status parse(const char *str);
#endif
    [[nodiscard]] T result() const;
};
</pre>

<p>A counterpart of <tt>decimal_to_number()</tt> functions but doesn't throw
exceptions, <a href="#number_parse_status"><tt>number_parse_status</tt></a> codes are returned instead by
<tt>parse()</tt>.</p>

<div class="section">Status codes</div>
<div>
<pre class="prototype">number_parse_status::ok</pre>
<blockquote>

<p>Success, the result can be obtained using <tt>result()</tt> function.</p>
</blockquote>
</div>
<div>
<pre class="prototype">number_parse_status::invalid_number</pre>
<blockquote>

<p>The string is not a correct decimal integer.</p>
</blockquote>
</div>
<div>
<pre class="prototype">number_parse_status::unrepresentable</pre>
<blockquote>

<p>The string is probably correct but the result cannot be represented by the
used type (integer overflow).</p>
</blockquote>
</div>


<div class="section">Class members</div>

<div>
<pre class="prototype">template&lt;class InputIterator&gt;
[[nodiscard]] status parse(InputIterator begin, InputIterator end)</pre>
<pre class="prototype">[[nodiscard]] status parse(std::string_view str) <span class="sign">[C++17]</span></pre>
<pre class="prototype">[[nodiscard]] status parse(const std::string &amp;str) <span class="sign">[until C++17]</span></pre>
<pre class="prototype">[[nodiscard]] status parse(const char *str) <span class="sign">[until C++17]</span></pre>
<blockquote>




<p>Converts a range of characters or a string to a number.</p>
<div>
<u>Postcondition</u>: The result of conversion can be obtained by <tt>result()</tt>
call if <tt>number_parse_status::ok</tt> is returned.
</div>
</blockquote>
</div>

<div>
<pre class="prototype">[[nodiscard]] T result() const</pre>
<blockquote>

<p>Returns the result of conversion produced by the the last <tt>parse()</tt>
call.</p>
<div>
<u>Precondition</u>: The last <tt>parse()</tt> call returned
<tt>number_parse_status::ok</tt>.</div>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
template&lt;class T&gt;
bool to_number(const std::string &amp;s, T &amp;result) noexcept
{
    __vic::decimal_parser&lt;T&gt; p;
    if(p.parse(s) != __vic::number_parse_status::ok) return false;
    result = p.result();
    returt true; // 'result' contains the result of conversion
}
</pre>





<h3 id="number_parse_status">
<span class="h3_num">2.24.4</span><tt>number_parse_status</tt>
</h3>


<pre class="code">
enum class number_parse_status
{
    ok,
    invalid_number,
    unrepresentable
};
using number_parse_status_t = number_parse_status; // for C++98
</pre>

<p>Number parsing outcome status codes.</p>

<div class="section">Types</div>

<div>
<pre class="prototype">typename number_parse_status_t</pre>
<blockquote>

<p>Use this as a name of type if your code has to be C++98-compatible.</p>
</blockquote>
</div>








<h2 id="string_buffer.h">
<span class="h2_num">2.25</span><tt>__vic/string_buffer.h</tt>
</h2>


<h3 id="string_buffer">
<span class="h3_num">2.25.1</span><tt>string_buffer</tt>
</h3>


<pre class="code">
class string_buffer : public std::string
{
public:
    string_buffer();
    explicit string_buffer(size_type n);
    string_buffer(const char *str);
    string_buffer(std::string str);
    string_buffer(string_ref sr);
    string_buffer(const std::string &amp;str, size_type off, size_type n = npos);
    string_buffer(const char *char_buf, size_type n);
    string_buffer(const char *begin, const char *end);
    template&lt;class InputIterator&gt;
    string_buffer(InputIterator begin, InputIterator end);

    string_buffer &amp;operator&lt;&lt;(const char *str);
    string_buffer &amp;operator&lt;&lt;(const std::string &amp;str);
    string_buffer &amp;operator&lt;&lt;(string_ref sr);
    string_buffer &amp;operator&lt;&lt;(char ch);

    string_buffer &amp;operator&lt;&lt;(long long n);
    string_buffer &amp;operator&lt;&lt;(long n);
    string_buffer &amp;operator&lt;&lt;(int n);
    string_buffer &amp;operator&lt;&lt;(short n);
    string_buffer &amp;operator&lt;&lt;(signed char ch);

    string_buffer &amp;operator&lt;&lt;(unsigned long long n);
    string_buffer &amp;operator&lt;&lt;(unsigned long n);
    string_buffer &amp;operator&lt;&lt;(unsigned n);
    string_buffer &amp;operator&lt;&lt;(unsigned short n);
    string_buffer &amp;operator&lt;&lt;(unsigned char ch);

    string_buffer &amp;operator&lt;&lt;(long double n);
    string_buffer &amp;operator&lt;&lt;(double n);
    string_buffer &amp;operator&lt;&lt;(float n);

    string_buffer &amp;operator&lt;&lt;(bool flag);
    string_buffer &amp;operator&lt;&lt;(const void *p);

    string_buffer &amp;operator=(string_ref sr);
    string_buffer &amp;operator+=(string_ref sr);
    string_buffer &amp;assign(string_ref sr);
    string_buffer &amp;append(string_ref sr);

    // improved std::string calls
    string_buffer &amp;assign(const std::string &amp;str,
                            size_type off, size_type n = npos);
    string_buffer &amp;append(const std::string &amp;str,
                            size_type off, size_type n = npos);
    string_buffer &amp;insert(size_type pos, const std::string &amp;str,
                            size_type off, size_type n = npos);

    string_buffer &amp;reserve(size_type n);
    string_buffer &amp;clear();

    // missing container interface of std::string
    reference front();
    reference back();
    const_reference front() const;
    const_reference back() const;
    void pop_back();

    operator const char *() const;
};

string_buffer operator+(const string_buffer &amp;s1, const string_buffer &amp;s2);
string_buffer operator+(const string_buffer &amp;s1, const std::string &amp;s2);
string_buffer operator+(const std::string &amp;s1, const string_buffer &amp;s2);

string_buffer operator+(const string_buffer &amp;s1, const char *s2);
string_buffer operator+(const char *s1, const string_buffer &amp;s2);

string_buffer operator+(const string_buffer &amp;s, char ch);
string_buffer operator+(char ch, const string_buffer &amp;s);

template&lt;class T&gt;
string_buffer &amp;operator&lt;&lt;(string_buffer &amp;&amp;s, const T &amp;v); // C++11

using msg = string_buffer;
</pre>

<p>Class is an extended and improved <tt>std::string</tt>. It has following
advantages:</p>

<ol>
<li>Left-associative append operator (<tt>&lt;&lt;</tt>) that allows
constructions like this:
<pre class="code">
str &lt;&lt; "Error message: " &lt;&lt; err_msg &lt;&lt; "\n";
</pre>
</li>
<li>Specific amount of bytes can be reserved using constructor as well as
<tt>reserve()</tt> call. Reserving required amount of space in advance can
improve performance significantly.
<pre class="code">
__vic::string_buffer st(4096);

// is same as
std::string st;
st.reserve(4096);
</pre>
</li>
<li>Operator <tt>&lt;&lt;</tt> accepts all fundamental types: numbers, chars,
pointers, <tt>bool</tt>:
<pre class="code">
for(int i=0; i&lt;10; i++)
    str &lt;&lt; "i = " &lt;&lt; i &lt;&lt; '\n';
</pre>
</li>
<li>All input <tt>nullptr</tt> values of <tt>const char *</tt> are treated as
an empty string. Such values usually cause crash with <tt>std::string</tt>.
<pre class="code">
std::string s1("Str");
const char *p = nullptr;
s1.append(p); // Oops.... Null pointer access!

__vic::string_buffer s2("Str");
s2.append(p); // Ok. s2 == "Str" still
s2 = p; // Ok. s2.empty() == true
</pre>
</li>
<li>Automatic conversion to <tt>const char *</tt> that allows usage of the
object in context requires C-string, without explicit <tt>c_str()</tt> call.
<pre class="code">
std::string fname(...);
FILE *fp = fopen(fname.c_str(), "r");

__vic::string_buffer fname(...);
FILE *fp = fopen(fname, "r");)
</pre>
</li>
<li>Some design irregularities of <tt>std::string</tt> are corrected. For
instance <tt>std::string</tt> is a complete container but operations
<tt>front()</tt> and <tt>back()</tt> are missed in C++98. There is
<tt>push_back()</tt> but no <tt>pop_back()</tt>.</li>
</ol>

<p>In spite of all these improvements, the interface of this class is completely
backward compatible with <tt>std::string</tt>. Objects can be passed in contexts
that require <tt>std::string</tt>. Class has no additional data-members.</p>

<p>Using of inserter (operator <tt>&lt;&lt;</tt>) provides the easiest way to
convert numbers to decimal string representation. Using of
<tt>std::ostringstream</tt> for this purposes is more functional (you can
specify radix, formatting, etc) but too tedious and not efficient in most
cases.</p>

<p>Additionally this type has a short synonym <tt>msg</tt>. It is very
convenient for usage when one needs to construct a complex message with a
single expression, without introducing unnecessary variables:</p>

<pre class="code">
oresult res = db_open(db_name);
if(res != 0) throw __vic::exception(
    __vic::msg(64) &lt;&lt; "Cannot open DB " &lt;&lt; db_name &lt;&lt; ". res = " &lt;&lt; res
);
</pre>

<p>As you can see, the maximum size of the message expected is specified in the
constructor for optimization purposes.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">string_buffer()</pre>
<blockquote>

<p>Create an empty string.</p>
<div>
<u>Postcondition</u>: <tt>empty() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">explicit string_buffer(size_type n)</pre>
<blockquote>

<p>Calls <tt>reserve(n)</tt>.</p>
<div>
<u>Postcondition</u>: <tt>capacity() &gt;= n</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer(const char *str)</pre>
<pre class="prototype">string_buffer(std::string str)</pre>
<blockquote>


<p>Creates the copy of <tt>str</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer(const std::string &amp;str, size_type off, size_type n = npos)</pre>
<blockquote>

<p>Creates the copy of <tt>str</tt> substring.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer(const char *char_buf, size_type n)</pre>
<blockquote>

<p>Creates string using buffer and its length.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer(string_ref sr)</pre>
<pre class="prototype">string_buffer(const char *begin, const char *end)</pre>
<pre class="prototype">template&lt;class InputIterator&gt;
string_buffer(InputIterator begin, InputIterator end)</pre>
<blockquote>



<p>Creates string from the chars range.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(const char *str)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(const std::string &amp;str)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(string_ref sr)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(char ch)</pre>
<blockquote>




<p>Calls <tt>std::string::append()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(long long n)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(long n)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(int n)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(short n)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(signed char ch)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(unsigned long long n)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(unsigned long n)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(unsigned n)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(unsigned short n)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(unsigned char ch)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(long double n)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(double n)</pre>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(float n)</pre>
<blockquote>













<p>Appends decimal representaion of <tt>n</tt> to the string.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(const void *p)</pre>
<blockquote>

<p>Appends pointers value in <tt>%p</tt> format of <tt>std::printf</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer &amp;operator&lt;&lt;(bool flag)</pre>
<blockquote>

<p>Appends <tt>1</tt> (for <tt>true</tt>) or <tt>0</tt> (for <tt>false</tt>)
to the string.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer &amp;operator=(string_ref sr)</pre>
<pre class="prototype">string_buffer &amp;operator+=(string_ref sr)</pre>
<pre class="prototype">string_buffer &amp;assign(string_ref sr)</pre>
<pre class="prototype">string_buffer &amp;append(string_ref sr)</pre>
<blockquote>




<p>Operations for <tt>string_ref</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer &amp;reserve(size_type n)</pre>
<pre class="prototype">string_buffer &amp;clear()</pre>
<blockquote>


<p>Calls the corresponding <tt>std::string</tt> operation and additionally
returns the reference to itself, so the call can be used in complex
expressions.</p>
</blockquote>
</div>

<div>
<pre class="prototype">reference front()</pre>
<pre class="prototype">reference back()</pre>
<pre class="prototype">const_reference front() const</pre>
<pre class="prototype">const_reference back() const</pre>
<pre class="prototype">void pop_back()</pre>
<blockquote>





<p>Missed container operations in the <tt>std::string</tt> interface in
C++98.</p>
</blockquote>
</div>

<div>
<pre class="prototype">operator const char *() const</pre>
<blockquote>

<p>Calls <tt>std::string::c_str()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">string_buffer operator+(const string_buffer &amp;s1, const string_buffer &amp;s2)</pre>
<pre class="prototype">string_buffer operator+(const string_buffer &amp;s1, const std::string &amp;s2)</pre>
<pre class="prototype">string_buffer operator+(const std::string &amp;s1, const string_buffer &amp;s2)</pre>
<pre class="prototype">string_buffer operator+(const string_buffer &amp;s1, const char *s2)</pre>
<pre class="prototype">string_buffer operator+(const char *s1, const string_buffer &amp;s2)</pre>
<pre class="prototype">string_buffer operator+(const string_buffer &amp;s, char ch)</pre>
<pre class="prototype">string_buffer operator+(char ch, const string_buffer &amp;s)</pre>
<blockquote>







<p>Concatenation of strings and characters.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class T&gt;
string_buffer &amp;operator&lt;&lt;(string_buffer &amp;&amp;s, const T &amp;v) <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Calls <tt>operator&lt;&lt;(string_buffer &amp;s, const T &amp;v)</tt>.</p>
</blockquote>
</div>







<h2 id="string_ref.h">
<span class="h2_num">2.26</span><tt>__vic/string_ref.h</tt>
</h2>


<h3 id="string_ref">
<span class="h3_num">2.26.1</span><tt>string_ref</tt>
</h3>


<pre class="code">
template&lt;class charT&gt;
class basic_string_ref
{
public:
    using value_type = charT;
    using iterator = const value_type *;
    using const_iterator = iterator;

    // Constructors
    basic_string_ref();
    basic_string_ref(const charT *str);
    basic_string_ref(const charT *chars, size_t n);
    basic_string_ref(const charT *begin, const charT *end);
    template&lt;class Traits, class Alloc&gt;
    explicit basic_string_ref(
        const std::basic_string&lt;charT,Traits,Alloc&gt; &amp;str);
    basic_string_ref(
        typename std::basic_string&lt;charT&gt;::const_iterator begin,
        typename std::basic_string&lt;charT&gt;::const_iterator end);
    // BEGIN C++11
    basic_string_ref(std::initializer_list&lt;charT&gt; );
    // END C++11

#if __cpp_lib_string_view // since C++17
    template&lt;class Traits&gt;
    basic_string_ref(std::basic_string_view&lt;charT,Traits&gt; s);
    operator std::basic_string_view&lt;charT&gt;() const;
#endif

    // Accessors
    iterator begin() const;
    iterator end() const;
    iterator cbegin() const;
    iterator cend() const;

    charT front() const;
    charT back() const;
    charT operator[](size_t i) const;
    const charT *data() const;

    bool empty() const;
    size_t size() const;
    size_t length() const;

    int compare(basic_string_ref s) const;

    // Converters
    std::basic_string&lt;charT&gt; str() const;
    template&lt;class Traits&gt;
    std::basic_string&lt;charT,Traits&gt; str() const;
    template&lt;class Traits, class Alloc&gt;
    std::basic_string&lt;charT,Traits,Alloc&gt; str(const Alloc &amp;a = Alloc())const;

    operator std::basic_string&lt;charT&gt;() const;
};

using string_ref = basic_string_ref&lt;char&gt; ;

template&lt;class charT&gt;
bool operator==(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2);
template&lt;class charT&gt;
bool operator!=(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2);
template&lt;class charT&gt;
bool operator&lt;(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2);
template&lt;class charT&gt;
bool operator&gt;(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2);
template&lt;class charT&gt;
bool operator&lt;=(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2);
template&lt;class charT&gt;
bool operator&gt;=(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2);

#ifdef __VIC_DEFINE_OSTREAM_INSERTERS
template&lt;class charT, class Traits&gt;
std::basic_ostream&lt;charT,Traits&gt; &amp;operator&lt;&lt;(
    std::basic_ostream&lt;charT,Traits&gt; &amp;os, const basic_string_ref&lt;charT&gt; &amp;sr);
#endif
</pre>

<p>The class represents a reference to the read-only continuous range of
characters. When used as a return value, it is significantly more lightweight
than <tt>std::string</tt>, because no string copy or memory allocation
performed. But, when <tt>std::string</tt> is required, automatic conversion
happens. Let's consider the example:</p>

<pre class="code">
class C
{
    std::string v;
public:
    std::string       get_v_1() const { return v; }
    __vic::string_ref get_v_2() const { return v; }
};
</pre>

<p>As you can see, class contains one string field. Two read-only
access-functions are defined. The first as usual returns <tt>std::string</tt>,
the second - <tt>string_ref</tt>. When the first is used, temporay string is
created every time. When the second is used, just reference is returned.</p>

<p>Another use case - input read-only string argument. The class is a drop-in
replacement for <tt>const std::string &amp;</tt>. In most cases, it can also
be used instead of <tt>const char *</tt>. The overhead in this case is an
additional scan of the string to find the NULL-terminator, which is nothing in
cases when we need the string end or length anyway. Let's consider 3 sets of
overloaded functions:</p>

<pre class="code">
void f1(const std::string &amp; );

void f2(const std::string &amp; );
void f2(const char * );

void f3(string_ref );
</pre>

<p>Each of them can be used as</p>

<pre class="code">
fx("Nul-terminated string");
</pre>

<p>as well as</p>

<pre class="code">
fx(std::string("std::string"));
</pre>

<p>But with <tt>f1()</tt> we will have redundant string copying in the first
case, just to read the value. With <tt>f2()</tt> several overloads are
required. And while it isn't a big issue when function has single argument,
with two or more string arguments it quickly becomes very tedious. The last
alternative - <tt>f3()</tt> - is at the same time as short and universal as
<tt>f1()</tt> and "friendlier" to the string literals and strings from the
C-world - they are not copied to the heap and not converted to
<tt>std::string</tt>.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">basic_string_ref()</pre>
<blockquote>

<div>
<u>Postcondition</u>: <tt>empty() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">basic_string_ref(const charT *str)</pre>
<pre class="prototype">template&lt;class Traits, class Alloc&gt;
basic_string_ref(const std::basic_string&lt;charT,Traits,Alloc&gt; &amp;str)</pre>
<blockquote>


<p>Creates reference to <tt>str</tt>.</p>
<div>
<u>Postcondition</u>: <tt>*this == str</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">basic_string_ref(const charT *chars, size_t n)</pre>
<pre class="prototype">basic_string_ref(const charT *begin, const charT *end)</pre>
<pre class="prototype">basic_string_ref(const charT *chars, size_t n)</pre>
<pre class="prototype">basic_string_ref(
    typename std::basic_string&lt;charT&gt;::const_iterator begin,
    typename std::basic_string&lt;charT&gt;::const_iterator end)</pre>
<pre class="prototype">basic_string_ref(std::initializer_list&lt;charT&gt; ) <span class="sign">[C++11]</span></pre>
<blockquote>





<p>Create reference to the range of the characters.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class Traits&gt;
basic_string_ref(std::basic_string_view&lt;charT,Traits&gt; s) <span class="sign">[C++17]</span></pre>
<pre class="prototype">operator std::basic_string_view&lt;charT&gt;() const <span class="sign">[C++17]</span></pre>
<blockquote>


<p>Converters from/to <tt>std::basic_string_view</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">iterator begin() const</pre>
<pre class="prototype">iterator cbegin() const</pre>
<pre class="prototype">const charT *data() const</pre>
<blockquote>



<p>Begin of the range of the characters.</p>
</blockquote>
</div>

<div>
<pre class="prototype">iterator end() const</pre>
<pre class="prototype">iterator cend() const</pre>
<blockquote>


<p>End of the range of the characters.</p>
</blockquote>
</div>

<div>
<pre class="prototype">charT front() const</pre>
<pre class="prototype">charT back() const</pre>
<blockquote>


<p>The first and the last character of the string correspondingly.</p>
<div>
<u>Precondition</u>: <tt>!empty()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">charT operator[](size_t i) const</pre>
<blockquote>

<p><tt>i</tt>-th character of the string.</p>
<div>
<u>Precondition</u>: <tt>i &lt; length()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool empty() const</pre>
<blockquote>

<p>Returns <tt>begin() == end()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">size_t size() const</pre>
<pre class="prototype">size_t length() const</pre>
<blockquote>


<p>Size of the string.</p>
</blockquote>
</div>

<div>
<pre class="prototype">int compare(basic_string_ref s) const</pre>
<blockquote>

<p>Compares the string with <tt>s</tt>. Returning values are the same as for
<tt>std::string::compare()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">std::basic_string&lt;charT&gt; str() const</pre>
<pre class="prototype">template&lt;class Traits&gt;
std::basic_string&lt;charT,Traits&gt; str() const</pre>
<pre class="prototype">template&lt;class Traits, class Alloc&gt;
std::basic_string&lt;charT,Traits,Alloc&gt; str(const Alloc &amp;a = Alloc()) const</pre>
<blockquote>



<p>Explicit converter to <tt>std::basic_string</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">operator std::basic_string&lt;charT&gt;() const</pre>
<blockquote>

<p>Implicit converter to <tt>std::basic_string</tt>.</p>
</blockquote>
</div>



<div class="section">Free functions</div>

<div>
<pre class="prototype">template&lt;class charT&gt;
bool operator==(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2)</pre>
<pre class="prototype">template&lt;class charT&gt;
bool operator!=(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2)</pre>
<pre class="prototype">template&lt;class charT&gt;
bool operator&lt;(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2)</pre>
<pre class="prototype">template&lt;class charT&gt;
bool operator&gt;(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2)</pre>
<pre class="prototype">template&lt;class charT&gt;
bool operator&lt;=(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2)</pre>
<pre class="prototype">template&lt;class charT&gt;
bool operator&gt;=(basic_string_ref&lt;charT&gt; s1, basic_string_ref&lt;charT&gt; s2)</pre>
<blockquote>






<p>Full set of the comparison operators.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class charT, class Traits&gt;
std::basic_ostream&lt;charT,Traits&gt; &amp;operator&lt;&lt;(
    std::basic_ostream&lt;charT,Traits&gt; &amp;os, const basic_string_ref&lt;charT&gt; &amp;sr)</pre>
<blockquote>

<p>Inserter to an output stream. Defined (and <tt>&lt;ostream&gt;</tt> is included)
only if <tt>__VIC_DEFINE_OSTREAM_INSERTERS</tt> macro was defined before the
header inclusion.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
C c; // see the class description above
__vic::string_ref s = c. get_v_2();

// print the string using different ways
for(__vic::string_ref::iterator it = s.begin(); it != s.end(); ++it)
    std::cout &lt;&lt; *it;

// C++11
for(auto ch : s) std::cout &lt;&lt; ch;

std::copy(s.begin(), s.end(), std::ostream_iterator&lt;char&gt;(std::cout));

std::cout &lt;&lt; s;

// automatic conversion to std::string
std::string ss = s;
</pre>






<h2 id="string_utils.h">
<span class="h2_num">2.27</span><tt>__vic/string_utils.h</tt>
</h2>


<p>Miscellaneous strings-related utilities.</p>


<h3 id="trim">
<span class="h3_num">2.27.1</span><tt>trim</tt> functions</h3>


<pre class="code">
char *trim(char *str);
char *trim_front(char *str);
char *trim_back(char *str);
char *trim(char *str, char ch);
char *trim_front(char *str, char ch);
char *trim_back(char *str, char ch);
char *trim(char *str, const char *set);
char *trim_front(char *str, const char *set);
char *trim_back(char *str, const char *set);

std::string &amp;trim(std::string &amp;str);
std::string &amp;trim_front(std::string &amp;str);
std::string &amp;trim_back(std::string &amp;str);
std::string &amp;trim(std::string &amp;str, char ch);
std::string &amp;trim_front(std::string &amp;str, char ch);
std::string &amp;trim_back(std::string &amp;str, char ch);
std::string &amp;trim(std::string &amp;str, const char *set);
std::string &amp;trim_front(std::string &amp;str, const char *set);
std::string &amp;trim_back(std::string &amp;str, const char *set);

#if __cpp_lib_string_view // C++17
std::string_view trimmed(std::string_view str);
std::string_view trimmed_front(std::string_view str);
std::string_view trimmed_back(std::string_view str);
std::string_view trimmed(std::string_view str, char ch);
std::string_view trimmed_front(std::string_view str, char ch);
std::string_view trimmed_back(std::string_view str, char ch);
std::string_view trimmed(std::string_view str, const char *set);
std::string_view trimmed_front(std::string_view str, const char *set);
std::string_view trimmed_back(std::string_view str, const char *set);
#else // until C++17
std::string trimmed(const std::string &amp;str);
std::string trimmed_left(const std::string &amp;str);
std::string trimmed_right(const std::string &amp;str);
std::string trimmed(const std::string &amp;str, char ch);
std::string trimmed_left(const std::string &amp;str, char ch);
std::string trimmed_right(const std::string &amp;str, char ch);
std::string trimmed(const std::string &amp;str, const char *set);
std::string trimmed_left(const std::string &amp;str, const char *set);
std::string trimmed_right(const std::string &amp;str, const char *set);
#endif
</pre>

<p>The set of functions stripping unwanted characters from the string edges.
Characters to strip can be specified. One can specify single character
<tt>ch</tt> as well as the set of characters <tt>set</tt>. If no characters
is specified, all ASCII-whitespaces are implied. Following naming rules for
the functions are used:</p>
<ul>
<li>
<tt>trim</tt> - strips from both edges,</li>
<li>
<tt>trim_front</tt> - strips from the beginning,</li>
<li>
<tt>trim_back</tt> - strips from the end.</li>
</ul>

<p>Functions <tt>trim</tt> modify the string in-situ and return the pointer or
reference to it. If the original value should be preserved, <tt>trimmed</tt>
functions should be used.</p>
<ul><li>
<tt>trimmed</tt> - return stripped copy of the string, argument
        itself is not modified.</li></ul>

<p>The implementation is optimized for common case when the string does not have
anything to trim. In such cases no modifications of the argument are performed,
the function returns immediately after the checks are completed, and the call
is maximally cheap.</p>

<p>All <tt>nullptr</tt> values are treated as an empty string.</p>

<div class="section">Example</div>
<pre class="code">
char st1[] = "\t value    \n";

// CHOICE:
__vic::trim(st1);       // result: "value"
__vic::trim_front(st1); // result: "value    \n"
__vic::trim_back(st1);  // result: "\t value"

std::string st2("...value123");

// CHOICE:
// trim dot chars
__vic::trim_front(st1, '.');        // result: "value123"
// trim all digits
__vic::trim_back(st1, "123456789"); // result: "...value"
</pre>





<h3 id="sift">
<span class="h3_num">2.27.2</span><tt>sift()</tt>
</h3>


<pre class="code">
char *sift(char *str, const char *trash_chars);
std::string &amp;sift(std::string &amp;str, const char *trash_chars);
</pre>

<p>Removes all characters from the set from the string. All <tt>nullptr</tt>
values are treated as an empty string.</p>

<div class="section">Example</div>
<pre class="code">
char st[] = "..ab.c..d.e.";
__vic::sift(st, ".");
assert(std::strcmp(st, "abcde") == 0);
</pre>





<h3 id="sift_if">
<span class="h3_num">2.27.3</span><tt>sift_if()</tt>
</h3>


<pre class="code">
template&lt;class Pred&gt;
char *sift(char *str, Pred pred);
template&lt;class Pred&gt;
std::string &amp;sift(std::string &amp;str, Pred pred);
</pre>

<p>Removes all characters satify the predicate <tt>pred</tt>. All
<tt>nullptr</tt> values are treated as an empty string.</p>




<h3 id="pad_front">
<span class="h3_num">2.27.4</span><tt>pad_front()</tt>
</h3>


<pre class="code">
std::string &amp;pad_front(std::string &amp;str, size_t size, char pad_ch = ' ');
char *pad_front(char *str, size_t size, char pad_ch = ' ');
</pre>

<p>Complements the string up to length <tt>size</tt> by adding the required
number of <tt>pad_ch</tt> chars to the beginning. Nothing happens if
<tt>str</tt> length is equal or greather than <tt>size</tt> or the pointer is
null. Returns <tt>str</tt>.</p>




<h3 id="pad_back">
<span class="h3_num">2.27.5</span><tt>pad_back()</tt>
</h3>


<pre class="code">
std::string &amp;pad_back(std::string &amp;str, size_t size, char pad_ch = ' ');
char *pad_back(char *str, size_t size, char pad_ch = ' ');
</pre>

<p>Complements the string up to length <tt>size</tt> by adding the required
number of <tt>pad_ch</tt> chars to the end. Nothing happens if
<tt>str</tt> length is equal or greather than <tt>size</tt> or the pointer is
null. Returns
<tt>str</tt>.</p>




<h3 id="starts_with">
<span class="h3_num">2.27.6</span><tt>starts_with()</tt>
</h3>


<pre class="code">
bool starts_with(const char *s, char pref);
bool starts_with(const char *s, const char *pref);
bool starts_with(const char *s, const char *pref, size_t pref_len);

#if __cpp_lib_string_view // C++17
bool starts_with(std::string_view s, char pref);
bool starts_with(std::string_view s, std::string_view pref);
bool starts_with(std::string_view s, const char *pref);
#else // until C++17
bool starts_with(const std::string &amp;s, char pref);
bool starts_with(const std::string &amp;s, const char *pref);
bool starts_with(const std::string &amp;s, const std::string &amp;pref);
bool starts_with(const std::string &amp;s, const char *pref, size_t pref_len);
#endif

bool starts_with(const char *s, size_t s_len, char pref);
bool starts_with(const char *s, size_t s_len, const char *pref);
bool starts_with(const char *s, size_t s_len, const char *pref, size_t pref_len);
</pre>

<p>Returns <tt>true</tt> if string <tt>s</tt> starts with the specified
prefix.</p>




<h3 id="ends_with">
<span class="h3_num">2.27.7</span><tt>ends_with()</tt>
</h3>


<pre class="code">
#if __cpp_lib_string_view // C++17
bool ends_with(std::string_view s, char suff);
bool ends_with(std::string_view s, std::string_view suff);
#else // until C++17
bool ends_with(const char *s, char suff);
bool ends_with(const char *s, const char *suff);
bool ends_with(const char *s, const char *suff, size_t suff_len);
bool ends_with(const char *s, size_t s_len, const char *suff);

bool ends_with(const std::string &amp;s, char suff);
bool ends_with(const std::string &amp;s, const char *suff);
bool ends_with(const std::string &amp;s, const std::string &amp;suff);
bool ends_with(const std::string &amp;s, const char *suff, size_t suff_len);
#endif

bool ends_with(const char *s, size_t s_len, char suff);
bool ends_with(const char *s, size_t s_len, const char *suff, size_t suff_len);
</pre>

<p>Returns <tt>true</tt> if string <tt>s</tt> ends with the specified
suffix.</p>






<h2 id="tchar.h">
<span class="h2_num">2.28</span><tt>__vic/tchar.h</tt>
</h2>


<p>Generic functions to manipulate C-strings regardless of the underlying
char-type, like <tt>std::char_traits&lt;&gt;</tt>. All the functions are located
within <tt>__vic::tchar</tt> namespace.</p>

<p>Most of the functions are just generic redirectors to calls like
<tt>strcpy</tt>, <tt>wcscpy</tt>, et al. Searching functions have more
intelligible names that ones in the C-library and unified parameters: they
always take pointers and never indices. Also the set of the functions is
complemented with "logically symmetrical" ones missed in the standard library.
Searching functions return <tt>nullptr</tt> in case of failure.</p>

<div class="section">Example</div>
<pre class="code">
template&lt;class charT&gt;
charT *generic_dup(const charT *st)
{
    namespace tchar = __vic::tchar;

    charT *st_copy = new charT[tchar::length(st) + 1];
    tchar::copy(st_copy, st);
    return st_copy;
}
</pre>



<h3 id="tchar--length">
<span class="h3_num">2.28.1</span><tt>tchar::length()</tt>
</h3>


<pre class="code">
template&lt;class charT&gt;
size_t tchar::length(const charT *str);
</pre>

<p>String length in elements. Generic <tt>strlen</tt> / <tt>wcslen</tt>.</p>




<h3 id="tchar--empty">
<span class="h3_num">2.28.2</span><tt>tchar::empty()</tt>
</h3>


<pre class="code">
template&lt;class charT&gt;
bool tchar::empty(const charT *str);
</pre>

<p>Checks if <tt>str</tt> is <tt>nullptr</tt> or has no characters.</p>




<h3 id="tchar--end">
<span class="h3_num">2.28.3</span><tt>tchar::end()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT&gt;
const charT *end(const charT *str);

template&lt;class charT&gt;
charT *end(charT *str);

}
</pre>

<p>Pointer to the NULL-terminator. Generic <tt>strchr(str, '\0')</tt> /
<tt>wcschr(str, L'\0')</tt>.</p>

<div>
<u><b>Note</b></u>: Some buggy implementations of <tt>std::strchr()</tt> like MinGW return
non-const <tt>char *</tt> even if the argument is <tt>const char *</tt> so
this function can be used as a workaround in the similar use case.</div>




<h3 id="tchar--compare">
<span class="h3_num">2.28.4</span><tt>tchar::compare()</tt>
</h3>


<pre class="code">
template&lt;class charT&gt;
int tchar::compare(const charT *str1, const charT *str2);
</pre>

<p>Compare two strings. Generic <tt>strcmp</tt> / <tt>wcscmp</tt>.</p>




<h3 id="tchar--equal">
<span class="h3_num">2.28.5</span><tt>tchar::equal()</tt>
</h3>


<pre class="code">
template&lt;class charT&gt;
bool tchar::equal(const charT *str1, const charT *str2);
</pre>

<p>Checks if two strings are equal.</p>

<div>
<u>Precondition</u>: <tt>str1 != nullptr &amp;&amp; str2 != nullptr</tt>
</div>




<h3 id="tchar--copy">
<span class="h3_num">2.28.6</span><tt>tchar::copy()</tt>
</h3>


<pre class="code">
template&lt;class charT&gt;
charT *tchar::copy(charT *dest, const charT *src);
</pre>

<p>Copy string. Generic <tt>strcpy</tt> / <tt>wcscpy</tt>.</p>




<h3 id="tchar--move">
<span class="h3_num">2.28.7</span><tt>tchar::move()</tt>
</h3>


<pre class="code">
template&lt;class charT&gt;
charT *tchar::move(charT *dest, const charT *src);
</pre>

<p>Move the string in memory (<tt>memmove</tt>).</p>




<h3 id="tchar--concat">
<span class="h3_num">2.28.8</span><tt>tchar::concat()</tt>
</h3>


<pre class="code">
template&lt;class charT&gt;
charT *tchar::concat(charT *dest, const charT *src);
</pre>

<p>Concatenate two strings. Generic <tt>strcat</tt> / <tt>wcscat</tt>.</p>




<h3 id="tchar--find">
<span class="h3_num">2.28.9</span><tt>tchar::find()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT&gt;
const charT *find(const charT *str, charT ch);

template&lt;class charT&gt;
charT *find(charT *str, charT ch);

template&lt;class charT&gt;
const charT *find(const charT *str, const charT *sub);

template&lt;class charT&gt;
charT *find(charT *str, const charT *sub);

}
</pre>

<p>Find the first occurrence of the character or substring. Generic
<tt>strchr</tt> / <tt>wcschr</tt> / <tt>strstr</tt> / <tt>wcsstr</tt>.</p>




<h3 id="tchar--rfind">
<span class="h3_num">2.28.10</span><tt>tchar::rfind()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT&gt;
const charT *rfind(const charT *str, charT ch);

template&lt;class charT&gt;
charT *rfind(charT *str, charT ch);

}
</pre>

<p>Find the last occurrence of the character. Generic <tt>strrchr</tt> /
<tt>wcsrchr</tt>.</p>




<h3 id="tchar--find_if">
<span class="h3_num">2.28.11</span><tt>tchar::find_if()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT, class Pred&gt;
const charT *find_if(const charT *str, Pred pred);

template&lt;class charT, class Pred&gt;
charT *find_if(charT *str, Pred pred);

}
</pre>

<p>Find the first occurrence of the character that satisfies the specified
predicate.</p>




<h3 id="tchar--find_if_not">
<span class="h3_num">2.28.12</span><tt>tchar::find_if_not()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT, class Pred&gt;
const charT *find_if_not(const charT *str, Pred pred);

template&lt;class charT, class Pred&gt;
charT *find_if_not(charT *str, Pred pred);

}
</pre>

<p>Find the first occurrence of the character that doesn't satisfy the
specified predicate.</p>




<h3 id="tchar--rfind_if">
<span class="h3_num">2.28.13</span><tt>tchar::rfind_if()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT, class Pred&gt;
const charT *rfind_if(const charT *str, Pred pred);

template&lt;class charT, class Pred&gt;
charT *rfind_if(charT *str, Pred pred);

}
</pre>

<p>Find the last occurrence of the character that satisfies the specified
predicate.</p>




<h3 id="tchar--rfind_if_not">
<span class="h3_num">2.28.14</span><tt>tchar::rfind_if_not()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT, class Pred&gt;
const charT *rfind_if_not(const charT *str, Pred pred);

template&lt;class charT, class Pred&gt;
charT *rfind_if_not(charT *str, Pred pred);

}
</pre>

<p>Find the last occurrence of the character that doesn't satisfy the specified
predicate.</p>




<h3 id="tchar--find_first_of">
<span class="h3_num">2.28.15</span><tt>tchar::find_first_of()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT&gt;
const charT *find_first_of(const charT *str, const charT *set);

template&lt;class charT&gt;
charT *find_first_of(charT *str, const charT *set);

}
</pre>

<p>Find the first occurrence of the character from the specified set. Generic
<tt>strpbrk</tt> / <tt>wcspbrk</tt>.</p>




<h3 id="tchar--find_first_not_of">
<span class="h3_num">2.28.16</span><tt>tchar::find_first_not_of()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT&gt;
const charT *find_first_not_of(const charT *str, const charT *set);

template&lt;class charT&gt;
charT *find_first_not_of(charT *str, const charT *set);

}
</pre>

<p>Find the first occurrence of the character absent in the specified set.
Generic <tt>strspn</tt> / <tt>wcsspn</tt>.</p>




<h3 id="tchar--find_last_of">
<span class="h3_num">2.28.17</span><tt>tchar::find_last_of()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT&gt;
const charT *find_last_of(const charT *str, const charT *set);

template&lt;class charT&gt;
charT *find_last_of(charT *str, const charT *set);

}
</pre>

<p>Find the last occurrence of the character from the specified set.</p>




<h3 id="tchar--find_last_not_of">
<span class="h3_num">2.28.18</span><tt>tchar::find_last_not_of()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT&gt;
const charT *find_last_not_of(const charT *str, const charT *set);

template&lt;class charT&gt;
charT *find_last_not_of(charT *str, const charT *set);

}
</pre>

<p>Find the last occurrence of the character absent in the specified set.</p>




<h3 id="tchar--skip">
<span class="h3_num">2.28.19</span><tt>tchar::skip()</tt>
</h3>


<pre class="code">
namespace tchar {

template&lt;class charT&gt;
const charT *skip(const charT *str, charT ch);

template&lt;class charT&gt;
charT *skip(charT *str, charT ch);

}
</pre>

<p>Skip all occurrences of the specified character and return the pointer.
Pointer to NULL-terminator is returned if no other characters is presented.</p>






<h2 id="thread.h">
<span class="h2_num">2.29</span><tt>__vic/thread.h</tt>
</h2>


<p>Threads support.</p>


<h3 id="thread">
<span class="h3_num">2.29.1</span><tt>thread</tt>
</h3>


<pre class="code">
class thread : private non_copyable
{
public:
    class id;
    using native_handle_type = <span class="nonterminal">&lt;implementation-defined&gt;</span>;

    thread();
    virtual ~thread();

    // BEGIN C++11
    thread(thread &amp;&amp;o) noexcept;
    thread &amp;operator=(thread &amp;&amp;o) noexcept;
    // END C++11

    void start();
    void cancel();
    void join();

    bool alive() const;
    bool joinable() const;

    id get_id() const;
    native_handle_type handle() const;
protected:
    virtual void worker() = 0;
};
</pre>

<p>Abstract base class for thread objects. Implements "Active object" pattern.
Inherit it and define <tt>worker()</tt> function which content will be executed
in the new thread after <tt>start()</tt> call. Then at some point in your
program you must call <tt>join()</tt> to free OS resources associated with the
spawned thread.</p>

<div>
<u><b>Note</b></u>: The object must always outlive the associated OS thread. Your program
will be terminated by <tt>std::terminate()</tt> call if this usage contract
is violated.</div>

<div class="section">Class members</div>

<div>
<pre class="prototype">thread()</pre>
<blockquote>

<div>
<u>Postcondition</u>: <tt>joinable() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">~thread()</pre>
<blockquote>

<p>Calls <tt>std::terminate()</tt> if precondition is not satisfied.</p>
<div>
<u>Precondition</u>: <tt>joinable() == false || alive() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">thread(thread &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Move constructor for C++11 mode.</p>
</blockquote>
</div>

<div>
<pre class="prototype">thread &amp;operator=(thread &amp;&amp;o) noexcept <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Move assignment for C++11 mode. Calls <tt>std::terminate()</tt> if
precondition is not satisfied.</p>
<div>
<u>Precondition</u>: <tt>joinable() == false || alive() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void start()</pre>
<blockquote>

<p>Spawns new thread and calls <tt>worker()</tt> there.</p>
<div>
<u>Precondition</u>: <tt>joinable() == false</tt>
</div>
<div>
<u>Postcondition</u>: <tt>joinable() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void cancel()</pre>
<blockquote>

<p>Cancels the thread execution.</p>
<div>
<u>Precondition</u>: <tt>joinable() == true</tt>
</div>
<div>
<u>Postcondition</u>: <tt>joinable() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void join()</pre>
<blockquote>

<p>Waits for the thread termination if running and makes
<tt>joinable() == false</tt>.</p>
<div>
<u>Precondition</u>: <tt>joinable() == true</tt>
</div>
<div>
<u>Postcondition</u>: <tt>joinable() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool alive() const</pre>
<blockquote>

<p>Returns <tt>true</tt> if the thread haven't been terminated yet
(<tt>worker()</tt> function haven't returned).</p>
<div>
<u>Precondition</u>: <tt>joinable() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool joinable() const</pre>
<blockquote>

<p>Returns <tt>true</tt> if the object has a corresponding OS object
(thread) created by the <tt>start()</tt> call and not yet destroyed by
<tt>join()</tt> call.</p>
</blockquote>
</div>

<div>
<pre class="prototype">id get_id() const</pre>
<blockquote>

<p>Returns ID of the thread.</p>
</blockquote>
</div>

<div>
<pre class="prototype">native_handle_type handle() const</pre>
<blockquote>

<p>Returns a native OS-specific handle of the thread.</p>
</blockquote>
</div>






<h3 id="thread--id">
<span class="h3_num">2.29.2</span><tt>thread::id</tt>
</h3>


<pre class="code">
class thread::id
{
public:
    id();
    explicit operator bool() const;
    native_handle_type handle() const;
};
bool operator==(thread::id a, thread::id b);
bool operator!=(thread::id a, thread::id b);
</pre>

<p>Unique thread ID. It can hold a value associated with some thread or the
special distinct value not associated with any thread.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">id()</pre>
<blockquote>

<p>Creates the special value not associated with any thread.</p>
<div>
<u>Postcondition</u>: <tt>bool(*this) == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">explicit operator bool() const</pre>
<blockquote>

<p>Returns <tt>true</tt> if the object holds ID of some thread.</p>
</blockquote>
</div>

<div>
<pre class="prototype">native_handle_type handle() const</pre>
<blockquote>

<p>Returns a native OS-specific handle of the thread.</p>
<div>
<u>Precondition</u>: <tt>bool(*this) == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool operator==(thread::id a, thread::id b)</pre>
<pre class="prototype">bool operator!=(thread::id a, thread::id b)</pre>
<blockquote>


<p>Check if <tt>a</tt> and <tt>b</tt> represent the same thread.</p>
<div>
<u>Invariant</u>: <tt>id() == id()</tt>
</div>
</blockquote>
</div>






<h3 id="this_thread">
<span class="h3_num">2.29.3</span><tt>this_thread</tt>
</h3>


<pre class="code">
namespace this_thread
{
    thread::id get_id();
    void sleep_ms(unsigned msec);
}
</pre>

<p>Set of the functions to control the current (calling) thread.</p>

<div>
<pre class="prototype">thread::id get_id()</pre>
<blockquote>

<p>Returns ID of the calling thread.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void sleep_ms(unsigned msec)</pre>
<blockquote>

<p>Suspends the execution of the calling thread until the time-out interval
specified in milliseconds elapses.</p>
</blockquote>
</div>






<h2 id="throw_errno.h">
<span class="h2_num">2.30</span><tt>__vic/throw_errno.h</tt>
</h2>


<h3 id="throw_errno">
<span class="h3_num">2.30.1</span><tt>throw_errno()</tt>
</h3>


<pre class="code">
[[noreturn]] void throw_errno(const char *prompt);
[[noreturn]] void throw_errno(const char *prompt, int err_no);
</pre>

<p>Throw an exception with global <tt>errno</tt> value or given
<tt>err_no</tt> correspondingly. Default exception type is
<a href="#libc_error"><tt>libc_error</tt></a> at the moment but can be changed at link time
by overriding this functions. For example <tt>std::system_error</tt> can be
used. Just create cpp-file with the following content in your project:</p>

<pre class="code">
#include&lt;__vic/throw_errno.h&gt;
#include&lt;system_error&gt;

//----------------------------------------------------------------------------
// Override library functions to throw std::system_error
//----------------------------------------------------------------------------
void __vic::throw_errno(const char *prompt, int err_no)
{
    throw std::system_error(err_no, std::system_category(), prompt);
}
//----------------------------------------------------------------------------
</pre>

<p>It's enough to override only one functions because the second one just calls
<tt>throw_errno(prompt, errno)</tt>.</p>

<div class="section">Example</div>
<pre class="code">
ssize_t written = ::write(fd, buf, buf_size);
if(written &lt; 0) __vic::throw_errno("write");
// ...
</pre>






<h2 id="to_text.h">
<span class="h2_num">2.31</span><tt>__vic/to_text.h</tt>
</h2>


<p>Converters of types to text representation.</p>


<h3 id="to_text_append">
<span class="h3_num">2.31.1</span><tt>to_text_append()</tt>
</h3>


<pre class="code">
void to_text_append(long long n, std::string &amp;str);
void to_text_append(long n, std::string &amp;str);
void to_text_append(int n, std::string &amp;str);
void to_text_append(short n, std::string &amp;str);
void to_text_append(signed char n, std::string &amp;str);

void to_text_append(unsigned long long n, std::string &amp;str);
void to_text_append(unsigned long n, std::string &amp;str);
void to_text_append(unsigned n, std::string &amp;str);
void to_text_append(unsigned short n, std::string &amp;str);
void to_text_append(unsigned char n, std::string &amp;str);

void to_text_append(long double n, std::string &amp;str);
void to_text_append(double n, std::string &amp;str);
void to_text_append(float n, std::string &amp;str);

void to_text_append(bool f, std::string &amp;str);

void to_text_append(const void *p, std::string &amp;str);
</pre>

<p>Converters of non-character C++ fundamental types to some text
representation. Second parameter <tt>str</tt> is an output parameter, result
is appended to it.</p>

<div>
<u><b>Note</b></u>: <tt>signed char</tt> and <tt>unsigned char</tt> types are treated as
integers not characters!</div>

<div>
<pre class="prototype">void to_text_append(long long n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(long n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(int n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(short n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(signed char n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(unsigned long long n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(unsigned long n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(unsigned n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(unsigned short n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(unsigned  char n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(long double n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(double n, std::string &amp;str)</pre>
<pre class="prototype">void to_text_append(float n, std::string &amp;str)</pre>
<blockquote>













<p>Converts a number to decimal representation.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void to_text_append(bool f, std::string &amp;str)</pre>
<blockquote>

<p>Converts a boolean value to <tt>0</tt> or <tt>1</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void to_text_append(const void *p, std::string &amp;str)</pre>
<blockquote>

<p>Converts a pointer to some platform-specific representation.</p>
</blockquote>
</div>

<div class="section">Example</div>
<pre class="code">
int n = 5;
std::string st = "n = ";
__vic::to_text_append(n, st);
assert(st == "n = 5");
</pre>






<h2 id="type_traits.h">
<span class="h2_num">2.32</span><tt>__vic/type_traits.h</tt>
</h2>


<p>Template metaprogramming support.</p>
<p>All the predicate metafunctions have boolean member <tt>value</tt> and,
usually, derived from <tt>integral_constant</tt>.</p>
<p>All the type transformer metafunctions have type member <tt>type</tt>
containing the conversion result.</p>
<p>All of the template aliases are available only in C++11 mode.</p>


<h3 id="integral_constant">
<span class="h3_num">2.32.1</span><tt>integral_constant</tt>
</h3>


<pre class="code">
template&lt;class T, T Val&gt;
struct integral_constant
{
    using value_type = T;
    using type = integral_constant&lt;T, Val&gt;;

    static constexpr T value = Val;
};
</pre>

<p>The topmost base class of the most metafunctions.</p>




<h3 id="true_type">
<span class="h3_num">2.32.2</span><tt>true_type</tt>
</h3>


<pre class="code">
using true_type = integral_constant&lt;bool, true&gt;;
</pre>

<p>Base class for predicate metafunctions that have value <tt>true</tt>.</p>




<h3 id="false_type">
<span class="h3_num">2.32.3</span><tt>false_type</tt>
</h3>


<pre class="code">
using false_type = integral_constant&lt;bool, false&gt;;
</pre>

<p>Base class for predicate metafunctions that have value <tt>false</tt>.</p>




<h3 id="is_same">
<span class="h3_num">2.32.4</span><tt>is_same</tt>
</h3>


<pre class="code">
template&lt;class T1, class T2&gt; struct is_same;
</pre>

<p>A predicate. True if <tt>T1</tt> and <tt>T2</tt> are exactly the same
type.</p>




<h3 id="is_const">
<span class="h3_num">2.32.5</span><tt>is_const</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct is_const;
</pre>

<p>A predicate. True if <tt>T</tt> has <tt>const</tt> qualifier.</p>




<h3 id="is_signed_integer">
<span class="h3_num">2.32.6</span><tt>is_signed_integer</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct is_signed_integer;
</pre>

<p>A predicate. True if <tt>T</tt> is a one of the "standard signed integer
types" (see the Standard).</p>




<h3 id="is_unsigned_integer">
<span class="h3_num">2.32.7</span><tt>is_unsigned_integer</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct is_unsigned_integer;
</pre>

<p>A predicate. True if <tt>T</tt> is a one of the "standard unsigned integer
types" (see the Standard).</p>




<h3 id="conjunction">
<span class="h3_num">2.32.8</span><tt>conjunction</tt> <span class="sign">[C++11]</span>
</h3>


<pre class="code">
template&lt;class... B&gt; struct conjunction;
</pre>

<p>A predicate. The logical conjunction of the predicates <tt>B...</tt>.
False iff one of the <tt>B...</tt> is false.</p>




<h3 id="disjunction">
<span class="h3_num">2.32.9</span><tt>disjunction</tt> <span class="sign">[C++11]</span>
</h3>


<pre class="code">
template&lt;class... B&gt; struct disjunction;
</pre>

<p>A predicate. The logical disjunction of the predicates <tt>B...</tt>.
True iff one of the <tt>B...</tt> is true.</p>




<h3 id="negation">
<span class="h3_num">2.32.10</span><tt>negation</tt>
</h3>


<pre class="code">
template&lt;class B&gt; struct negation;
</pre>

<p>A predicate. The logical negation of the predicate <tt>B</tt>.</p>




<h3 id="remove_const">
<span class="h3_num">2.32.11</span><tt>remove_const</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct remove_const;
template&lt;class T&gt; using remove_const_t = typename remove_const&lt;T&gt;::type;
</pre>

<p>A type transformer. Removes the top-level <tt>const</tt> qualifier or just
returns <tt>T</tt> if it doesn't have such qualifier.</p>




<h3 id="remove_volatile">
<span class="h3_num">2.32.12</span><tt>remove_volatile</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct remove_volatile;
template&lt;class T&gt; using remove_volatile_t = typename remove_volatile&lt;T&gt;::type;
</pre>

<p>A type transformer. Removes the top-level <tt>volatile</tt> qualifier or just
returns <tt>T</tt> if it doesn't have such qualifier.</p>




<h3 id="remove_cv">
<span class="h3_num">2.32.13</span><tt>remove_cv</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct remove_cv;
template&lt;class T&gt; using remove_cv_t = typename remove_cv&lt;T&gt;::type;
</pre>

<p>A type transformer. Removes any top-level cv-qualifier or just returns
<tt>T</tt> if it doesn't have such qualifiers.</p>




<h3 id="remove_reference">
<span class="h3_num">2.32.14</span><tt>remove_reference</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct remove_reference;
template&lt;class T&gt; using remove_reference_t = typename remove_reference&lt;T&gt;::type;
</pre>

<p>A type transformer. Returns the type referred by <tt>T</tt> or just
<tt>T</tt> if it isn't a reference type.</p>




<h3 id="remove_cvref">
<span class="h3_num">2.32.15</span><tt>remove_cvref</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct remove_cvref;
template&lt;class T&gt; using remove_cvref_t = typename remove_cvref&lt;T&gt;::type;
</pre>

<p>A type transformer. Applies <tt>remove_reference</tt> then <tt>remove_cv</tt>
to <tt>T</tt>.</p>




<h3 id="remove_pointer">
<span class="h3_num">2.32.16</span><tt>remove_pointer</tt>
</h3>


<pre class="code">
template&lt;class T&gt; struct remove_pointer;
template&lt;class T&gt; using remove_pointer_t = typename remove_pointer&lt;T&gt;::type;
</pre>

<p>A type transformer. Returns the type pointed by <tt>T</tt> or just
<tt>T</tt> if it isn't a pointer type.</p>




<h3 id="conditional">
<span class="h3_num">2.32.17</span><tt>conditional</tt>
</h3>


<pre class="code">
template&lt;bool Cond, class Then, class Else&gt; struct conditional;

template&lt;bool Cond, class Then, class Else&gt;
using conditional_t = typename conditional&lt;Cond, Then, Else&gt;;
</pre>

<p>A type transformer. Returns <tt>Then</tt> if <tt>Cond == true</tt>.
<tt>Else</tt> is returned otherwise.</p>




<h3 id="enable_if">
<span class="h3_num">2.32.18</span><tt>enable_if</tt>, <tt>disable_if</tt>
</h3>


<pre class="code">
template&lt;bool Test, class T = void&gt;
struct enable_if
{
    using type = T;
};
template&lt;class T&gt;
struct enable_if&lt;false, T&gt; {};

template&lt;bool Test, class T = void&gt;
struct disable_if : enable_if&lt;!Test, T&gt; {};
</pre>

<p>Classical tools for SFINAE-magic.</p>




<h3 id="index_sequence">
<span class="h3_num">2.32.19</span><tt>index_sequence</tt>, <tt>make_index_sequence</tt> <span class="sign">[C++11]</span>
</h3>


<pre class="code">
template&lt;size_t... I&gt;
struct index_sequence
{
    static constexpr size_t size() { return sizeof...(I); }
};

template&lt;size_t Size&gt;
using make_index_sequence = index_sequence&lt;0, 1, ..., Size-1&gt;;
</pre>

<p>Implementation of C++14 <tt>std::index_sequence</tt> for C++11.</p>

<div>
<u><b>Note</b></u>: Unlike <tt>std::index_sequence</tt> it isn't a special case of some sort
of <tt>std::integer_sequence</tt>.</div>






<h2 id="unicode.h">
<span class="h2_num">2.33</span><tt>__vic/unicode.h</tt>
</h2>


<p><a href="https://www.unicode.org/">Unicode</a> support utilities.</p>


<h3 id="unicode_t">
<span class="h3_num">2.33.1</span><tt>unicode_t</tt>
</h3>


<pre class="code">
using unicode_t = char32_t; // since C++11
// or
using unicode_t = uint_least32_t; // C++98
</pre>

<p>Type able to store any Unicode
<a href="https://www.unicode.org/glossary/#code_point">code point</a>.</p>




<h3 id="utf_transcode">
<span class="h3_num">2.33.2</span><tt>utf_transcode()</tt>
</h3>


<pre class="code">
template&lt;class UTFReader, class UTFWriter&gt;
void utf_transcode(UTFReader r, UTFWriter w);
</pre>

<p>An algorithm that reads all code points of type <a href="#unicode_t"><tt>unicode_t</tt></a> from
<tt>UTFReader</tt> using <tt>r.read()</tt> and writes them to <tt>UTFWriter</tt>
using <tt>w.write()</tt>.</p>




<h3 id="unicode_code_point_constants">
<span class="h3_num">2.33.3</span><tt>Code point constants</tt>
</h3>


<pre class="code">
constexpr unicode_t unicode_max = 0x10FFFF;
constexpr unicode_t unicode_bom = 0xFEFF;
constexpr unicode_t unicode_replacement_char = 0xFFFD;
</pre>

<p>Named constants for some useful Unicode code points.</p>






<h2 id="utf8.status.h">
<span class="h2_num">2.34</span><tt>__vic/utf8/status.h</tt>
</h2>



<h3 id="utf8--status">
<span class="h3_num">2.34.1</span><tt>utf8::status</tt>
</h3>


<pre class="code">
enum class utf8::status
{
    ok = 0,
    eof,
    // Errors
    no_leading_byte,
    truncated_code_point,
    overlong_encoding,
    code_point_too_big
};
using utf8::status_t = utf8::status; // for C++98
</pre>

<p>Values returned by <a href="#utf8--reader"><tt>utf8::reader</tt></a> <tt>parse()</tt> function.</p>

<ul>
<li>
<tt>ok</tt> - code point successfully read</li>
<li>
<tt>eof</tt> - no more code points to read</li>
<li>
<tt>no_leading_byte</tt> - continuation byte w/o leading</li>
<li>
<tt>truncated_code_point</tt> - incomplete multibyte sequence</li>
<li>
<tt>overlong_encoding</tt> - overlong encoded code point</li>
<li>
<tt>code_point_too_big</tt> - code point value is too big</li>
</ul>




<h3 id="utf8--is_error">
<span class="h3_num">2.34.2</span><tt>utf8::is_error()</tt>
</h3>


<pre class="code">
constexpr bool utf8::is_error(utf8::status s);
</pre>

<p>Returns <tt>false</tt> for <tt>utf8::status::ok</tt> and
<tt>utf8::status::eof</tt> values. <tt>true</tt> is returned otherwise.</p>




<h3 id="utf8--throw_if_error">
<span class="h3_num">2.34.3</span><tt>utf8::throw_if_error()</tt>
</h3>


<pre class="code">
bool utf8::throw_if_error(utf8::status s);
</pre>

<p>Throws exception from <a href="#utf8.exceptions.h"><tt>__vic/utf8/exceptions.h</tt></a> if
<tt>is_error(s)</tt>. Returns <tt>true</tt> for <tt>utf8::status::ok</tt>
or <tt>false</tt> for <tt>utf8::status::eof</tt>.</p>






<h2 id="utf8.exceptions.h">
<span class="h2_num">2.35</span><tt>__vic/utf8/exceptions.h</tt>
</h2>


<pre class="code">
namespace utf8 {

class bad_encoding; // public std::exception
    class no_leading_byte;
    class truncated_code_point;
    class overlong_encoding;
    class code_point_too_big;

} // namespace
</pre>

<p>Exception classes thrown by <a href="#utf8--reader"><tt>utf8::reader</tt></a> <tt>read()</tt>
function. All exceptions are derived from abstract base class
<tt>utf8::bad_encoding</tt>. See <a href="#utf8--status"><tt>utf8::status</tt></a> for equivalent
status codes.</p>



<h2 id="utf8.reader.h">
<span class="h2_num">2.36</span><tt>__vic/utf8/reader.h</tt>
</h2>


<h3 id="utf8--reader">
<span class="h3_num">2.36.1</span><tt>utf8::reader</tt>
</h3>


<pre class="code">
template&lt;class ByteReader&gt;
class utf8::reader
{
public:
    using byte_reader_type = ByteReader;
    ByteReader &amp;get_byte_reader();
    const ByteReader &amp;get_byte_reader() const;

    template&lt;class... Args&gt;
    explicit reader(Args&amp;&amp;... args); // since C++11

    reader(); // C++98 only
    explicit reader(ByteReader r); // C++98 only

    status_t parse(unicode_t &amp;cp);
    bool read(unicode_t &amp;cp);
};

template&lt;class ByteReader&gt;
utf8::reader&lt;ByteReader&gt; utf8::make_reader(ByteReader r);
</pre>

<p>UTF-8 code points from byte sequence reader. The sequence is accessed using
<tt>ByteReader</tt> which models <tt>Reader&lt;unsigned char&gt;</tt> (see
<a href="#readers"><tt>__vic/readers/</tt></a>).</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">ByteReader &amp;get_byte_reader()</pre>
<pre class="prototype">const ByteReader &amp;get_byte_reader() const</pre>
<blockquote>


<p>Returns reference to the used byte reader.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class... Args&gt;
explicit reader(Args&amp;&amp;... args) <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Forwards all parameters to the used byte reader.</p>
</blockquote>
</div>

<div>
<pre class="prototype">reader() <span class="sign">[C++98 only]</span></pre>
<pre class="prototype">explicit reader(ByteReader r) <span class="sign">[C++98 only]</span></pre>
<blockquote>


<p>Constructors for C++98 mode.</p>
</blockquote>
</div>

<div>
<pre class="prototype">status_t parse(unicode_t &amp;cp)</pre>
<blockquote>

<p>Tries to extract the next code point from byte sequence using
<tt>ByteReader</tt>. On success <tt>utf8::status::ok</tt> is returned and the
code point is stored in <tt>cp</tt>. <tt>utf8::status::eof</tt> is returned
when no more bytes available. Other values are returned on errors, see
<a href="#utf8--status"><tt>utf8::status</tt></a> for more details. <tt>ByteReader::read()</tt> is
used to access individual bytes.</p>
<div>
<u>Note</u>: The function itself doesn't throw exceptions but exception can be
thrown by <tt>ByteReader::read()</tt>.</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool read(unicode_t &amp;cp)</pre>
<blockquote>

<p>Same as <tt>parse()</tt> but returns <tt>true</tt> on success, <tt>false</tt>
on EOF or throws an exception from <a href="#utf8.exceptions.h"><tt>__vic/utf8/exceptions.h</tt></a> otherwise.</p>
</blockquote>
</div>



<div class="section">Free functions</div>

<div>
<pre class="prototype">template&lt;class ByteReader&gt;
utf8::reader&lt;ByteReader&gt; utf8::make_reader(ByteReader r)</pre>
<blockquote>

<p>Creates UTF-8 reader using specified <tt>ByteReader</tt>.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
#include&lt;__vic/utf8/reader.h&gt;
#include&lt;__vic/readers/string.h&gt;
#include&lt;string&gt;
#include&lt;cstdint&gt;
#include&lt;iostream&gt;

// C++11
using utf8_string_reader = __vic::utf8::reader&lt;__vic::string_reader&gt;;

// C++98
struct utf8_string_reader : __vic::utf8::reader&lt;__vic::string_reader&gt;
{
    explicit utf8_string_reader(const std::string &amp;s)
        : __vic::utf8::reader&lt;__vic::string_reader&gt;(__vic::string_reader(s)) {}
};

void print_utf8_code_points(const string &amp;s)
{
    utf8_string_reader r(s);
    __vic::unicode_t cp;
    while(r.read(cp))
        std::cout &lt;&lt; uint_least32_t(cp) &lt;&lt; '\n';
}
</pre>






<h2 id="utf8.writer.h">
<span class="h2_num">2.37</span><tt>__vic/utf8/writer.h</tt>
</h2>


<h3 id="utf8--writer">
<span class="h3_num">2.37.1</span><tt>utf8::writer</tt>
</h3>


<pre class="code">
template&lt;class ByteWriter&gt;
class utf8::writer
{
public:
    using byte_writer_type = ByteWriter;
    ByteWriter &amp;get_byte_writer();
    const ByteWriter &amp;get_byte_writer() const;

    template&lt;class... Args&gt;
    explicit writer(Args&amp;&amp;... args); // since C++11

    writer(); // C++98 only
    explicit writer(ByteWriter w); // C++98 only

    void write(unicode_t cp);
};

template&lt;class ByteWriter&gt;
utf8::writer&lt;ByteWriter&gt; utf8::make_writer(ByteWriter w);
</pre>

<p>UTF-8 code points to byte sequence writer. <tt>ByteWriter</tt>
which models <tt>Writer&lt;unsigned char&gt;</tt> (see <a href="#writers"><tt>__vic/writers/</tt></a>)
is used as a byte output.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">ByteWriter &amp;get_byte_writer()</pre>
<pre class="prototype">const ByteWriter &amp;get_byte_writer() const</pre>
<blockquote>


<p>Returns reference to the used byte writer.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class... Args&gt;
explicit writer(Args&amp;&amp;... args) <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Forwards all parameters to the used byte writer.</p>
</blockquote>
</div>

<div>
<pre class="prototype">writer() <span class="sign">[C++98 only]</span></pre>
<pre class="prototype">explicit writer(ByteWriter r) <span class="sign">[C++98 only]</span></pre>
<blockquote>


<p>Constructors for C++98 mode.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void write(unicode_t cp)</pre>
<blockquote>

<p>Writes the specified code point according to UTF-8 encoding rules.
<tt>ByteWriter::write()</tt> is used to write individual bytes.</p>
</blockquote>
</div>



<div class="section">Free functions</div>

<div>
<pre class="prototype">template&lt;class ByteWriter&gt;
utf8::writer&lt;ByteWriter&gt; utf8::make_writer(ByteWriter w)</pre>
<blockquote>

<p>Creates UTF-8 writer using specified <tt>ByteWriter</tt>.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
#include&lt;__vic/utf8/writer.h&gt;
#include&lt;__vic/writers/string.h&gt;
#include&lt;string&gt;
#include&lt;vector&gt;

// C++11
using utf8_string_writer = __vic::utf8::writer&lt;__vic::string_writer&gt;;

// C++98
struct utf8_string_writer : __vic::utf8::writer&lt;__vic::string_writer&gt;
{
    explicit utf8_string_writer(std::string &amp;s)
        : __vic::utf8::writer&lt;__vic::string_writer&gt;(__vic::string_writer(s)) {}
};

std::string encode_utf8(const std::vector&lt;__vic::unicode_t&gt; &amp;code_points)
{
    std::string utf8_res;
    utf8_string_writer w(utf8_res);
    for(auto cp : code_points) w.write(cp);
    return utf8_res;
}
</pre>






<h2 id="utf16.defs.h">
<span class="h2_num">2.38</span><tt>__vic/utf16/defs.h</tt>
</h2>


<h3 id="utf16--code_unit_t">
<span class="h3_num">2.38.1</span><tt>utf16::code_unit_t</tt>
</h3>


<pre class="code">
namespace utf16 {

using code_unit_t = char16_t; // since C++11
// or
using code_unit_t = uint_least16_t; // C++98

} // namespace
</pre>

<p>UTF-16 <a href="https://unicode.org/glossary/#code_unit">code unit</a>
type.</p>





<h2 id="utf16.status.h">
<span class="h2_num">2.39</span><tt>__vic/utf16/status.h</tt>
</h2>



<h3 id="utf16--status">
<span class="h3_num">2.39.1</span><tt>utf16::status</tt>
</h3>


<pre class="code">
enum class utf16::status
{
    ok = 0,
    eof,
    // Errors
    truncated_code_unit,
    truncated_code_point,
    invalid_sequence
};
using utf16::status_t = utf16::status; // for C++98
</pre>

<p>Values returned by <a href="#utf16--reader"><tt>utf16::reader</tt></a> <tt>parse()</tt> function.</p>

<ul>
<li>
<tt>ok</tt> - code point successfully read</li>
<li>
<tt>eof</tt> - no more code points to read</li>
<li>
<tt>truncated_code_unit</tt> - incomplete code unit</li>
<li>
<tt>truncated_code_point</tt> - incomplete code point</li>
<li>
<tt>invalid_sequence</tt> - the bytes don't represent any valid
        UTF-16 code point</li>
</ul>




<h3 id="utf16--is_error">
<span class="h3_num">2.39.2</span><tt>utf16::is_error()</tt>
</h3>


<pre class="code">
constexpr bool utf16::is_error(utf16::status s);
</pre>

<p>Returns <tt>false</tt> for <tt>utf16::status::ok</tt> and
<tt>utf16::status::eof</tt> values. <tt>true</tt> is returned otherwise.</p>




<h3 id="utf16--throw_if_error">
<span class="h3_num">2.39.3</span><tt>utf16::throw_if_error()</tt>
</h3>


<pre class="code">
bool utf16::throw_if_error(utf16::status s);
</pre>

<p>Throws exception from <a href="#utf16.exceptions.h"><tt>__vic/utf16/exceptions.h</tt></a> if
<tt>is_error(s)</tt>. Returns <tt>true</tt> for <tt>utf16::status::ok</tt>
or <tt>false</tt> for <tt>utf16::status::eof</tt>.</p>






<h2 id="utf16.exceptions.h">
<span class="h2_num">2.40</span><tt>__vic/utf16/exceptions.h</tt>
</h2>


<pre class="code">
namespace utf16 {

class bad_encoding; // public std::exception
    class truncated_code_unit;
    class truncated_code_point;
    class invalid_sequence;

} // namespace
</pre>

<p>Exception classes thrown by <a href="#utf16--reader"><tt>utf16::reader</tt></a> <tt>read()</tt>
function. All exceptions are derived from abstract base class
<tt>utf16::bad_encoding</tt>. See <a href="#utf16--status"><tt>utf16::status</tt></a> for equivalent
status codes.</p>



<h2 id="utf16.reader.h">
<span class="h2_num">2.41</span><tt>__vic/utf16/reader.h</tt>
</h2>


<h3 id="utf16--reader">
<span class="h3_num">2.41.1</span><tt>utf16::reader</tt>
</h3>


<pre class="code">
template&lt;class CodeUnitReader&gt;
class utf16::reader
{
public:
    using code_unit_reader_type = CodeUnitReader;
    CodeUnitReader &amp;get_code_unit_reader();
    const CodeUnitReader &amp;get_code_unit_reader() const;

    template&lt;class... Args&gt;
    explicit reader(Args&amp;&amp;... args);  // since C++11

    reader(); // C++98 only
    explicit reader(CodeUnitReader r); // C++98 only

    status_t parse(unicode_t &amp;cp);
    bool read(unicode_t &amp;cp);
};

template&lt;class CodeUnitReader&gt;
utf16::reader&lt;CodeUnitReader&gt; utf16::make_reader(CodeUnitReader r);
</pre>

<p>UTF-16 code points from 2-byte <a href="#utf16--code_unit_t"><tt>utf16::code_unit_t</tt></a> sequence
reader. The sequence is accessed using the special reader of the following
structure:</p>

<pre class="code">
class <span class="nonterminal">CodeUnitReader</span>
{
public:
    utf16::status_t read_unit(utf16::code_unit_t &amp;u);
};
</pre>

<div>
<pre class="prototype">utf16::status_t read_unit(utf16::code_unit_t &amp;u)</pre>
<blockquote>

<p>Tries to read the next code unit. Returns <tt>utf16::status::ok</tt> on
success, <tt>utf16::status::eof</tt> if no more code units available or
<tt>utf16::status::truncated_code_unit</tt> if only partial code unit
is available.</p>
</blockquote>
</div>

<div class="section">Class members</div>

<div>
<pre class="prototype">CodeUnitReader &amp;get_code_unit_reader()</pre>
<pre class="prototype">const CodeUnitReader &amp;get_code_unit_reader() const</pre>
<blockquote>


<p>Returns reference to the used code unit reader.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class... Args&gt;
explicit reader(Args&amp;&amp;... args) <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Forwards all parameters to the used code unit reader.</p>
</blockquote>
</div>

<div>
<pre class="prototype">reader() <span class="sign">[C++98 only]</span></pre>
<pre class="prototype">explicit reader(CodeUnitReader r) <span class="sign">[C++98 only]</span></pre>
<blockquote>


<p>Constructors for C++98 mode.</p>
</blockquote>
</div>

<div>
<pre class="prototype">status_t parse(unicode_t &amp;cp)</pre>
<blockquote>

<p>Tries to extract the next code point from code unit sequence using
<tt>CodeUnitReader</tt>. On success <tt>utf16::status::ok</tt> is returned and
the code point is stored in <tt>cp</tt>. <tt>utf16::status::eof</tt> is
returned when no more code units available. Other values are returned on errors,
see <a href="#utf16--status"><tt>utf16::status</tt></a> for more details.
<tt>CodeUnitReader::read_unit()</tt> is used to access code units.</p>
<div>
<u>Note</u>: The function itself doesn't throw exceptions but exception can be
thrown by <tt>CodeUnitReader::read_unit()</tt>.</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool read(unicode_t &amp;cp)</pre>
<blockquote>

<p>Same as <tt>parse()</tt> but returns <tt>true</tt> on success, <tt>false</tt>
on EOF or throws an exception from <a href="#utf16.exceptions.h"><tt>__vic/utf16/exceptions.h</tt></a> otherwise.</p>
</blockquote>
</div>



<div class="section">Free functions</div>

<div>
<pre class="prototype">template&lt;class CodeUnitReader&gt;
utf16::reader&lt;CodeUnitReader&gt; utf16::make_reader(CodeUnitReader r)</pre>
<blockquote>

<p>Creates UTF-16 reader using specified <tt>CodeUnitReader</tt>.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
#include&lt;__vic/utf16/reader.h&gt;
#include&lt;__vic/readers/string.h&gt;
#include&lt;string&gt;
#include&lt;cstdint&gt;
#include&lt;iostream&gt;

class u16string_code_unit_reader
{
    __vic::basic_string_reader&lt;char16_t&gt; r;
public:
    explicit u16string_code_unit_reader(const std::u16string &amp;s) : r(s) {}

    __vic::utf16::status_t read_unit(__vic::utf16::code_unit_t &amp;u)
    {
        if(r.read(u)) return __vic::utf16::status::ok;
        return __vic::utf16::status::eof;
    }
};

void print_utf16_code_points(const std::u16string &amp;s)
{
    __vic::utf16::reader&lt;u16string_code_unit_reader&gt; r(s);
    __vic::unicode_t cp;
    while(r.read(cp))
        std::cout &lt;&lt; uint_least32_t(cp) &lt;&lt; '\n';
}
</pre>






<h2 id="utf16.writer.h">
<span class="h2_num">2.42</span><tt>__vic/utf16/writer.h</tt>
</h2>


<h3 id="utf16--writer">
<span class="h3_num">2.42.1</span><tt>utf16::writer</tt>
</h3>


<pre class="code">
template&lt;class CodeUnitWriter&gt;
class utf16::writer
{
public:
    using code_unit_writer_type = CodeUnitWriter;
    CodeUnitWriter &amp;get_code_unit_writer();
    const CodeUnitWriter &amp;get_code_unit_writer() const;

    template&lt;class... Args&gt;
    explicit writer(Args&amp;&amp;... args); // since C++11

    writer(); // C++98 only
    explicit writer(CodeUnitWriter w); // C++98 only

    void write(unicode_t cp);
};

template&lt;class CodeUnitWriter&gt;
utf16::writer&lt;CodeUnitWriter&gt; utf16::make_writer(CodeUnitWriter w);
</pre>

<p>UTF-16 code points to 2-byte <a href="#utf16--code_unit_t"><tt>utf16::code_unit_t</tt></a> sequence writer.
<tt>CodeUnitWriter</tt> which models <tt>Writer&lt;utf16::code_unit_t&gt;</tt>
(see <a href="#writers"><tt>__vic/writers/</tt></a>) is used as a code units output.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">CodeUnitWriter &amp;get_code_unit_writer()</pre>
<pre class="prototype">const CodeUnitWriter &amp;get_code_unit_writer() const</pre>
<blockquote>


<p>Returns reference to the used code unit writer.</p>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class... Args&gt;
explicit writer(Args&amp;&amp;... args) <span class="sign">[C++11]</span></pre>
<blockquote>

<p>Forwards all parameters to the used code unit writer.</p>
</blockquote>
</div>

<div>
<pre class="prototype">writer() <span class="sign">[C++98 only]</span></pre>
<pre class="prototype">explicit writer(CodeUnitWriter r) <span class="sign">[C++98 only]</span></pre>
<blockquote>


<p>Constructors for C++98 mode.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void write(unicode_t cp)</pre>
<blockquote>

<p>Writes the specified code point according to UTF-16 encoding rules.
<tt>CodeUnitWriter::write()</tt> is used to write individual code units.</p>
</blockquote>
</div>



<div class="section">Free functions</div>

<div>
<pre class="prototype">template&lt;class CodeUnitWriter&gt;
utf16::writer&lt;CodeUnitWriter&gt; utf16::make_writer(CodeUnitWriter w)</pre>
<blockquote>

<p>Creates UTF-16 writer using specified <tt>CodeUnitWriter</tt>.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
#include&lt;__vic/utf16/writer.h&gt;
#include&lt;__vic/writers/string.h&gt;
#include&lt;string&gt;
#include&lt;vector&gt;

std::u16string encode_utf16(const std::vector&lt;__vic::unicode_t&gt; &amp;code_points)
{
    std::u16string utf16_res;
    __vic::utf16::writer&lt;__vic::basic_string_writer&lt;char16_t&gt;&gt; w(utf16_res);
    for(auto cp : code_points) w.write(cp);
    return utf16_res;
}
</pre>






<h2 id="waitable_event.h">
<span class="h2_num">2.43</span><tt>__vic/waitable_event.h</tt>
</h2>


<h3 id="waitable_event">
<span class="h3_num">2.43.1</span><tt>waitable_event</tt>
</h3>


<pre class="code">
class waitable_event : private non_copyable
{
public:
    explicit waitable_event(bool signaled = false);
    ~waitable_event();

    void set();
    void reset();
    bool signaled() const;

    void wait();
    bool wait_ms(unsigned msec);

    // BEGIN C++11
    template&lt;class Rep, class Period&gt;
    bool wait_for(const std::chrono::duration&lt;Rep,Period&gt; &amp;d);
    template&lt;class Clock, class Duration&gt;
    bool wait_until(const std::chrono::time_point&lt;Clock,Duration&gt; &amp;t);
    // END C++11
};

</pre>

<p>A synchronization object like Event Object in Windows. Can be in ether of
two states: signaled or nonsignaled. A thread can effectively wait for the
signaled state using one of the available wait-functions (with minimal system
resources consumption).</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">explicit waitable_event(bool signaled = false)</pre>
<blockquote>

<div>
<u>Postcondition</u>: <tt>signaled() == signaled</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool signaled() const</pre>
<blockquote>

<p>Returns <tt>true</tt> if the object is in signaled state.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void set()</pre>
<blockquote>

<p>Sets the signaled state.</p>
<div>
<u>Postcondition</u>: <tt>signaled() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void reset()</pre>
<blockquote>

<p>Sets the nonsignaled state.</p>
<div>
<u>Postcondition</u>: <tt>signaled() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void wait()</pre>
<blockquote>

<p>Waits for the signaled state with no timeout.</p>
<div>
<u>Postcondition</u>: <tt>signaled() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool wait_ms(unsigned msec)</pre>
<blockquote>

<p>Waits for the signaled state no longer than the specified amount of
milliseconds. Returns <tt>signaled()</tt>.</p>
<div>
<u>Note</u>: <tt>wait_for()</tt> should be used in C++11 mode instead.</div>
</blockquote>
</div>

<div>
<pre class="prototype">template&lt;class Rep, class Period&gt;
bool wait_for(const std::chrono::duration&lt;Rep,Period&gt; &amp;d) <span class="sign">[C++11]</span></pre>
<pre class="prototype">template&lt;class Clock, class Duration&gt;
bool wait_until(const std::chrono::time_point&lt;Clock,Duration&gt; &amp;t) <span class="sign">[C++11]</span></pre>
<blockquote>


<p>Waits for the signaled state no longer than the specified timeout. Returns
<tt>signaled()</tt>.</p>
</blockquote>
</div>







<h2 id="writers">
<span class="h2_num">2.44</span><tt>__vic/writers/</tt>
</h2>



<h3 id="writer-concept">
<span class="h3_num">2.44.1</span><tt>Writer</tt> concept</h3>


<pre class="code">
template&lt;class ElementT&gt;
class <span class="nonterminal">Writer</span>
{
public:
    Writer(Writer &amp;&amp;o); or Writer(const Writer &amp;o);
    void write(ElementT v); // throws on errors
};
</pre>

<p>A concept used by the library algorithms to write logical sequence of elements
of type <tt>ElementT</tt> element by element. It is a generalization and rework
of the <tt>OutputIterator</tt> concept. In particular it handles streams
and other output sequences where <tt>end</tt>-iterator is meaningless or
expensive to obtain better. At the same time, a traditional output iterators
are just a particular case and fully and well handled by
<tt>__vic::iterator_writer</tt> adapter.</p>

<p>When the particular class meets the requirements of this concept for some
<tt>ElementT = T</tt> it is said <b>to model</b> the <tt>Writer&lt;T&gt;</tt>
concept.</p>

<p>Each instance of the class has to be move- or copy-constructible.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">void write(ElementT v)</pre>
<blockquote>

<p>Writes the element or throws an exception on error.</p>
</blockquote>
</div>






<h3 id="null_writer">
<span class="h3_num">2.44.2</span><tt>null_writer</tt>
</h3>


<pre class="code">
#include&lt;__vic/writers/null.h&gt;

class null_writer
{
public:
    template&lt;class T&gt; void write(T v) {}
};

null_writer make_null_writer();
</pre>

<p>Fake writer that accepts any value and does nothing with it (like UNIX
<tt>/dev/null</tt>).</p>




<h3 id="push_back_writer">
<span class="h3_num">2.44.3</span><tt>push_back_writer</tt>
</h3>


<pre class="code">
#include&lt;__vic/writers/push_back.h&gt;

template&lt;class Cont, class T = typename Cont::value_type&gt;
class push_back_writer
{
public:
    explicit push_back_writer(Cont &amp;c);
    void write(T v) { c-&gt;push_back(v); }
};

template&lt;class Cont&gt;
push_back_writer&lt;Cont&gt; make_push_back_writer(Cont &amp;c);

template&lt;class T, class Cont&gt;
push_back_writer&lt;Cont,T&gt; make_push_back_writer_for(Cont &amp;c);
</pre>

<p>An adapter. Uses <tt>push_back()</tt> member function to write elements.
Can be created using constructor or one of <tt>make_...</tt> functions.</p>




<h3 id="iterator_writer">
<span class="h3_num">2.44.4</span><tt>iterator_writer</tt>
</h3>


<pre class="code">
#include&lt;__vic/writers/iterator.h&gt;

template&lt;class OutputIterator,
         class T = typename std::iterator_traits&lt;OutputIterator&gt;::value_type&gt;
class iterator_writer
{
public:
    explicit iterator_writer(OutputIterator it);
    void write(T v);
};

template&lt;class OutputIterator&gt;
iterator_writer&lt;OutputIterator&gt; make_iterator_writer(OutputIterator it);

template&lt;class T, class OutputIterator&gt;
iterator_writer&lt;OutputIterator,T&gt; make_iterator_writer_for(OutputIterator it);
</pre>

<p>Output iterator writer. Can be created using constructor or one of
<tt>make_...</tt> functions.</p>




<h3 id="string_writer">
<span class="h3_num">2.44.5</span><tt>string_writer</tt>
</h3>


<pre class="code">
#include&lt;__vic/writers/string.h&gt;

template&lt;
    class charT,
    class Tr = std::char_traits&lt;charT&gt;,
    class Al = std::allocator&lt;charT&gt;
&gt;
class basic_string_writer
{
public:
    explicit basic_string_writer(std::basic_string&lt;charT,Tr,Al&gt; &amp;s);
    void write(charT ch);
};

using string_writer = basic_string_writer&lt;char&gt;;

template&lt;class charT, class Tr, class Al&gt;
basic_string_writer&lt;charT,Tr,Al&gt;
    make_string_writer(std::basic_string&lt;charT,Tr,Al&gt; &amp;s);
</pre>

<p>An adapter for <tt>std::basic_string</tt>. Can be created using constructor
or <tt>make_...</tt> function.</p>




<h3 id="cstream_writer">
<span class="h3_num">2.44.6</span><tt>cstream_writer</tt>
</h3>


<pre class="code">
#include&lt;__vic/writers/cstream.h&gt;

class cstream_writer
{
public:
    explicit cstream_writer(std::FILE *fp);
    void write(char ch) { __vic::write(fp, ch); }
};

cstream_writer make_cstream_writer(std::FILE *fp);
</pre>

<p>Models <tt>Writer&lt;char&gt;</tt> for <tt>std::FILE</tt>. Can be created using
constructor or <tt>make_...</tt> function.</p>






<h2 id="windows.bitmap.h">
<span class="h2_num">2.45</span><tt>__vic/windows/bitmap.h</tt>
</h2>


<h3 id="windows--Bitmap">
<span class="h3_num">2.45.1</span><tt>windows::Bitmap</tt>
</h3>


<pre class="code">
class windows::Bitmap
{
public:
    Bitmap() = default;
    explicit Bitmap(HBITMAP h);

    static Bitmap CreateCompatible(HDC hdc, int w, int h);

    bool DeleteNT() noexcept;
    void Delete();

    void ClearHandle();
    HBITMAP Handle() const;
    void Handle(HBITMAP h);
    operator HBITMAP() const;
};
</pre>

<p>C++ wrapper for Win32 API <tt>HBITMAP</tt>.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">Bitmap() = default</pre>
<blockquote>

<p>Creates an uninitialized value.</p>
</blockquote>
</div>

<div>
<pre class="prototype">explicit Bitmap(HBITMAP h)</pre>
<blockquote>

<div>
<u>Postcondition</u>: <tt>Handle() == h</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">static Bitmap CreateCompatible(HDC hdc, int w, int h)</pre>
<blockquote>

<p>Calls <tt>::CreateCompatibleBitmap()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool DeleteNT() noexcept</pre>
<blockquote>

<p>Calls <tt>::DeleteObject()</tt> and returns <tt>false</tt> on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void Delete()</pre>
<blockquote>

<p>Calls <tt>::DeleteObject()</tt> and throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void ClearHandle()</pre>
<blockquote>

<div>
<u>Postcondition</u>: <tt>!Handle()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">HBITMAP Handle() const</pre>
<pre class="prototype">operator HBITMAP() const</pre>
<blockquote>


<p>Returns the wrapped HBITMAP value.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void Handle(HBITMAP h)</pre>
<blockquote>

<div>
<u>Postcondition</u>: <tt>Handle() == h</tt>
</div>
</blockquote>
</div>







<h2 id="windows.critical_section.h">
<span class="h2_num">2.46</span><tt>__vic/windows/critical_section.h</tt>
</h2>



<h3 id="windows--CriticalSection">
<span class="h3_num">2.46.1</span><tt>windows::CriticalSection</tt>
</h3>


<pre class="code">
class windows::CriticalSection : private non_copyable
{
public:
    CriticalSection();
    explicit CriticalSection(DWORD dwSpinCount); // _WIN32_WINNT &gt;= 0x0403
    ~CriticalSection();

    void Enter();
    bool TryEnter();
    void Leave() noexcept;

    ::CRITICAL_SECTION *handle();
    const ::CRITICAL_SECTION *handle() const;
};
</pre>

<p>A C++ wrapper for Win32 API <tt>CRITICAL_SECTION</tt>.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">CriticalSection()</pre>
<blockquote>

<p>Calls <tt>::InitializeCriticalSection()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">explicit CriticalSection(DWORD dwSpinCount) <span class="sign">[_WIN32_WINNT &gt;= 0x0403]</span></pre>
<blockquote>

<p>Calls <tt>::InitializeCriticalSectionAndSpinCount()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~CriticalSection()</pre>
<blockquote>

<p>Calls <tt>::LeaveCriticalSection()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void Enter()</pre>
<blockquote>

<p>Calls <tt>::EnterCriticalSection()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool TryEnter()</pre>
<blockquote>

<p>Calls <tt>::TryEnterCriticalSection()</tt> and returs the result.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void Leave() noexcept</pre>
<blockquote>

<p>Calls <tt>::LeaveCriticalSection()</tt>.</p>
</blockquote>
</div>



<div>
<u><b>Note</b></u>: Direct calls of <tt>Enter()</tt>/<tt>Leave()</tt> should be avoided, use
<a href="#windows--CSGuard"><tt>windows::CSGuard</tt></a> objects instead.</div>




<h3 id="windows--CSGuard">
<span class="h3_num">2.46.2</span><tt>windows::CSGuard</tt>
</h3>


<pre class="code">
class windows::CSGuard : private non_copyable
{
public:
    enum adopt_t { adopt };

    explicit CSGuard(::CRITICAL_SECTION &amp;cs);
    CSGuard(::CRITICAL_SECTION &amp;cs, adopt_t);

    explicit CSGuard(CriticalSection &amp;cs);
    CSGuard(CriticalSection &amp;cs, adopt_t);

    ~CSGuard();
};
</pre>

<p>A scoped lock guard. Works with <tt>::CRITICAL_SECTION</tt> as well as with
<a href="#windows--CriticalSection"><tt>windows::CriticalSection</tt></a> objects.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">explicit CSGuard(::CRITICAL_SECTION &amp;cs)</pre>
<pre class="prototype">explicit CSGuard(CriticalSection &amp;cs)</pre>
<blockquote>


<p>Calls <tt>::EnterCriticalSection(&amp;cs)</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">CSGuard(::CRITICAL_SECTION &amp;cs, adopt_t)</pre>
<pre class="prototype">CSGuard(CriticalSection &amp;cs, adopt_t)</pre>
<blockquote>


<p>Only saves the reference to <tt>cs</tt> without
<tt>::EnterCriticalSection()</tt> call.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~CSGuard()</pre>
<blockquote>

<p>Calls <tt>::LeaveCriticalSection(&amp;cs)</tt>.</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
// Typical usage
void reentrant_function()
{
    static __vic::windows::CriticalSection cs;
    __vic::windows::CSGuard guard(cs);
    // Critical section code until the end of the block
    ...
}

// Usage of the adopt-constructor
__vic::windows::CriticalSection cs;
if(cs.TryEnter()) // Try to enter the critical section
{
    // Success
    using __vic::windows::CSGuard;
    CSGuard guard(cs, CSGuard::adopt);
    // Critical section code until the end of the block
    ...
}
else
{
    // The critical section is busy
    ...
}
</pre>







<h2 id="windows.dc.h">
<span class="h2_num">2.47</span><tt>__vic/windows/dc.h</tt>
</h2>


<p>C++ wrappers for Win32 GDI device context (DC).</p>


<h3 id="windows--DC">
<span class="h3_num">2.47.1</span><tt>windows::DC</tt>
</h3>


<pre class="code">
class windows::DC
{
public:
    DC() = default;
    explicit DC(HDC hdc);

    static DC CreateCompatible(HDC hdc);

    bool ReleaseNT(HWND hwnd) noexcept;
    void Release(HWND hwnd);
    bool DeleteNT() noexcept;
    void Delete();

    int GetHorzRes() const;
    int GetVertRes() const;
    HWND GetWindow() const;
    HGDIOBJ GetCurrentObject(UINT uObjType) const;
    HBRUSH GetCurrentBrush() const;
    HPEN GetCurrentPen() const;
    HFONT GetCurrentFont() const;
    HBITMAP GetCurrentBitmap() const;

    void Select(HGDIOBJ hObj); // not a region object
    void Select(HRGN hReg);

    COLORREF SetPixel(int x, int y, COLORREF c);
    bool MoveTo(int x, int y, POINT *p = 0);
    bool LineTo(int x, int y);
    bool PolyBezier(const POINT *lppt, DWORD cPoints);
    bool FillRect(const RECT &amp;rect, HBRUSH hbr);

    bool BlitTo(HDC dcDest, int x, int y,
                            int w, int h, DWORD dwRop = SRCCOPY) const;
    bool BlitTo(HDC dcDest, const RECT &amp;r, DWORD dwRop = SRCCOPY) const;

    void ClearHandle();
    HDC Handle() const;
    void Handle(HDC hdc);
    operator HDC() const;
};
</pre>

<p>General purpose <tt>HDC</tt> wrapper. Use <a href="#windows--ClientDC"><tt>windows::ClientDC</tt></a>
instead of <tt>::ReleaseDC()</tt>. Use <a href="#windows--PaintDC"><tt>windows::PaintDC</tt></a> instead of
<tt>::BeginPaint()</tt>/<tt>::EndPaint()</tt>.</p>

<div>
<u><b>Note</b></u>: For the most functions returning <tt>false</tt> on error no any addition
information can be obtained using <tt>::GetLastError()</tt>.</div>

<div class="section">Class members</div>

<div>
<pre class="prototype">DC() = default</pre>
<blockquote>

<p>Creates an uninitialized value.</p>
</blockquote>
</div>

<div>
<pre class="prototype">explicit DC(HDC hdc)</pre>
<blockquote>

<div>
<u>Postcondition</u>: <tt>Handle() == hdc</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">static DC CreateCompatible(HDC hdc)</pre>
<blockquote>

<p>Calls <tt>::CreateCompatibleDC()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool ReleaseNT(HWND hwnd) noexcept</pre>
<blockquote>

<p>Calls <tt>::ReleaseDC()</tt> and returns <tt>false</tt> on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void Release(HWND hwnd)</pre>
<blockquote>

<p>Calls <tt>::ReleaseDC()</tt> and throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool DeleteNT() noexcept</pre>
<blockquote>

<p>Calls <tt>::DeleteDC()</tt> and returns <tt>false</tt> on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void Delete()</pre>
<blockquote>

<p>Calls <tt>::DeleteDC()</tt> and throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">int GetHorzRes() const</pre>
<blockquote>

<p>Returns a horizontal resolution of the DC.</p>
</blockquote>
</div>

<div>
<pre class="prototype">int GetVertRes() const</pre>
<blockquote>

<p>Returns a vertical resolution of the DC.</p>
</blockquote>
</div>

<div>
<pre class="prototype">HWND GetWindow() const</pre>
<blockquote>

<p>Calls <tt>::WindowFromDC()</tt> and returns its result.</p>
</blockquote>
</div>

<div>
<pre class="prototype">HGDIOBJ GetCurrentObject(UINT uObjType) const</pre>
<blockquote>

<p>Calls <tt>::GetCurrentObject()</tt> with the specified <tt>uObjType</tt>
and returns its result.</p>
</blockquote>
</div>

<div>
<pre class="prototype">HBRUSH GetCurrentBrush() const</pre>
<pre class="prototype">HPEN GetCurrentPen() const</pre>
<pre class="prototype">HFONT GetCurrentFont() const</pre>
<pre class="prototype">HBITMAP GetCurrentBitmap() const</pre>
<blockquote>




<p>Calls <tt>::GetCurrentObject()</tt> for the corresponding object type
and returns its result.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void Select(HGDIOBJ hObj)</pre>
<blockquote>

<p>Calls <tt>::SelectObject()</tt> for object that is not a region and
throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void Select(HRGN hReg)</pre>
<blockquote>

<p>Calls <tt>::SelectObject()</tt> for region object and throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">COLORREF SetPixel(int x, int y, COLORREF c)</pre>
<blockquote>

<p>Calls <tt>::SetPixel()</tt> and returns its result.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool MoveTo(int x, int y, POINT *p = 0)</pre>
<blockquote>

<p>Calls <tt>::MoveToEx()</tt> and returns <tt>false</tt> on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool LineTo(int x, int y)</pre>
<blockquote>

<p>Calls <tt>::LineTo()</tt> and returns <tt>false</tt> on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool PolyBezier(const POINT *lppt, DWORD cPoints)</pre>
<blockquote>

<p>Calls <tt>::PolyBezier()</tt> and returns <tt>false</tt> on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool FillRect(const RECT &amp;rect, HBRUSH hbr)</pre>
<blockquote>

<p>Calls <tt>::PolyBezier()</tt> and returns <tt>false</tt> on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool BlitTo(HDC dcDest, int x, int y, int w, int h, DWORD dwRop = SRCCOPY) const</pre>
<pre class="prototype">bool BlitTo(HDC dcDest, const RECT &amp;r, DWORD dwRop = SRCCOPY) const</pre>
<blockquote>


<p>Calls <tt>::BitBlt()</tt> and returns <tt>false</tt> on error.</p>
<div>
<u>Note</u>: <tt>::GetLastError()</tt> can be used to get extended error information.</div>
</blockquote>
</div>

<div>
<pre class="prototype">void ClearHandle()</pre>
<blockquote>

<div>
<u>Postcondition</u>: <tt>!Handle()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">HDC Handle() const</pre>
<pre class="prototype">operator HDC() const</pre>
<blockquote>


<p>Returns the wrapped HDC value.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void Handle(HDC hdc)</pre>
<blockquote>

<div>
<u>Postcondition</u>: <tt>Handle() == hdc</tt>
</div>
</blockquote>
</div>






<h3 id="windows--ClientDC">
<span class="h3_num">2.47.2</span><tt>windows::ClientDC</tt>
</h3>


<pre class="code">
class windows::ClientDC : public windows::DC, private non_copyable
{
public:
    explicit ClientDC(HWND hwnd);
    ClientDC(HDC hdc, HWND hwnd);
    ~ClientDC();
};
</pre>

<p>RAII-wrapper. Calls <tt>::ReleaseDC()</tt> in destructor.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">explicit ClientDC(HWND hwnd)</pre>
<blockquote>

<p>Calls <tt>::GetDC(hwnd)</tt>. Throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">ClientDC(HDC hdc, HWND hwnd)</pre>
<blockquote>

<p>Adopts <tt>hdc</tt> for the subsequent release in the destructor.</p>
<div>
<u>Precondition</u>: <tt>hdc</tt> is a valid handler returned by
<tt>::GetDC(hwnd)</tt> call.</div>
<div>
<u>Postcondition</u>: <tt>Handle() == hdc</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">~ClientDC()</pre>
<blockquote>

<p>Calls <tt>::ReleaseDC()</tt>.</p>
</blockquote>
</div>






<h3 id="windows--PaintDC">
<span class="h3_num">2.47.3</span><tt>windows::PaintDC</tt>
</h3>


<pre class="code">
class windows::PaintDC :
    public windows::DC, public PAINTSTRUCT, private non_copyable
{
public:
    explicit PaintDC(HWND hwnd);
    ~PaintDC();
};
</pre>

<p>Wrapper for <tt>PAINTSTRUCT</tt> and
<tt>::BeginPaint()</tt>/<tt>::EndPaint()</tt> calls.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">explicit PaintDC(HWND hwnd)</pre>
<blockquote>

<p>Calls <tt>::BeginPaint(hwnd, this)</tt>. Throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~PaintDC()</pre>
<blockquote>

<p>Calls <tt>::EndPaint()</tt>.</p>
</blockquote>
</div>








<h2 id="windows.error.h">
<span class="h2_num">2.48</span><tt>__vic/windows/error.h</tt>
</h2>


<p>Windows-specific error handling tools.</p>

<h3 id="windows--error">
<span class="h3_num">2.48.1</span><tt>windows::error</tt>
</h3>


<pre class="code">
class windows::error : public std::exception
{
public:
    explicit error(DWORD err_code = ::GetLastError());
    explicit error(const char *prompt, DWORD err_code = ::GetLastError());

    const char *what() const noexcept;
    DWORD code() const;
};
</pre>

<p>Wrapper for Windows system error codes returned by Win32 API function
<tt>GetLastError()</tt>. See <a href="#libc_error"><tt>libc_error</tt></a> for reference.</p>





<h2 id="windows.event.h">
<span class="h2_num">2.49</span><tt>__vic/windows/event.h</tt>
</h2>


<h3 id="windows--Event">
<span class="h3_num">2.49.1</span><tt>windows::Event</tt>
</h3>


<pre class="code">
class windows::Event : private non_copyable
{
public:
    explicit Event(bool bManualReset,
         bool bInitialSignaled = false, LPCWSTR lpName = nullptr);
    ~Event();

    void Set();
    void Reset();
    bool Wait(DWORD timeout = INFINITE) const;
    bool wait_for(std::chrono::milliseconds ms) const; // C++11

    HANDLE handle() const;
};
</pre>

<p>Wrapper for Win32 API event synchronization object.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">explicit Event(bool bManualReset, bool bInitialSignaled = false, LPCWSTR lpName = nullptr)</pre>
<blockquote>

<p>Creates the object using <tt>::CreateEvent()</tt>. Throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~Event()</pre>
<blockquote>

<p>Destroys the object.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void Set()</pre>
<blockquote>

<p>Calls <tt>::SetEvent()</tt>. Throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void Reset()</pre>
<blockquote>

<p>Calls <tt>::ResetEvent()</tt>. Throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool Wait(DWORD timeout = INFINITE) const</pre>
<blockquote>

<p>Calls <tt>::WaitForSingleObject()</tt>. Throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool wait_for(std::chrono::milliseconds ms) const <span class="sign">[C++11]</span></pre>
<blockquote>

<p>chrono-friendly wrapper for <tt>Wait()</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">HANDLE handle() const</pre>
<blockquote>

<p>Returns Win32 API handle.</p>
</blockquote>
</div>







<h2 id="windows.find_file.h">
<span class="h2_num">2.50</span><tt>__vic/windows/find_file.h</tt>
</h2>


<h3 id="windows--FindFile">
<span class="h3_num">2.50.1</span><tt>windows::FindFile</tt>
</h3>


<pre class="code">
class windows::FindFile : public WIN32_FIND_DATA, private non_copyable
{
public:
    FindFile();
    ~FindFile();

    bool FindFirst(LPCTSTR filename);
    bool FindNext();

    bool IsOpen() const;
    void Close();
    bool CloseNT() noexcept;
};
</pre>

<p>Wrapper for Win32 API <tt>FindFirstFile()</tt>/<tt>FindNextFile()</tt>
functions. Special entries <tt>.</tt> and <tt>..</tt> are newer included in
the resulting set.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">FindFile()</pre>
<blockquote>

<div>
<u>Postcondition</u>: <tt>IsOpen() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">~FindFile()</pre>
<blockquote>

<p>Calls <tt>CloseNT()</tt> if <tt>IsOpen() == true</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool FindFirst(LPCTSTR filename)</pre>
<blockquote>

<p>Calls <tt>FindFirstFile()</tt>. Returns <tt>false</tt> if no files found.
Throws <a href="#windows--error"><tt>windows::error</tt></a> on other errors.</p>
<div>
<u>Precondition</u>: <tt>IsOpen() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool FindNext()</pre>
<blockquote>

<p>Calls <tt>FindNextFile()</tt>. Returns <tt>false</tt> if no more files
available. Throws <a href="#windows--error"><tt>windows::error</tt></a> on other errors.</p>
<div>
<u>Precondition</u>: <tt>IsOpen() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool Close()</pre>
<blockquote>

<p>Closes the find handle. Throws <a href="#windows--error"><tt>windows::error</tt></a> on errors.</p>
<div>
<u>Precondition</u>: <tt>IsOpen() == true</tt>
</div>
<div>
<u>Postcondition</u>: <tt>IsOpen() == false</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool CloseNT() noexcept</pre>
<blockquote>

<p>Same as <tt>Close()</tt> but returns <tt>false</tt> instead of throwing
exceptions.</p>
<div>
<u>Precondition</u>: <tt>IsOpen() == true</tt>
</div>
<div>
<u>Postcondition</u>: <tt>IsOpen() == false</tt>
</div>
</blockquote>
</div>







<h2 id="windows.handle.h">
<span class="h2_num">2.51</span><tt>__vic/windows/handle.h</tt>
</h2>



<h3 id="windows--Handle">
<span class="h3_num">2.51.1</span><tt>windows::Handle</tt>
</h3>


<pre class="code">
class windows::Handle
{
public:
    Handle() = default; // uninitialized
    constexpr Handle(HANDLE h);

    void Close();
    bool CloseNT() noexcept;
    static void Close(HANDLE h);

    bool Wait(DWORD timeout = INFINITE) const;

    bool IsInvalid() const;
    void SetInvalid();
    operator HANDLE() const;

    void swap(Handle &amp;o) noexcept;
};
</pre>

<p>A C++ wrapper for Win32 API <tt>HANDLE</tt>.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">Handle() = default</pre>
<blockquote>

<p>Creates an uninitialized value.</p>
</blockquote>
</div>

<div>
<pre class="prototype">constexpr Handle(HANDLE h)</pre>
<blockquote>

<p>Implicit converter from <tt>HANDLE</tt>.</p>
<div>
<u>Postcondition</u>: <tt>*this == h</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">operator HANDLE() const</pre>
<blockquote>

<p>Implicit converter to <tt>HANDLE</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool IsInvalid() const</pre>
<blockquote>

<p>Returns <tt>true</tt> if the handle has value <tt>INVALID_HANDLE_VALUE</tt>.
</p>
</blockquote>
</div>

<div>
<pre class="prototype">void SetInvalid()</pre>
<blockquote>

<p>Assigns value <tt>INVALID_HANDLE_VALUE</tt> to the handle.</p>
<div>
<u>Postcondition</u>: <tt>IsInvalid() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void Close()</pre>
<pre class="prototype">static void Close(HANDLE h)</pre>
<blockquote>


<p>Calls <tt>::CloseHandle()</tt>. Throws on error.</p>
<div>
<u>Precondition</u>: The same as for <tt>::CloseHandle()</tt>.</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool CloseNT() noexcept</pre>
<blockquote>

<p>Calls <tt>::CloseHandle()</tt> and returns <tt>true</tt> on success.
On failure <tt>::GetLastError()</tt> can be used to get the error
description.</p>
<div>
<u>Precondition</u>: The same as for <tt>::CloseHandle()</tt>.</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool Wait(DWORD timeout = INFINITE) const</pre>
<blockquote>

<p>Calls <tt>::WaitForSingleObject()</tt> with the specified timeout. Returns
<tt>false</tt> in case of <tt>WAIT_TIMEOUT</tt>. Throws on error.
<a href="#windows--WaitAbandoned"><tt>windows::WaitAbandoned</tt></a> is thrown in case of
<tt>WAIT_ABANDONED</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void swap(Handle &amp;o) noexcept</pre>
<blockquote>

<p>Swaps the value with <tt>o</tt>.</p>
</blockquote>
</div>






<h3 id="windows--WaitAbandoned">
<span class="h3_num">2.51.2</span><tt>windows::WaitAbandoned</tt>
</h3>


<pre class="code">
struct windows::WaitAbandoned : public std::exception
{
    const char *what() const noexcept;
};
</pre>

<p>An exception class thrown by <tt>__vic::windows::Handle::Wait()</tt>.</p>






<h2 id="windows.shadow_dc.h">
<span class="h2_num">2.52</span><tt>__vic/windows/shadow_dc.h</tt>
</h2>


<h3 id="windows--ShadowDC">
<span class="h3_num">2.52.1</span><tt>windows::ShadowDC</tt>
</h3>


<pre class="code">
class windows::ShadowDC : public windows::DC, private non_copyable
{
public:
    ShadowDC();
    ~ShadowDC();

    void Create(HWND hwnd);
    void Destroy();
    bool IsCreated() const;
};
</pre>

<p>Virtual in-memory DC.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">ShadowDC()</pre>
<blockquote>

<div>
<u>Postcondition</u>: <tt>!IsCreated()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">~ShadowDC()</pre>
<blockquote>

<p>Calls <tt>Destroy()</tt> is <tt>IsCreated() == true</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void Create(HWND hwnd)</pre>
<blockquote>

<p>Creates shadow DC compatible with the specified window of the same size.
Throws on errors.</p>
<div>
<u>Precondition</u>: <tt>!IsCreated()</tt>
</div>
<div>
<u>Postcondition</u>: <tt>IsCreated() == true</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">void Destroy()</pre>
<blockquote>

<p>Destroys the DC.</p>
<div>
<u>Precondition</u>: <tt>IsCreated() == true</tt>
</div>
<div>
<u>Postcondition</u>: <tt>!IsCreated()</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">bool IsCreated() const</pre>
<blockquote>

<p>Returns <tt>true</tt> if the object has an associated shadow DC.</p>
</blockquote>
</div>







<h2 id="windows.throw_last_error.h">
<span class="h2_num">2.53</span><tt>__vic/windows/throw_last_error.h</tt>
</h2>


<h3 id="windows--throw_last_error">
<span class="h3_num">2.53.1</span><tt>windows::throw_last_error()</tt>
</h3>


<pre class="code">
[[noreturn]] void throw_last_error(const char *prompt);
[[noreturn]] void throw_last_error(const char *prompt, DWORD code);
</pre>

<p>Throw an exception with global <tt>GetLastError()</tt> value or given
<tt>code</tt> correspondingly.</p>



<div class="section">Example</div>
<pre class="code">
if(!CloseHandle(h)) __vic::windows::throw_last_error("CloseHandle");
</pre>




<h2 id="windows.wait_cursor.h">
<span class="h2_num">2.54</span><tt>__vic/windows/wait_cursor.h</tt>
</h2>


<h3 id="windows--WaitCursor">
<span class="h3_num">2.54.1</span><tt>windows::WaitCursor</tt>
</h3>


<pre class="code">
class windows::WaitCursor : private non_copyable
{
public:
    explicit WaitCursor(HCURSOR h);
    ~WaitCursor();

    static HCURSOR GetDefault();
};
</pre>

<p>A RAII-wrapper. Temporarily replaces the mouse cursor with the one given in
the constructor. The destructor restores the previous cursor.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">explicit WaitCursor(HCURSOR h)</pre>
<blockquote>

<p>Replaces current cursor with <tt>h</tt>.</p>
</blockquote>
</div>

<div>
<pre class="prototype">~WaitCursor()</pre>
<blockquote>

<p>Restores the cursor.</p>
</blockquote>
</div>

<div>
<pre class="prototype">static HCURSOR GetDefault()</pre>
<blockquote>

<p>Returns the default wait-cursor handle (<tt>IDC_WAIT</tt>).</p>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
using __vic::windows::WaitCursor;
static HCURSOR hWaitCursor = WaitCursor::GetDefault();
{
    WaitCursor _(hWaitCursor); // the cursor is replaced here by hWaitCursor
    some_long_processing();
    // here the destructor restores the cursor
}
</pre>






<h2 id="windows.wchar.h">
<span class="h2_num">2.55</span><tt>__vic/windows/wchar.h</tt>
</h2>


<p>UTF-8 &lt;-&gt; UTF-16 interconversion tools.</p>


<h3 id="windows--wstring">
<span class="h3_num">2.55.1</span><tt>windows::wstring</tt>
</h3>


<pre class="code">
class windows::wstring : public std::wstring
{
public:
    wstring() = default;
    explicit wstring(size_type n) { reserve(n); }
    wstring(const wchar_t *st);
    wstring(std::wstring st);

    operator const wchar_t *() const { return c_str(); }
};
</pre>

<p><tt>std::wstring</tt> with automatic conversion to <tt>const wchar_t *</tt>.</p>




<h3 id="windows--utf8to16">
<span class="h3_num">2.55.2</span><tt>windows::utf8to16()</tt>
</h3>


<pre class="code">
windows::wstring windows::utf8to16(const char *s, size_t len);
windows::wstring windows::utf8to16(const char *s);
</pre>

<p>UTF-8 to UTF-16 converter.</p>




<h3 id="windows--utf16to8">
<span class="h3_num">2.55.3</span><tt>windows::utf16to8()</tt>
</h3>


<pre class="code">
std::string windows::utf16to8(const wchar_t *s, size_t len);
std::string windows::utf16to8(const wchar_t *s);
</pre>

<p>UTF-16 to UTF-8 converter.</p>






<h2 id="windows.window.h">
<span class="h2_num">2.56</span><tt>__vic/windows/window.h</tt>
</h2>



<h3 id="windows--Window">
<span class="h3_num">2.56.1</span><tt>windows::Window</tt>
</h3>


<pre class="code">
class windows::Window
{
public:
    struct Class;
    struct CreateParams;

    Window() = default;
    explicit Window(HWND hwnd);

    static void Register(WNDCLASSEXW wcl);
    void Create(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWndName,
        DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent,
        HMENU hMenu, HINSTANCE hInstance, void *lpParam = nullptr);
    void Create(const CREATESTRUCTW &amp;cs);

    LRESULT SendMessage(UINT msg, WPARAM w = 0, LPARAM l = 0);

    void Update();
    bool Show(int nWinMode);
    void Redraw(const RECT *rect = 0, HRGN hrgn = 0,
                        UINT flags = RDW_INVALIDATE | RDW_UPDATENOW);

    void GetRect(RECT &amp;r) const;
    RECT GetRect() const;
    void GetClientRect(RECT &amp;r) const
    RECT GetClientRect() const;

    void SetText(LPCWSTR st);
    void SetText(const char *st);
    int GetText(LPWSTR st, int nMax) const;

    void SetPos(HWND hWndAfter, int x, int y, int w, int h, UINT uFlags);
    void SetPos(int x, int y, int w, int h);
    void SetSize(int w, int h);
    void SetClientAreaSize(int w, int h);
    void MoveTo(int x, int y);
    void MoveToCenter();

    HWND Handle() const;
    void Handle(HWND hwnd);
    operator HWND() const;
};
</pre>

<p>Thin wrapper for Win32 API <tt>HWND</tt>.</p>

<div class="section">Class members</div>

<div>
<pre class="prototype">Window() = default</pre>
<blockquote>

<p>Creates an uninitialized value.</p>
</blockquote>
</div>

<div>
<pre class="prototype">explicit Window(HWND hwnd)</pre>
<blockquote>

<div>
<u>Postcondition</u>: <tt>Handle() == hwnd</tt>
</div>
</blockquote>
</div>

<div>
<pre class="prototype">static void Register(WNDCLASSEXW wcl)</pre>
<blockquote>

<p>Calls <tt>::RegisterClassExW()</tt>. Throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void Create(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWndName,
    DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent,
    HMENU hMenu, HINSTANCE hInstance, void *lpParam = nullptr)</pre>
<blockquote>

<p>Calls <tt>::CreateWindowExW()</tt> and updates the wrapped <tt>HWND</tt>
value. Throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void Create(const CREATESTRUCTW &amp;cs)</pre>
<blockquote>

<p>Calls <tt>Create()</tt> with the values specified in <tt>cs</tt>.
Throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">LRESULT SendMessage(UINT msg, WPARAM w = 0, LPARAM l = 0)</pre>
<blockquote>

<p>Calls <tt>::SendMessage()</tt> and returns the returned value.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void Update()</pre>
<blockquote>

<p>Calls <tt>::UpdateWindow()</tt>. Throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">bool Show(int nWinMode)</pre>
<blockquote>

<p>Calls <tt>::ShowWindow()</tt> and returns the returned value.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void Redraw(const RECT *rect = 0, HRGN hrgn = 0,
        UINT flags = RDW_INVALIDATE | RDW_UPDATENOW)</pre>
<blockquote>

<p>Calls <tt>::RedrawWindow()</tt>. Throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void GetRect(RECT &amp;r) const</pre>
<pre class="prototype">RECT GetRect() const</pre>
<blockquote>


<p>Calls <tt>::GetWindowRect()</tt>. Throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void GetClientRect(RECT &amp;r) const</pre>
<pre class="prototype">RECT GetClientRect() const</pre>
<blockquote>


<p>Calls <tt>::GetClientRect()</tt>. Throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void SetText(LPCWSTR st)</pre>
<blockquote>

<p>Calls <tt>::SetWindowTextW()</tt>. Throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void SetText(const char *st)</pre>
<blockquote>

<p>Converts the specified string from UTF-8 to UTF-16 then calls
<tt>SetText()</tt>. Throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">int GetText(LPWSTR st, int nMax) const</pre>
<blockquote>

<p>Calls <tt>::GetWindowTextW()</tt> and returns the returned value.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void SetPos(HWND hWndAfter, int x, int y, int w, int h, UINT uFlags)</pre>
<blockquote>

<p>Calls <tt>::SetWindowPos()</tt>. Throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void SetPos(int x, int y, int w, int h)</pre>
<blockquote>

<p>Sets position and size of the window. Throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void SetSize(int w, int h)</pre>
<blockquote>

<p>Sets size of the window. Throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void SetClientAreaSize(int w, int h)</pre>
<blockquote>

<p>Sets client area size of the window. Throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void MoveTo(int x, int y)</pre>
<blockquote>

<p>Moves the window to the specified position. Throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void MoveToCenter()</pre>
<blockquote>

<p>Moves the window to the center of the screen. Throws on error.</p>
</blockquote>
</div>

<div>
<pre class="prototype">HWND Handle() const</pre>
<pre class="prototype">operator HWND() const</pre>
<blockquote>


<p>Returns the wrapped value.</p>
</blockquote>
</div>

<div>
<pre class="prototype">void Handle(HWND hwnd)</pre>
<blockquote>

<div>
<u>Postcondition</u>: <tt>Handle() == hwnd</tt>
</div>
</blockquote>
</div>



<div class="section">Example</div>
<pre class="code">
// Skeleton Win32 API application
#include&lt;__vic/windows/window.h&gt;
#include&lt;windows.h&gt;
#include&lt;exception&gt;

extern "C" LRESULT CALLBACK WindowFunc(
    HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
        case WM_DESTROY:
            PostQuitMessage(0); break;
        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}
WPARAM skeleton_win32_app(int nWinMode)
{
    using __vic::windows::Window;
    static wchar_t szWinClassName[] = L"TestAppClass";

     Window wnd;
     HINSTANCE hInstance = ::GetModuleHandle(0);
     HICON hIcon = LoadIcon(NULL, IDI_APPLICATION);
     Window::Register(Window::Class(hInstance, szWinClassName, WindowFunc)
        .Icon(hIcon)
        .SmallIcon(hIcon)
        .Cursor(LoadCursor(0, IDC_ARROW))
        .Background((HBRUSH) GetStockObject(GRAY_BRUSH))
    );
    wnd.Create(Window::CreateParams(hInstance,
        szWinClassName, L"Skeleton Win32 application"));
    wnd.Show(nWinMode);
    wnd.Update();
    return __vic::windows::MessageLoop();
}
int WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR lpszArgs, int nWinMode)
{
    try
    {
        return skeleton_win32_app(nWinMode);
    }
    catch(const std::exception &amp;ex)
    {
        __vic::windows::MsgBox(ex.what(),
            "Application error", MB_OK | MB_ICONERROR);
    }
    return 1;
}
</pre>





<h3 id="windows--Window--Class">
<span class="h3_num">2.56.2</span><tt>windows::Window::Class</tt>
</h3>


<pre class="code">
struct windows::Window::Class : WNDCLASSEXW
{
    Class(HMODULE hInst, LPCWSTR name, WNDPROC wndProc)
    {
        cbSize = sizeof(WNDCLASSEXW);
        style = 0;
        lpfnWndProc = wndProc;
        cbClsExtra = cbWndExtra = 0;
        hInstance = hInst;
        hIcon = 0;
        hCursor = ::LoadCursorW(0, IDC_ARROW);
        hbrBackground = 0;
        lpszMenuName = 0;
        lpszClassName = name;
        hIconSm = 0;
    }
    Class &amp;Style(UINT v) { style = v; return *this; }
    Class &amp;ClsExtra(int v) { cbClsExtra = v; return *this; }
    Class &amp;WndExtra(int v) { cbWndExtra = v; return *this; }
    Class &amp;Instance(HINSTANCE v) { hInstance = v; return *this; }
    Class &amp;Icon(HICON v) { hIcon = v; return *this; }
    Class &amp;Cursor(HCURSOR v) { hCursor = v; return *this; }
    Class &amp;Background(HBRUSH v) { hbrBackground = v; return *this; }
    Class &amp;MenuName(LPCWSTR v) { lpszMenuName = v; return *this; }
    Class &amp;SmallIcon(HICON v) { hIconSm = v; return *this; }
};
</pre>

<p>Wrapper for <tt>WNDCLASSEXW</tt>.</p>

<div class="section">Example</div>
<pre class="code">
using __vic::windows::Windows;

Window::Register(Window::Class(hInstance, WndClassName, wndProc)
    .Icon(hIcon)
    .SmallIcon(hIcon)
    .Cursor(::LoadCursor(nullptr, IDC_ARROW))
    .Background((HBRUSH) ::GetStockObject(LTGRAY_BRUSH))
);
</pre>





<h3 id="windows--Window--CreateParams">
<span class="h3_num">2.56.3</span><tt>windows::Window::CreateParams</tt>
</h3>


<pre class="code">
struct windows::Window::CreateParams : CREATESTRUCTW
{
    CreateParams(HMODULE hInst, LPCWSTR lpClsName, LPCWSTR lpWndName = nullptr)
    {
        lpCreateParams = 0;
        hInstance = hInst;
        hMenu = 0;
        hwndParent = HWND_DESKTOP;
        cy = cx = y = x = CW_USEDEFAULT;
        style = WS_OVERLAPPEDWINDOW;
        lpszName = lpWndName;
        lpszClass = lpClsName;
        dwExStyle = 0;
    }
    CreateParams &amp;ExtraParam(void *v) { lpCreateParams = v; return *this; }
    CreateParams &amp;Instance(HINSTANCE v) { hInstance = v; return *this; }
    CreateParams &amp;Menu(HMENU v) { hMenu = v; return *this; }
    CreateParams &amp;Parent(HWND v) { hwndParent = v; return *this; }
    CreateParams &amp;Position(int X, int Y) { x = X; y = Y; return *this; }
    CreateParams &amp;Dimension(int w, int h) { cx = w; cy = h; return *this; }
    CreateParams &amp;Style(DWORD v) { style = v; return *this; }
    CreateParams &amp;ExStyle(DWORD v) { dwExStyle = v; return *this; }
};
</pre>

<p>Wrapper for <tt>CREATESTRUCTW</tt>.</p>

<div class="section">Example</div>
<pre class="code">
using __vic::windows::Windows;

Windows wnd;
wnd.Create(Window::CreateParams(hInstance, className, title).Position(x, y));
</pre>





<h3 id="windows--MsgBox">
<span class="h3_num">2.56.4</span><tt>windows::MsgBox()</tt>
</h3>


<pre class="code">
int windows::MsgBox(HWND hwnd,
    const wchar_t *msg, const wchar_t *title = L"", int t = MB_OK);
int windows::MsgBox(
    const wchar_t *msg, const wchar_t *title = L"", int t = MB_OK);
int windows::MsgBox(HWND hwnd,
    const char *msg, const char *title = "", int t = MB_OK);
int windows::MsgBox(
    const char *msg, const char *title = "", int t = MB_OK)
</pre>

<p>Calls <tt>::MessageBoxW()</tt> and returns the returned value. <tt>hwnd</tt>
parameter is <tt>NULL</tt> (<tt>HWND_DESKTOP</tt>) when not specified.
<tt>char</tt>-functions convert strings from UTF-8 to UTF-16.</p>




<h3 id="windows--MessageLoop">
<span class="h3_num">2.56.5</span><tt>windows::MessageLoop()</tt>
</h3>


<pre class="code">
WPARAM windows::MessageLoop(HWND hwnd = NULL);
</pre>

<p>Calls <tt>::GetMessage()</tt> while it returs nonzero (until
<tt>WM_QUIT</tt> is read). Then calls <tt>::TranslateMessage()</tt> and
<tt>::DispatchMessage()</tt> with the message. Returns <tt>MSG::wParam</tt>.</p>




<h3 id="windows--ProcessMessages">
<span class="h3_num">2.56.6</span><tt>windows::ProcessMessages()</tt>
</h3>


<pre class="code">
bool windows::ProcessMessages(HWND hwnd = NULL);
</pre>

<p>Like <a href="#windows--MessageLoop"><tt>windows::MessageLoop()</tt></a> but returns when message queue is
empty. Returns <tt>true</tt> if can be called again and <tt>false</tt> if
<tt>WM_QUIT</tt> message was read.</p>








<h1 id="build">
<span class="h1_num">3</span>Build and install</h1>

<p>To build the library you need one of supported C++ compilers and
<a href="https://www.gnu.org/software/make">GNU Make</a> utility version
3.82 or higher available in your command line environment (cmd).</p>

<p>Currently supported compilers are:</p>
<ul>
<li>GNU C++ v 4.7+ (MinGW) [<tt>gcc</tt>]</li>
<li>Clang v 5+ with MinGW [<tt>clang</tt>]</li>
<li>Clang v 5+ with Visual C++ [<tt>clang-cl</tt>]</li>
<li>Visual C++ v 15.8+ (Visual Studio 2017) [<tt>msvc</tt>]</li>
<li>Visual C++ v 7.1+ (Visual Studio 2003) [<tt>msvc</tt>] is supported
          but you may need to edit makefiles because of unsupported compiler
          options</li>
</ul>

<p>Go to <tt>src</tt> subdirectory and write:</p>
<pre class="code">
C:\&gt; gmake
</pre>
<p>The library file will be built for you.</p>

<p>C++17 is used by default but you can choose another language standard
version using <tt>std</tt> option. E.g. to build the library in C++98 mode
write:</p>
<pre class="code">
C:\&gt; gmake std=98
</pre>

<p>Available values include: 98, 11, 14, 17, 20 and 23.</p>

<p>Also you can choose the used compiler manually:</p>
<pre class="code">
C:\&gt; gmake compiler=gcc
</pre>

<p>Alternatively NMAKE utility can be used with Visual C++ and clang-cl instead
of gmake:</p>
<pre class="code">
C:\&gt; nmake -f Makefile.nmake compiler=msvc
</pre>

<p>Finally, to use the library you just need to copy the library file and
contents of <tt>include</tt> subdirectory to some place where compiler/linker
can find it.</p>



</div></body>
</html>
