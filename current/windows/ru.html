<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="ru"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>__vic's C++ library (Windows)</title><style type="text/css">
body {
	font-family: verdana, sans-serif;
	font-size: 10pt;
	background-color: #777777;
	margin: 0;
}
div.page-wrap {
	background-color: white;
	width: 210mm; /* A4 */
	margin: 0 auto;
	padding: 2mm 5mm;
}
p, div {
	margin-top: 6pt;
	margin-bottom: 0;
}
h1, h2, h3, h4, h5, h6 {
	font-weight: bold;
	margin-top: 9pt;
	margin-bottom: 12pt;
	margin-left: 0;
}
h1 { font-size: 16pt; }
h2 { font-size: 13pt; }
h3 { font-size: 11pt; }
h4 { font-size: 11pt; }
span.h1_num, span.h2_num {
	margin-right: 2em;
	font-family: sans-serif;
}
span.h3_num, span.h4_num {
	margin-right: 2em;
	font-weight: normal;
	font-size: smaller;
}
h1.main-title {
	font-size: 2em;
	font-weight: bold;
}
caption.toc {
	text-align: left;
	font-weight: bold;
	font-size: 13pt;
	margin-top: 9pt;
	margin-bottom: 12pt;
	margin-left: 0;
}
td.toc-chapter-no {
	padding-right: 1ex;
	vertical-align: top;
}
a { text-decoration: none; }
a:hover { text-decoration: underline; }
pre.code {
	background-color: #EEE;
	border: 1px solid #CCCCCC;
	padding-top: 6pt;
	padding-bottom: 6pt;
	padding-left: 2pt;
	font-family: monospace;
	font-size: 10pt;
	width: 17.3cm; /* 80ch */
}
pre.prototype {
	font-family: monospace;
	margin-top: 0;
	margin-bottom: 0;
}
div.section {
	font-weight: bold;
}
div.todo {
	color: red;
	font-weight: bold;
}
span.ver {
	font-size: smaller;
	color: #C0C0C0;
}
span.nonterminal {
	font-family: monospace;
	font-style: italic;
}
span.sign {
	color: #C0C0C0;
	font-family: monospace;
	font-size: 9pt;
	font-weight: bold;
}
blockquote {
	margin-top: 6pt;
	margin-bottom: 0;
	margin-right: 0;
}
blockquote * {
	margin-top: 0;
	margin-bottom: 0;
}
</style></head><body><div class="page-wrap"><h1 class="main-title">__vic's C++ library (Windows)<span class="ver"> v1.0 [Draft]</span></h1><table style="font-size:10pt;" cellspacing="0" cellpadding="0"><caption class="toc">Содержание</caption><tr><td class="toc-chapter-no">1</td><td><a href="#intro">Введение</a></td></tr><tr><td class="toc-chapter-no">1.1</td><td><a href="#why">Зачем эта библиотека была создана?</a></td></tr><tr><td class="toc-chapter-no">1.2</td><td><a href="#general-structure">Общая структура и использование</a></td></tr><tr><td colspan="2" style="font-size:5pt;"> </td></tr><tr><td class="toc-chapter-no">2</td><td><a href="#components-reference">Описание компонентов библиотеки</a></td></tr><tr><td class="toc-chapter-no">2.1</td><td><a href="#defs.h"><tt>__vic/defs.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.1.1</td><td style="padding-left:4ex"><a href="#nullptr"><tt>nullptr</tt> <span class="sign">[C++98 only]</span></a></td></tr><tr><td class="toc-chapter-no">2.1.2</td><td style="padding-left:4ex"><a href="#noexcept"><tt>noexcept</tt> <span class="sign">[C++98 only]</span></a></td></tr><tr><td class="toc-chapter-no">2.1.3</td><td style="padding-left:4ex"><a href="#array_size"><tt>array_size()</tt></a></td></tr><tr><td class="toc-chapter-no">2.1.4</td><td style="padding-left:4ex"><a href="#non_copyable"><tt>non_copyable</tt></a></td></tr><tr><td class="toc-chapter-no">2.1.5</td><td style="padding-left:4ex"><a href="#non_heap_allocatable"><tt>non_heap_allocatable</tt></a></td></tr><tr><td class="toc-chapter-no">2.1.6</td><td style="padding-left:4ex"><a href="#std--move"><tt>std::move()</tt>, <tt>std::forward()</tt>, <tt>std::swap()</tt>
<span class="sign">[C++11]</span></a></td></tr><tr><td class="toc-chapter-no">2.1.7</td><td style="padding-left:4ex"><a href="#VIC_SWAP_HEADER"><tt>__VIC_SWAP_HEADER</tt></a></td></tr><tr><td class="toc-chapter-no">2.1.8</td><td style="padding-left:4ex"><a href="#platform-dependent-macros">Системно-зависимые макроопределения</a></td></tr><tr><td class="toc-chapter-no">2.2</td><td><a href="#ascii.h"><tt>__vic/ascii.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.2.1</td><td style="padding-left:4ex"><a href="#ascii--is-functions"><tt>ascii::is</tt>-функции</a></td></tr><tr><td class="toc-chapter-no">2.2.2</td><td style="padding-left:4ex"><a href="#ascii--todigit"><tt>ascii::todigit()</tt></a></td></tr><tr><td class="toc-chapter-no">2.2.3</td><td style="padding-left:4ex"><a href="#ascii--toxdigit"><tt>ascii::toxdigit_upper()</tt>, <tt>ascii::toxdigit_lower()</tt></a></td></tr><tr><td class="toc-chapter-no">2.2.4</td><td style="padding-left:4ex"><a href="#ascii--digit_to_number"><tt>ascii::digit_to_number()</tt></a></td></tr><tr><td class="toc-chapter-no">2.2.5</td><td style="padding-left:4ex"><a href="#ascii--xdigit_to_number"><tt>ascii::xdigit_to_number()</tt></a></td></tr><tr><td class="toc-chapter-no">2.2.6</td><td style="padding-left:4ex"><a href="#ascii--tolower-char"><tt>ascii::tolower(char)</tt>, <tt>ascii::toupper(char)</tt></a></td></tr><tr><td class="toc-chapter-no">2.2.7</td><td style="padding-left:4ex"><a href="#ascii--equal_icase-char"><tt>ascii::equal_icase(char,char)</tt></a></td></tr><tr><td class="toc-chapter-no">2.3</td><td><a href="#ascii_string.h"><tt>__vic/ascii_string.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.3.1</td><td style="padding-left:4ex"><a href="#ascii--tolower-str"><tt>ascii::tolower()</tt></a></td></tr><tr><td class="toc-chapter-no">2.3.2</td><td style="padding-left:4ex"><a href="#ascii--toupper-str"><tt>ascii::toupper()</tt></a></td></tr><tr><td class="toc-chapter-no">2.3.3</td><td style="padding-left:4ex"><a href="#ascii--equal_icase-str"><tt>ascii::equal_icase()</tt></a></td></tr><tr><td class="toc-chapter-no">2.4</td><td><a href="#base16.h"><tt>__vic/base16.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.4.1</td><td style="padding-left:4ex"><a href="#base16"><tt>base16</tt></a></td></tr><tr><td class="toc-chapter-no">2.4.2</td><td style="padding-left:4ex"><a href="#base16--bad_format"><tt>base16::bad_format</tt></a></td></tr><tr><td class="toc-chapter-no">2.4.3</td><td style="padding-left:4ex"><a href="#base16--bad_digit"><tt>base16::bad_digit</tt></a></td></tr><tr><td class="toc-chapter-no">2.4.4</td><td style="padding-left:4ex"><a href="#base16--bad_length"><tt>base16::bad_length</tt></a></td></tr><tr><td class="toc-chapter-no">2.4.5</td><td style="padding-left:4ex"><a href="#base16--status"><tt>base16::status</tt></a></td></tr><tr><td class="toc-chapter-no">2.4.6</td><td style="padding-left:4ex"><a href="#base16--encode_upper"><tt>base16::encode_upper()</tt></a></td></tr><tr><td class="toc-chapter-no">2.4.7</td><td style="padding-left:4ex"><a href="#base16--encode_lower"><tt>base16::encode_lower()</tt></a></td></tr><tr><td class="toc-chapter-no">2.4.8</td><td style="padding-left:4ex"><a href="#base16--decode"><tt>base16::decode()</tt></a></td></tr><tr><td class="toc-chapter-no">2.4.9</td><td style="padding-left:4ex"><a href="#base16--try_decode"><tt>base16::try_decode()</tt></a></td></tr><tr><td class="toc-chapter-no">2.5</td><td><a href="#base64.h"><tt>__vic/base64.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.5.1</td><td style="padding-left:4ex"><a href="#base64"><tt>base64</tt></a></td></tr><tr><td class="toc-chapter-no">2.5.2</td><td style="padding-left:4ex"><a href="#base64--bad_format"><tt>base64::bad_format</tt></a></td></tr><tr><td class="toc-chapter-no">2.5.3</td><td style="padding-left:4ex"><a href="#base64--bad_digit"><tt>base64::bad_digit</tt></a></td></tr><tr><td class="toc-chapter-no">2.5.4</td><td style="padding-left:4ex"><a href="#base64--bad_length"><tt>base64::bad_length</tt></a></td></tr><tr><td class="toc-chapter-no">2.5.5</td><td style="padding-left:4ex"><a href="#base64--status"><tt>base64::status</tt></a></td></tr><tr><td class="toc-chapter-no">2.5.6</td><td style="padding-left:4ex"><a href="#base64--encode"><tt>base64::encode()</tt></a></td></tr><tr><td class="toc-chapter-no">2.5.7</td><td style="padding-left:4ex"><a href="#base64--decode"><tt>base64::decode()</tt></a></td></tr><tr><td class="toc-chapter-no">2.5.8</td><td style="padding-left:4ex"><a href="#base64--try_decode"><tt>base64::try_decode()</tt></a></td></tr><tr><td class="toc-chapter-no">2.5.9</td><td style="padding-left:4ex"><a href="#base64--encoded_length"><tt>base64::encoded_length()</tt></a></td></tr><tr><td class="toc-chapter-no">2.5.10</td><td style="padding-left:4ex"><a href="#base64--max_decoded_length"><tt>base64::max_decoded_length()</tt></a></td></tr><tr><td class="toc-chapter-no">2.6</td><td><a href="#bin_file.h"><tt>__vic/bin_file.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.6.1</td><td style="padding-left:4ex"><a href="#bin_file"><tt>bin_file</tt></a></td></tr><tr><td class="toc-chapter-no">2.7</td><td><a href="#bits.h"><tt>__vic/bits.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.7.1</td><td style="padding-left:4ex"><a href="#lo_nibble"><tt>lo_nibble()</tt>, <tt>hi_nibble()</tt></a></td></tr><tr><td class="toc-chapter-no">2.7.2</td><td style="padding-left:4ex"><a href="#msb_ones"><tt>msb_ones()</tt>, <tt>lsb_ones()</tt></a></td></tr><tr><td class="toc-chapter-no">2.7.3</td><td style="padding-left:4ex"><a href="#get_lsbs"><tt>get_lsbs()</tt></a></td></tr><tr><td class="toc-chapter-no">2.7.4</td><td style="padding-left:4ex"><a href="#ord"><tt>ord()</tt></a></td></tr><tr><td class="toc-chapter-no">2.7.5</td><td style="padding-left:4ex"><a href="#popcount"><tt>popcount()</tt></a></td></tr><tr><td class="toc-chapter-no">2.7.6</td><td style="padding-left:4ex"><a href="#msb_position"><tt>msb_position()</tt></a></td></tr><tr><td class="toc-chapter-no">2.7.7</td><td style="padding-left:4ex"><a href="#ispow2"><tt>ispow2()</tt></a></td></tr><tr><td class="toc-chapter-no">2.7.8</td><td style="padding-left:4ex"><a href="#ceil2"><tt>ceil2()</tt></a></td></tr><tr><td class="toc-chapter-no">2.7.9</td><td style="padding-left:4ex"><a href="#floor2"><tt>floor2()</tt></a></td></tr><tr><td class="toc-chapter-no">2.7.10</td><td style="padding-left:4ex"><a href="#ceil_log2"><tt>ceil_log2()</tt></a></td></tr><tr><td class="toc-chapter-no">2.7.11</td><td style="padding-left:4ex"><a href="#floor_log2"><tt>floor_log2()</tt></a></td></tr><tr><td class="toc-chapter-no">2.7.12</td><td style="padding-left:4ex"><a href="#rotl"><tt>rotl()</tt>, <tt>rotr()</tt></a></td></tr><tr><td class="toc-chapter-no">2.7.13</td><td style="padding-left:4ex"><a href="#swapped_nibbles"><tt>swapped_nibbles()</tt></a></td></tr><tr><td class="toc-chapter-no">2.8</td><td><a href="#date_time.h"><tt>__vic/date_time.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.8.1</td><td style="padding-left:4ex"><a href="#is_leap_year"><tt>is_leap_year()</tt></a></td></tr><tr><td class="toc-chapter-no">2.8.2</td><td style="padding-left:4ex"><a href="#days_in_month"><tt>days_in_month()</tt></a></td></tr><tr><td class="toc-chapter-no">2.8.3</td><td style="padding-left:4ex"><a href="#days_between_years"><tt>days_between_years()</tt></a></td></tr><tr><td class="toc-chapter-no">2.8.4</td><td style="padding-left:4ex"><a href="#invalid_date"><tt>invalid_date</tt></a></td></tr><tr><td class="toc-chapter-no">2.8.5</td><td style="padding-left:4ex"><a href="#validate_date_time"><tt>validate_date()</tt>, <tt>validate_time()</tt>,
<tt>validate_date_time()</tt></a></td></tr><tr><td class="toc-chapter-no">2.9</td><td><a href="#endian.h"><tt>__vic/endian.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.9.1</td><td style="padding-left:4ex"><a href="#endianness"><tt>endianness</tt></a></td></tr><tr><td class="toc-chapter-no">2.9.2</td><td style="padding-left:4ex"><a href="#endian--from"><tt>endian::from_...()</tt></a></td></tr><tr><td class="toc-chapter-no">2.9.3</td><td style="padding-left:4ex"><a href="#endian--to"><tt>endian::to_...()</tt></a></td></tr><tr><td class="toc-chapter-no">2.9.4</td><td style="padding-left:4ex"><a href="#swab"><tt>swab16()</tt>, <tt>swab32()</tt>, <tt>swab64()</tt></a></td></tr><tr><td class="toc-chapter-no">2.10</td><td><a href="#error.h"><tt>__vic/error.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.10.1</td><td style="padding-left:4ex"><a href="#exception"><tt>exception</tt></a></td></tr><tr><td class="toc-chapter-no">2.10.2</td><td style="padding-left:4ex"><a href="#libc_error"><tt>libc_error</tt></a></td></tr><tr><td class="toc-chapter-no">2.11</td><td><a href="#fixed_vector.h"><tt>__vic/fixed_vector.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.11.1</td><td style="padding-left:4ex"><a href="#fixed_vector"><tt>fixed_vector</tt></a></td></tr><tr><td class="toc-chapter-no">2.12</td><td><a href="#fs.h"><tt>__vic/fs.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.12.1</td><td style="padding-left:4ex"><a href="#path_exists"><tt>path_exists()</tt>, <tt>file_exists()</tt>, <tt>dir_exists()</tt>
</a></td></tr><tr><td class="toc-chapter-no">2.12.2</td><td style="padding-left:4ex"><a href="#mkdir"><tt>mkdir()</tt>, <tt>mkdir_if_absent()</tt></a></td></tr><tr><td class="toc-chapter-no">2.12.3</td><td style="padding-left:4ex"><a href="#rmdir"><tt>rmdir()</tt>, <tt>rmdir_if_exists()</tt></a></td></tr><tr><td class="toc-chapter-no">2.12.4</td><td style="padding-left:4ex"><a href="#get_current_dir"><tt>get_current_dir()</tt></a></td></tr><tr><td class="toc-chapter-no">2.12.5</td><td style="padding-left:4ex"><a href="#remove_file"><tt>remove_file()</tt>, <tt>remove_file_if_exists()</tt>,
<tt>remove_file_nt()</tt></a></td></tr><tr><td class="toc-chapter-no">2.12.6</td><td style="padding-left:4ex"><a href="#copy_file"><tt>copy_file()</tt>, <tt>copy_file_if_exists()</tt>,
<tt>copy_file_replace()</tt>, <tt>copy_file_replace_if_exists()</tt></a></td></tr><tr><td class="toc-chapter-no">2.12.7</td><td style="padding-left:4ex"><a href="#move_file"><tt>move_file()</tt>, <tt>move_file_if_exists()</tt>,
<tt>move_file_replace()</tt>, <tt>move_file_replace_if_exists()</tt></a></td></tr><tr><td class="toc-chapter-no">2.12.8</td><td style="padding-left:4ex"><a href="#rename_file"><tt>rename_file()</tt>, <tt>rename_file_if_exists()</tt>,
    <tt>rename_file_replace()</tt>, <tt>rename_file_replace_if_exists()</tt></a></td></tr><tr><td class="toc-chapter-no">2.12.9</td><td style="padding-left:4ex"><a href="#file_size"><tt>file_size()</tt></a></td></tr><tr><td class="toc-chapter-no">2.13</td><td><a href="#iterator.h"><tt>__vic/iterator.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.13.1</td><td style="padding-left:4ex"><a href="#begin-array"><tt>begin(T[])</tt>, <tt>end(T[])</tt>, <tt>cbegin(T[])</tt>,
<tt>cend(T[])</tt></a></td></tr><tr><td class="toc-chapter-no">2.13.2</td><td style="padding-left:4ex"><a href="#advance"><tt>advance()</tt></a></td></tr><tr><td class="toc-chapter-no">2.13.3</td><td style="padding-left:4ex"><a href="#next"><tt>next()</tt>, <tt>prev()</tt></a></td></tr><tr><td class="toc-chapter-no">2.14</td><td><a href="#logger.h"><tt>__vic/logger.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.14.1</td><td style="padding-left:4ex"><a href="#logger"><tt>logger</tt></a></td></tr><tr><td class="toc-chapter-no">2.15</td><td><a href="#memory.h"><tt>__vic/memory.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.15.1</td><td style="padding-left:4ex"><a href="#load_unaligned"><tt>load_unaligned()</tt></a></td></tr><tr><td class="toc-chapter-no">2.16</td><td><a href="#mutex.h"><tt>__vic/mutex.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.16.1</td><td style="padding-left:4ex"><a href="#mutex"><tt>mutex</tt></a></td></tr><tr><td class="toc-chapter-no">2.16.2</td><td style="padding-left:4ex"><a href="#mutex_lock"><tt>mutex_lock</tt></a></td></tr><tr><td class="toc-chapter-no">2.17</td><td><a href="#packon.h"><tt>__vic/packon.h</tt> &#38; <tt>__vic/packoff.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.18</td><td><a href="#readers"><tt>__vic/readers/</tt></a></td></tr><tr><td class="toc-chapter-no">2.18.1</td><td style="padding-left:4ex"><a href="#reader-concept"><tt>Reader</tt> concept</a></td></tr><tr><td class="toc-chapter-no">2.18.2</td><td style="padding-left:4ex"><a href="#iterator_reader"><tt>iterator_reader</tt></a></td></tr><tr><td class="toc-chapter-no">2.18.3</td><td style="padding-left:4ex"><a href="#iterator_reader_n"><tt>iterator_reader_n</tt></a></td></tr><tr><td class="toc-chapter-no">2.18.4</td><td style="padding-left:4ex"><a href="#container_reader"><tt>container_reader</tt></a></td></tr><tr><td class="toc-chapter-no">2.18.5</td><td style="padding-left:4ex"><a href="#cstring_reader"><tt>cstring_reader</tt></a></td></tr><tr><td class="toc-chapter-no">2.18.6</td><td style="padding-left:4ex"><a href="#string_reader"><tt>string_reader</tt></a></td></tr><tr><td class="toc-chapter-no">2.18.7</td><td style="padding-left:4ex"><a href="#cstream_reader"><tt>cstream_reader</tt></a></td></tr><tr><td class="toc-chapter-no">2.19</td><td><a href="#readonly_cstring.h"><tt>__vic/readonly_cstring.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.19.1</td><td style="padding-left:4ex"><a href="#readonly_cstring"><tt>readonly_cstring</tt></a></td></tr><tr><td class="toc-chapter-no">2.20</td><td><a href="#set_of_chars.h"><tt>__vic/set_of_chars.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.20.1</td><td style="padding-left:4ex"><a href="#set_of_chars"><tt>set_of_chars</tt></a></td></tr><tr><td class="toc-chapter-no">2.21</td><td><a href="#stdint.h"><tt>__vic/stdint.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.21.1</td><td style="padding-left:4ex"><a href="#intN_t">Целые с точной длиной</a></td></tr><tr><td class="toc-chapter-no">2.21.2</td><td style="padding-left:4ex"><a href="#int_leastN_t">Целые с минимальной длиной</a></td></tr><tr><td class="toc-chapter-no">2.21.3</td><td style="padding-left:4ex"><a href="#int_fastN_t">Быстрейшие целые с минимальной длиной</a></td></tr><tr><td class="toc-chapter-no">2.21.4</td><td style="padding-left:4ex"><a href="#intmax_t">Целые наибольшего размера</a></td></tr><tr><td class="toc-chapter-no">2.21.5</td><td style="padding-left:4ex"><a href="#intptr_t">Целые, вмещающие указатели на объекты</a></td></tr><tr><td class="toc-chapter-no">2.21.6</td><td style="padding-left:4ex"><a href="#int_exactly_bytes"><tt>int_exactly_bytes&#60;&gt;</tt>, <tt>uint_exactly_bytes&#60;&gt;</tt></a></td></tr><tr><td class="toc-chapter-no">2.22</td><td><a href="#stdio_file.h"><tt>__vic/stdio_file.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.22.1</td><td style="padding-left:4ex"><a href="#stdio_file"><tt>stdio_file</tt></a></td></tr><tr><td class="toc-chapter-no">2.22.2</td><td style="padding-left:4ex"><a href="#read-FILE-char"><tt>read(std::FILE, char&#38;)</tt>,
    <tt>read(std::FILE, unsigned char&#38;)</tt></a></td></tr><tr><td class="toc-chapter-no">2.22.3</td><td style="padding-left:4ex"><a href="#write-FILE-char"><tt>write(std::FILE, char)</tt></a></td></tr><tr><td class="toc-chapter-no">2.22.4</td><td style="padding-left:4ex"><a href="#getline-FILE"><tt>getline(std::FILE)</tt></a></td></tr><tr><td class="toc-chapter-no">2.23</td><td><a href="#str2num.h"><tt>__vic/str2num.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.23.1</td><td style="padding-left:4ex"><a href="#decimal_to_number"><tt>decimal_to_number()</tt></a></td></tr><tr><td class="toc-chapter-no">2.23.2</td><td style="padding-left:4ex"><a href="#decimal_to_number_range"><tt>decimal_to_number_range()</tt></a></td></tr><tr><td class="toc-chapter-no">2.23.3</td><td style="padding-left:4ex"><a href="#decimal_parser"><tt>decimal_parser</tt></a></td></tr><tr><td class="toc-chapter-no">2.23.4</td><td style="padding-left:4ex"><a href="#number_parse_status"><tt>number_parse_status</tt></a></td></tr><tr><td class="toc-chapter-no">2.24</td><td><a href="#string_buffer.h"><tt>__vic/string_buffer.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.24.1</td><td style="padding-left:4ex"><a href="#string_buffer"><tt>string_buffer</tt></a></td></tr><tr><td class="toc-chapter-no">2.25</td><td><a href="#string_ref.h"><tt>__vic/string_ref.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.25.1</td><td style="padding-left:4ex"><a href="#string_ref"><tt>string_ref</tt></a></td></tr><tr><td class="toc-chapter-no">2.26</td><td><a href="#string_utils.h"><tt>__vic/string_utils.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.26.1</td><td style="padding-left:4ex"><a href="#trim">Набор функций <tt>trim</tt></a></td></tr><tr><td class="toc-chapter-no">2.26.2</td><td style="padding-left:4ex"><a href="#sift"><tt>sift()</tt></a></td></tr><tr><td class="toc-chapter-no">2.26.3</td><td style="padding-left:4ex"><a href="#sift_if"><tt>sift_if()</tt></a></td></tr><tr><td class="toc-chapter-no">2.26.4</td><td style="padding-left:4ex"><a href="#pad_front"><tt>pad_front()</tt></a></td></tr><tr><td class="toc-chapter-no">2.26.5</td><td style="padding-left:4ex"><a href="#pad_back"><tt>pad_back()</tt></a></td></tr><tr><td class="toc-chapter-no">2.26.6</td><td style="padding-left:4ex"><a href="#starts_with"><tt>starts_with()</tt></a></td></tr><tr><td class="toc-chapter-no">2.26.7</td><td style="padding-left:4ex"><a href="#ends_with"><tt>ends_with()</tt></a></td></tr><tr><td class="toc-chapter-no">2.27</td><td><a href="#tchar.h"><tt>__vic/tchar.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.27.1</td><td style="padding-left:4ex"><a href="#tchar--length"><tt>tchar::length()</tt></a></td></tr><tr><td class="toc-chapter-no">2.27.2</td><td style="padding-left:4ex"><a href="#tchar--empty"><tt>tchar::empty()</tt></a></td></tr><tr><td class="toc-chapter-no">2.27.3</td><td style="padding-left:4ex"><a href="#tchar--end"><tt>tchar::end()</tt></a></td></tr><tr><td class="toc-chapter-no">2.27.4</td><td style="padding-left:4ex"><a href="#tchar--compare"><tt>tchar::compare()</tt></a></td></tr><tr><td class="toc-chapter-no">2.27.5</td><td style="padding-left:4ex"><a href="#tchar--equal"><tt>tchar::equal()</tt></a></td></tr><tr><td class="toc-chapter-no">2.27.6</td><td style="padding-left:4ex"><a href="#tchar--copy"><tt>tchar::copy()</tt></a></td></tr><tr><td class="toc-chapter-no">2.27.7</td><td style="padding-left:4ex"><a href="#tchar--move"><tt>tchar::move()</tt></a></td></tr><tr><td class="toc-chapter-no">2.27.8</td><td style="padding-left:4ex"><a href="#tchar--concat"><tt>tchar::concat()</tt></a></td></tr><tr><td class="toc-chapter-no">2.27.9</td><td style="padding-left:4ex"><a href="#tchar--find"><tt>tchar::find()</tt></a></td></tr><tr><td class="toc-chapter-no">2.27.10</td><td style="padding-left:4ex"><a href="#tchar--rfind"><tt>tchar::rfind()</tt></a></td></tr><tr><td class="toc-chapter-no">2.27.11</td><td style="padding-left:4ex"><a href="#tchar--find_if"><tt>tchar::find_if()</tt></a></td></tr><tr><td class="toc-chapter-no">2.27.12</td><td style="padding-left:4ex"><a href="#tchar--find_if_not"><tt>tchar::find_if_not()</tt></a></td></tr><tr><td class="toc-chapter-no">2.27.13</td><td style="padding-left:4ex"><a href="#tchar--rfind_if"><tt>tchar::rfind_if()</tt></a></td></tr><tr><td class="toc-chapter-no">2.27.14</td><td style="padding-left:4ex"><a href="#tchar--rfind_if_not"><tt>tchar::rfind_if_not()</tt></a></td></tr><tr><td class="toc-chapter-no">2.27.15</td><td style="padding-left:4ex"><a href="#tchar--find_first_of"><tt>tchar::find_first_of()</tt></a></td></tr><tr><td class="toc-chapter-no">2.27.16</td><td style="padding-left:4ex"><a href="#tchar--find_first_not_of"><tt>tchar::find_first_not_of()</tt></a></td></tr><tr><td class="toc-chapter-no">2.27.17</td><td style="padding-left:4ex"><a href="#tchar--find_last_of"><tt>tchar::find_last_of()</tt></a></td></tr><tr><td class="toc-chapter-no">2.27.18</td><td style="padding-left:4ex"><a href="#tchar--find_last_not_of"><tt>tchar::find_last_not_of()</tt></a></td></tr><tr><td class="toc-chapter-no">2.27.19</td><td style="padding-left:4ex"><a href="#tchar--skip"><tt>tchar::skip()</tt></a></td></tr><tr><td class="toc-chapter-no">2.28</td><td><a href="#thread.h"><tt>__vic/thread.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.28.1</td><td style="padding-left:4ex"><a href="#thread"><tt>thread</tt></a></td></tr><tr><td class="toc-chapter-no">2.28.2</td><td style="padding-left:4ex"><a href="#thread--id"><tt>thread::id</tt></a></td></tr><tr><td class="toc-chapter-no">2.28.3</td><td style="padding-left:4ex"><a href="#this_thread"><tt>this_thread</tt></a></td></tr><tr><td class="toc-chapter-no">2.29</td><td><a href="#throw_errno.h"><tt>__vic/throw_errno.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.29.1</td><td style="padding-left:4ex"><a href="#throw_errno"><tt>throw_errno()</tt></a></td></tr><tr><td class="toc-chapter-no">2.30</td><td><a href="#to_text.h"><tt>__vic/to_text.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.30.1</td><td style="padding-left:4ex"><a href="#to_text_append"><tt>to_text_append()</tt></a></td></tr><tr><td class="toc-chapter-no">2.31</td><td><a href="#type_traits.h"><tt>__vic/type_traits.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.31.1</td><td style="padding-left:4ex"><a href="#integral_constant"><tt>integral_constant</tt></a></td></tr><tr><td class="toc-chapter-no">2.31.2</td><td style="padding-left:4ex"><a href="#true_type"><tt>true_type</tt></a></td></tr><tr><td class="toc-chapter-no">2.31.3</td><td style="padding-left:4ex"><a href="#false_type"><tt>false_type</tt></a></td></tr><tr><td class="toc-chapter-no">2.31.4</td><td style="padding-left:4ex"><a href="#is_same"><tt>is_same</tt></a></td></tr><tr><td class="toc-chapter-no">2.31.5</td><td style="padding-left:4ex"><a href="#is_const"><tt>is_const</tt></a></td></tr><tr><td class="toc-chapter-no">2.31.6</td><td style="padding-left:4ex"><a href="#is_signed_integer"><tt>is_signed_integer</tt></a></td></tr><tr><td class="toc-chapter-no">2.31.7</td><td style="padding-left:4ex"><a href="#is_unsigned_integer"><tt>is_unsigned_integer</tt></a></td></tr><tr><td class="toc-chapter-no">2.31.8</td><td style="padding-left:4ex"><a href="#remove_const"><tt>remove_const</tt></a></td></tr><tr><td class="toc-chapter-no">2.31.9</td><td style="padding-left:4ex"><a href="#remove_volatile"><tt>remove_volatile</tt></a></td></tr><tr><td class="toc-chapter-no">2.31.10</td><td style="padding-left:4ex"><a href="#remove_cv"><tt>remove_cv</tt></a></td></tr><tr><td class="toc-chapter-no">2.31.11</td><td style="padding-left:4ex"><a href="#remove_reference"><tt>remove_reference</tt></a></td></tr><tr><td class="toc-chapter-no">2.31.12</td><td style="padding-left:4ex"><a href="#remove_cvref"><tt>remove_cvref</tt></a></td></tr><tr><td class="toc-chapter-no">2.31.13</td><td style="padding-left:4ex"><a href="#remove_pointer"><tt>remove_pointer</tt></a></td></tr><tr><td class="toc-chapter-no">2.31.14</td><td style="padding-left:4ex"><a href="#enable_if"><tt>enable_if</tt>, <tt>disable_if</tt></a></td></tr><tr><td class="toc-chapter-no">2.31.15</td><td style="padding-left:4ex"><a href="#index_sequence"><tt>index_sequence</tt>, <tt>make_index_sequence</tt> <span class="sign">[C++11]</span></a></td></tr><tr><td class="toc-chapter-no">2.32</td><td><a href="#unicode.h"><tt>__vic/unicode.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.32.1</td><td style="padding-left:4ex"><a href="#unicode_t"><tt>unicode_t</tt></a></td></tr><tr><td class="toc-chapter-no">2.32.2</td><td style="padding-left:4ex"><a href="#utf_transcode"><tt>utf_transcode()</tt></a></td></tr><tr><td class="toc-chapter-no">2.32.3</td><td style="padding-left:4ex"><a href="#unicode_code_point_constants"><tt>Code point constants</tt></a></td></tr><tr><td class="toc-chapter-no">2.33</td><td><a href="#utf8.status.h"><tt>__vic/utf8/status.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.33.1</td><td style="padding-left:4ex"><a href="#utf8--status"><tt>utf8::status</tt></a></td></tr><tr><td class="toc-chapter-no">2.33.2</td><td style="padding-left:4ex"><a href="#utf8--is_error"><tt>utf8::is_error()</tt></a></td></tr><tr><td class="toc-chapter-no">2.33.3</td><td style="padding-left:4ex"><a href="#utf8--throw_if_error"><tt>utf8::throw_if_error()</tt></a></td></tr><tr><td class="toc-chapter-no">2.34</td><td><a href="#utf8.exceptions.h"><tt>__vic/utf8/exceptions.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.35</td><td><a href="#utf8.reader.h"><tt>__vic/utf8/reader.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.35.1</td><td style="padding-left:4ex"><a href="#utf8--reader"><tt>utf8::reader</tt></a></td></tr><tr><td class="toc-chapter-no">2.36</td><td><a href="#utf8.writer.h"><tt>__vic/utf8/writer.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.36.1</td><td style="padding-left:4ex"><a href="#utf8--writer"><tt>utf8::writer</tt></a></td></tr><tr><td class="toc-chapter-no">2.37</td><td><a href="#utf16.defs.h"><tt>__vic/utf16/defs.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.37.1</td><td style="padding-left:4ex"><a href="#utf16--code_unit_t"><tt>utf16::code_unit_t</tt></a></td></tr><tr><td class="toc-chapter-no">2.38</td><td><a href="#utf16.status.h"><tt>__vic/utf16/status.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.38.1</td><td style="padding-left:4ex"><a href="#utf16--status"><tt>utf16::status</tt></a></td></tr><tr><td class="toc-chapter-no">2.38.2</td><td style="padding-left:4ex"><a href="#utf16--is_error"><tt>utf16::is_error()</tt></a></td></tr><tr><td class="toc-chapter-no">2.38.3</td><td style="padding-left:4ex"><a href="#utf16--throw_if_error"><tt>utf16::throw_if_error()</tt></a></td></tr><tr><td class="toc-chapter-no">2.39</td><td><a href="#utf16.exceptions.h"><tt>__vic/utf16/exceptions.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.40</td><td><a href="#utf16.reader.h"><tt>__vic/utf16/reader.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.40.1</td><td style="padding-left:4ex"><a href="#utf16--reader"><tt>utf16::reader</tt></a></td></tr><tr><td class="toc-chapter-no">2.41</td><td><a href="#utf16.writer.h"><tt>__vic/utf16/writer.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.41.1</td><td style="padding-left:4ex"><a href="#utf16--writer"><tt>utf16::writer</tt></a></td></tr><tr><td class="toc-chapter-no">2.42</td><td><a href="#waitable_event.h"><tt>__vic/waitable_event.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.42.1</td><td style="padding-left:4ex"><a href="#waitable_event"><tt>waitable_event</tt></a></td></tr><tr><td class="toc-chapter-no">2.43</td><td><a href="#writers"><tt>__vic/writers/</tt></a></td></tr><tr><td class="toc-chapter-no">2.43.1</td><td style="padding-left:4ex"><a href="#writer-concept"><tt>Writer</tt> concept</a></td></tr><tr><td class="toc-chapter-no">2.43.2</td><td style="padding-left:4ex"><a href="#null_writer"><tt>null_writer</tt></a></td></tr><tr><td class="toc-chapter-no">2.43.3</td><td style="padding-left:4ex"><a href="#push_back_writer"><tt>push_back_writer</tt></a></td></tr><tr><td class="toc-chapter-no">2.43.4</td><td style="padding-left:4ex"><a href="#iterator_writer"><tt>iterator_writer</tt></a></td></tr><tr><td class="toc-chapter-no">2.43.5</td><td style="padding-left:4ex"><a href="#string_writer"><tt>string_writer</tt></a></td></tr><tr><td class="toc-chapter-no">2.43.6</td><td style="padding-left:4ex"><a href="#cstream_writer"><tt>cstream_writer</tt></a></td></tr><tr><td class="toc-chapter-no">2.44</td><td><a href="#windows.critical_section.h"><tt>__vic/windows/critical_section.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.44.1</td><td style="padding-left:4ex"><a href="#windows--CriticalSection"><tt>windows::CriticalSection</tt></a></td></tr><tr><td class="toc-chapter-no">2.44.2</td><td style="padding-left:4ex"><a href="#windows--CSGuard"><tt>windows::CSGuard</tt></a></td></tr><tr><td class="toc-chapter-no">2.45</td><td><a href="#windows.error.h"><tt>__vic/windows/error.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.45.1</td><td style="padding-left:4ex"><a href="#windows--error"><tt>windows::error</tt></a></td></tr><tr><td class="toc-chapter-no">2.46</td><td><a href="#windows.event.h"><tt>__vic/windows/event.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.46.1</td><td style="padding-left:4ex"><a href="#windows--event"><tt>windows::event</tt></a></td></tr><tr><td class="toc-chapter-no">2.47</td><td><a href="#windows.find_file.h"><tt>__vic/windows/find_file.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.47.1</td><td style="padding-left:4ex"><a href="#windows--find_file"><tt>windows::find_file</tt></a></td></tr><tr><td class="toc-chapter-no">2.48</td><td><a href="#windows.handle.h"><tt>__vic/windows/handle.h</tt></a></td></tr><tr><td class="toc-chapter-no">2.48.1</td><td style="padding-left:4ex"><a href="#windows--Handle"><tt>windows::Handle</tt></a></td></tr><tr><td class="toc-chapter-no">2.48.2</td><td style="padding-left:4ex"><a href="#windows--WaitAbandoned"><tt>windows::WaitAbandoned</tt></a></td></tr><tr><td colspan="2" style="font-size:5pt;"> </td></tr><tr><td class="toc-chapter-no">3</td><td><a href="#build">Сборка и установка</a></td></tr><tr><td colspan="2" style="font-size:5pt;"> </td></tr></table><h1 id="intro"><span class="h1_num">1</span>Введение</h1><h2 id="why"><span class="h2_num">1.1</span>Зачем эта библиотека была создана?</h2><p>Данная библиотека содержит компоненты, которых мне не хватает в
Стандартной библиотеке C++. Это, своего рода, мой личный
<a href="http://www.boost.org/">Boost</a>.</p><p>Дополнительно, это уровень абстракции, который скрывает детали реализации,
ошибки и причуды различных ОС, компиляторов и реализаций Стандартной
библиотеки.</p><h2 id="general-structure"><span class="h2_num">1.2</span>Общая структура и использование</h2><p>Структурными единицами самого верхнего уровня в библиотеке являются
заголовочные файлы и файл библиотеки (или архив) - <tt>lib__vic.a</tt> или
<tt>__vic.lib</tt>. Обычно файл библиотеки имеет дополнительный суффикс,
вроде <tt>lib__vic14.a</tt>. Все заголовочные файлы располагаются в подкаталоге
<tt>__vic/</tt>. Включать их следует следующим образом:</p><pre class="code">
#include &#60;__vic/<span class="nonterminal">header.h</span>&gt;
</pre><p>Где <tt><span class="nonterminal">header.h</span></tt> - это имя нужного заголовочного файла.</p><p>Практически весь код находится внутри пространства имён <tt>__vic</tt>,
включая другие пространства имён.</p><p>При компоновке программы, нужно подсунуть компоновщику файл библиотеки.
Например:</p><pre class="code">
$ g++ -std=c++14 prog.cpp -l__vic14
</pre><p>Библиотека может быть собрана с использованием одного из стандартов ISO C++:
C++98, C++11, C++14 или C++17. Суффикс стандарта используется в качестве
суффикса файла библиотеки (архива).</p><p>Некоторые компоненты библиотеки требуют какую-то минимальную версию
стандарта, например многие требуют использования как минимум C++11. Такие
компоненты помечаются значком <span class="sign">[C++11]</span>, который означает «C++11 или
более старшие версии».</p><p>Некоторые компоненты библиотеки доступны только для какой-то конкретной
версии стандарта и не доступны для других. Такие компоненты помечаются значком
<span class="sign">[C++98 only]</span>.</p><p>Детальное описание компонентов библиотеки приведено в последующих главах.
Описание сгруппировано по заголовочным файлам. В основном используется синтаксис
C++14, как более богатый и выразительный.</p><h1 id="components-reference"><span class="h1_num">2</span>Описание компонентов библиотеки</h1><h2 id="defs.h"><span class="h2_num">2.1</span><tt>__vic/defs.h</tt></h2><p>Различные фундаментальные определения.</p><h3 id="nullptr"><span class="h3_num">2.1.1</span><tt>nullptr</tt> <span class="sign">[C++98 only]</span></h3><p>Литерал для пустого указателя. Может использоваться вместо <tt>NULL</tt> или
<tt>0</tt>. В режиме ISO C++ 98 определён как</p><pre class="code">
const int nullptr = 0;
</pre><p>Данное определение позволяет писать код в стиле C++11 при использовании
стандарта C++98.</p><p>Это одно из немногих глобальных определений библиотеки. Определение можно
предотвратить, определив макрос <tt>__VIC_NO_NULLPTR_DEF</tt> перед включением.
</p><div class="section">Пример</div><pre class="code">
int *p = nullptr;
pthread_create(&#38;tid, nullptr, thread_func, nullptr);
</pre><h3 id="noexcept"><span class="h3_num">2.1.2</span><tt>noexcept</tt> <span class="sign">[C++98 only]</span></h3><p>В режиме C++98 - макроопределение, синоним <tt>throw()</tt>. В режимах
остальных стандартов данное определение отсутсвует.</p><h3 id="array_size"><span class="h3_num">2.1.3</span><tt>array_size()</tt></h3><pre class="code">
template&#60;class T, size_t N&gt;
constexpr size_t array_size(T (&#38;array)[N]);
</pre><p>Возвращает количество элементов массива. Может вычисляться во время
компиляции.</p><div class="section">Пример</div><pre class="code">
int m[] = { 1, 2, 3, 5, 7 };

size_t n = __vic::array_size(m); // n == 5

int *dup = new int[n];
</pre><h3 id="non_copyable"><span class="h3_num">2.1.4</span><tt>non_copyable</tt></h3><pre class="code">
class non_copyable
{
    non_copyable(const non_copyable &#38;) = delete;
    non_copyable &#38;operator=(const non_copyable &#38;) = delete;
protected:
    non_copyable() = default;
};
</pre><p>Наследование данного класса подавляет генерацию копирующих конструктора
и присваивания. Аналог <tt>boost::noncopyable</tt>.</p><div class="section">Пример</div><pre class="code">
class C : private __vic::non_copyable
{
};

C c1;
C c2 = c1; // Error! Non-copyable object
</pre><h3 id="non_heap_allocatable"><span class="h3_num">2.1.5</span><tt>non_heap_allocatable</tt></h3><pre class="code">
class non_heap_allocatable
{
    void *operator new(std::size_t ) = delete;
    void *operator new(std::size_t , const std::nothrow_t &#38; ) = delete;
    void *operator new[](std::size_t ) = delete;
    void *operator new[](std::size_t , const std::nothrow_t &#38; ) = delete;
protected:
    non_heap_allocatable() = default;
};
</pre><p>Наследование данного класса предотвращает размещение объекта в куче с
использованием оператора <tt>new</tt>.</p><div class="section">Пример</div><pre class="code">
class C : private __vic::non_heap_allocatable
{
};

C c; // Ok. Allocation on stack
C *p = new C; // Error! Attempt to allocate on heap
</pre><h3 id="std--move"><span class="h3_num">2.1.6</span><tt>std::move()</tt>, <tt>std::forward()</tt>, <tt>std::swap()</tt>
<span class="sign">[C++11]</span></h3><p>Данный заголовочный файл всегда включает эти утилиты в режиме C++11.</p><h3 id="VIC_SWAP_HEADER"><span class="h3_num">2.1.7</span><tt>__VIC_SWAP_HEADER</tt></h3><p>Макроопределение для <tt>#include</tt>. Раскрывается в имя заголовочного
файла, который содержит определение <tt>std::swap()</tt>, в зависимости от
используемого стандарта языка.</p><div class="section">Пример</div><pre class="code">
#include __VIC_SWAP_HEADER
</pre><h3 id="platform-dependent-macros"><span class="h3_num">2.1.8</span>Системно-зависимые макроопределения</h3><p>Библиотека предоставляет набор макроопределений, позволяющий программе
определить, для какой целевой платформы она собирается. Подобные определения
предоставляются компиляторами, но везде под разными именами. Использование
макроопределений библиотеки позволяет не зависеть от компилятора.</p><p>Список аппаратных платформ (процессоров):</p><ul><li><tt>__VIC_X86__</tt> - Intel x86 (IA32)</li><li><tt>__VIC_X64__</tt> - x64 aka AMD 64</li><li><tt>__VIC_IA64__</tt> - Intel IA64</li><li><tt>__VIC_POWERPC__</tt> - PowerPC</li></ul><p>Другие макроопределения:</p><ul><li><tt>__VIC_STRICT_RAM_ALIGNMENT__</tt> - попытка вычитать из памяти
        невыровненные данные приведёт к ошибке шины</li></ul><h2 id="ascii.h"><span class="h2_num">2.2</span><tt>__vic/ascii.h</tt></h2><p>Быстрые, компактные и независимые от locale инструменты для обработки
ASCII-символов. Все инструменты находятся в пространстве имён
<tt>__vic::ascii</tt>.</p><h3 id="ascii--is-functions"><span class="h3_num">2.2.1</span><tt>ascii::is</tt>-функции</h3><pre class="code">
namespace ascii {

constexpr bool isdigit(char c);
constexpr bool isxdigit(char c);
constexpr bool islower(char c);
constexpr bool isupper(char c);
constexpr bool isalpha(char c);
constexpr bool isalnum(char c);
constexpr bool isspace(char c);
constexpr bool isascii(char c);

}
</pre><p>Аналоги соответствующих функций из <tt>&#60;cctype&gt;</tt>.</p><h3 id="ascii--todigit"><span class="h3_num">2.2.2</span><tt>ascii::todigit()</tt></h3><pre class="code">
constexpr char ascii::todigit(int d);
</pre><p>Преобразует целое значение от 0 до 9 в десятичную цифру. Результат
неопределён, если входное значение не попадает в указанный диапазон.</p><div><u>Предусловие</u>: <tt>0 &#60;= d &#38;&#38; d &#60;= 9</tt></div><h3 id="ascii--toxdigit"><span class="h3_num">2.2.3</span><tt>ascii::toxdigit_upper()</tt>, <tt>ascii::toxdigit_lower()</tt></h3><pre class="code">
namespace ascii {

constexpr char toxdigit_upper(int d);
constexpr char toxdigit_lower(int d);

}
</pre><p>Преобразует целое значение от 0 до 15 в шестнадцатеричную цифру. Первая
функция использует верхний регистр для <tt>A</tt>-<tt>F</tt>, вторая - нижний.
Результат неопределён, если входное значение не попадает в указанный диапазон.
</p><div><u>Предусловие</u>: <tt>0 &#60;= d &#38;&#38; d &#60;= 15</tt></div><h3 id="ascii--digit_to_number"><span class="h3_num">2.2.4</span><tt>ascii::digit_to_number()</tt></h3><pre class="code">
constexpr int ascii::digit_to_number(char d);
</pre><p>Преобразует десятичную цифру в число, если <tt>ascii::isdigit(d)</tt>.
В противном случае возвращается <tt>-1</tt>.</p><h3 id="ascii--xdigit_to_number"><span class="h3_num">2.2.5</span><tt>ascii::xdigit_to_number()</tt></h3><pre class="code">
constexpr int ascii::xdigit_to_number(char d);
</pre><p>Преобразует шестнадцатеричную цифру в число, если
<tt>ascii::isxdigit(d)</tt>. В противном случае возвращается <tt>-1</tt>.</p><h3 id="ascii--tolower-char"><span class="h3_num">2.2.6</span><tt>ascii::tolower(char)</tt>, <tt>ascii::toupper(char)</tt></h3><pre class="code">
namespace ascii {

constexpr char tolower(char c);
constexpr char toupper(char c);
constexpr char upper_to_lower(char upper);
constexpr char lower_to_upper(char lower);

}
</pre><div><pre class="prototype">constexpr char tolower(char c)</pre><pre class="prototype">constexpr char toupper(char c)</pre><blockquote><p>Аналоги соответствующих функций из <tt>&#60;cctype&gt;</tt>.</p></blockquote></div><div><pre class="prototype">constexpr char upper_to_lower(char upper)</pre><blockquote><p>Более ограниченный аналог <tt>tolower()</tt>. Результат неопределён, если
аргумент не является заглавной буквой ASCII.</p><div><u>Предусловие</u>: <tt>ascii::isupper(upper)</tt></div></blockquote></div><div><pre class="prototype">constexpr char lower_to_upper(char lower)</pre><blockquote><p>Более ограниченный аналог <tt>toupper()</tt>. Результат неопределён, если
аргумент не является строчной буквой ASCII.</p><div><u>Предусловие</u>: <tt>ascii::islower(lower)</tt></div></blockquote></div><h3 id="ascii--equal_icase-char"><span class="h3_num">2.2.7</span><tt>ascii::equal_icase(char,char)</tt></h3><pre class="code">
constexpr bool ascii::equal_icase(char ch1, char ch2);
</pre><p>Проверяет два ASCII-символа на равенство без учета регистра букв.</p><h2 id="ascii_string.h"><span class="h2_num">2.3</span><tt>__vic/ascii_string.h</tt></h2><p>Инструменты обработки ASCII-строк.</p><h3 id="ascii--tolower-str"><span class="h3_num">2.3.1</span><tt>ascii::tolower()</tt></h3><pre class="code">
namespace ascii {

char *tolower(char *str);
std::string &#38;tolower(std::string &#38;str);

}
</pre><p>Переводит все заглавные латинские буквы <tt>str</tt> в строчные. Возвращает
<tt>str</tt>. Указатель на C-строку не должен быть <tt>nullptr</tt>!</p><h3 id="ascii--toupper-str"><span class="h3_num">2.3.2</span><tt>ascii::toupper()</tt></h3><pre class="code">
namespace ascii {

char *toupper(char *str);
std::string &#38;toupper(std::string &#38;str);

}
</pre><p>Переводит все строчные латинские буквы <tt>str</tt> в заглавные. Возвращает
<tt>str</tt>. Указатель на C-строку не должен быть <tt>nullptr</tt>!</p><h3 id="ascii--equal_icase-str"><span class="h3_num">2.3.3</span><tt>ascii::equal_icase()</tt></h3><pre class="code">
namespace ascii {

bool equal_icase(const char *s1, const char *s2);
bool equal_icase(const std::string &#38;s1, const std::string &#38;s2);
bool equal_icase(const std::string &#38;s1, const char *s2);
bool equal_icase(const char *s1, const std::string &#38;s2);
bool equal_icase(const char *s1, size_t s1_len,
                 const char *s2, size_t s2_len);

}
</pre><p>Проверяет две ASCII-строки на равенство без учета регистра букв. Указатели
на строки не должны быть <tt>nullptr</tt>!</p><h2 id="base16.h"><span class="h2_num">2.4</span><tt>__vic/base16.h</tt></h2><p>Кодировщик и декодировщик Base16.</p><h3 id="base16"><span class="h3_num">2.4.1</span><tt>base16</tt></h3><p>Класс, используемый как пространство имён. Содержит только типы, константы
и статические функции. Создание объектов данного класса не предполагается.</p><h3 id="base16--bad_format"><span class="h3_num">2.4.2</span><tt>base16::bad_format</tt></h3><pre class="code">
struct base16::bad_format : public std::exception {};
</pre><p>Абстрактный базовый класс исключений.</p><h3 id="base16--bad_digit"><span class="h3_num">2.4.3</span><tt>base16::bad_digit</tt></h3><pre class="code">
struct base16::bad_digit : public base16::bad_format
{
    const char *what() const noexcept;
};
</pre><p>Класс исключений, бросаемый <a href="#base16--decode"><tt>base16::decode()</tt></a> если входная
последовательность содержит символ, не являющийся шестнадцатеричной цифрой.</p><h3 id="base16--bad_length"><span class="h3_num">2.4.4</span><tt>base16::bad_length</tt></h3><pre class="code">
struct base16::bad_length : public base16::bad_format
{
    const char *what() const noexcept;
};
</pre><p>Класс исключений, бросаемый <a href="#base16--decode"><tt>base16::decode()</tt></a> если входная
последовательность состоит из нечётного количества символов.</p><h3 id="base16--status"><span class="h3_num">2.4.5</span><tt>base16::status</tt></h3><pre class="code">
enum class base16::status
{
    ok,
    invalid_length,
    invalid_digit
};
using base16::status_t = base16::status; // for C++98
</pre><p>Коды статусов разбора входной последовательности, возвращаемые
<a href="#base16--try_decode"><tt>base16::try_decode()</tt></a>.</p><h3 id="base16--encode_upper"><span class="h3_num">2.4.6</span><tt>base16::encode_upper()</tt></h3><pre class="code">
// Bytes -&gt; Text
template&#60;class ByteReader, class CharWriter&gt;
void base16::encode_upper(ByteReader reader, CharWriter writer);
</pre><p>Кодирует байты из <tt>reader</tt> и записывает результирующие символы во
<tt>writer</tt>. Для шестнадцатеричных цифр используется верхний регистр.</p><p><tt>ByteReader</tt> должен моделировать concept
<tt>Reader&#60;unsigned char&gt;</tt>. См. <a href="#readers"><tt>__vic/readers/</tt></a>.</p><p><tt>CharWriter</tt> должен моделировать concept <tt>Writer&#60;char&gt;</tt>.
См. <a href="#writers"><tt>__vic/writers/</tt></a>.</p><div class="section">Пример</div><pre class="code">
#include&#60;__vic/readers/string.h&gt;
#include&#60;__vic/writers/string.h&gt;

using bytes = std::string;
using bytes_reader = __vic::string_reader;

std::string encode_base16(const bytes &#38;s)
{
    std::string res;
    res.reserve(s.length() * 2);
    __vic::base16::encode_upper(bytes_reader(s), __vic::string_writer(res));
    return res;
}
</pre><h3 id="base16--encode_lower"><span class="h3_num">2.4.7</span><tt>base16::encode_lower()</tt></h3><pre class="code">
// Bytes -&gt; Text
template&#60;class ByteReader, class CharWriter&gt;
void base16::encode_lower(ByteReader reader, CharWriter writer);
</pre><p>То же самое, что <a href="#base16--encode_upper"><tt>base16::encode_upper()</tt></a>, но использует нижний
регистр для шестнадцатеричных цифр.</p><h3 id="base16--decode"><span class="h3_num">2.4.8</span><tt>base16::decode()</tt></h3><pre class="code">
// Text -&gt; Bytes
template&#60;class CharReader, class ByteWriter&gt;
void base16::decode(CharReader reader, ByteWriter writer);
</pre><p>Декодирует символы из <tt>reader</tt> и записывает результирующие байты во
<tt>writer</tt>. Если входная последовательность имеет неправильный Base16
формат, бросается исключение наследник <a href="#base16--bad_format"><tt>base16::bad_format</tt></a>.</p><p><tt>CharReader</tt> должен моделировать concept <tt>Reader&#60;char&gt;</tt>.
См. <a href="#readers"><tt>__vic/readers/</tt></a>.</p><p><tt>ByteWriter</tt> должен моделировать concept
<tt>Writer&#60;unsigned char&gt;</tt>. См. <a href="#writers"><tt>__vic/writers/</tt></a>.</p><div class="section">Пример</div><pre class="code">
#include&#60;__vic/readers/string.h&gt;
#include&#60;__vic/writers/string.h&gt;

using bytes = std::string;
using bytes_writer = __vic::string_writer;

bytes decode_base16(const std::string &#38;s)
{
    bytes res;
    res.reserve(s.length() / 2);
    __vic::base16::decode(__vic::string_reader(s), bytes_writer(res));
    return res;
}
</pre><h3 id="base16--try_decode"><span class="h3_num">2.4.9</span><tt>base16::try_decode()</tt></h3><pre class="code">
// Text -&gt; Bytes
template&#60;class CharReader, class ByteWriter&gt;
base16::status_t base16::try_decode(CharReader reader, ByteWriter writer);
</pre><p>То же самое, что <a href="#base16--decode"><tt>base16::decode()</tt></a>, но возвращает
<a href="#base16--status"><tt>base16::status</tt></a> отличный от <tt>base16::status::ok</tt> в случае
неправильного формата входной последовательности вместо бросания исключений.</p><h2 id="base64.h"><span class="h2_num">2.5</span><tt>__vic/base64.h</tt></h2><p>Кодировщик и декодировщик Base64.</p><h3 id="base64"><span class="h3_num">2.5.1</span><tt>base64</tt></h3><p>Класс, используемый как пространство имён. Содержит только типы, константы
и статические функции. Создание объектов данного класса не предполагается.</p><h3 id="base64--bad_format"><span class="h3_num">2.5.2</span><tt>base64::bad_format</tt></h3><pre class="code">
struct base64::bad_format : public std::exception {};
</pre><p>Абстрактный базовый класс исключений.</p><h3 id="base64--bad_digit"><span class="h3_num">2.5.3</span><tt>base64::bad_digit</tt></h3><pre class="code">
struct base64::bad_digit : public base64::bad_format
{
    const char *what() const noexcept;
};
</pre><p>Класс исключений, бросаемый <a href="#base64--decode"><tt>base64::decode()</tt></a> если входная
последовательность содержит символ, не являющийся цифрой Base64.</p><h3 id="base64--bad_length"><span class="h3_num">2.5.4</span><tt>base64::bad_length</tt></h3><pre class="code">
struct base64::bad_length : public base64::bad_format
{
    const char *what() const noexcept;
};
</pre><p>Класс исключений, бросаемый <a href="#base64--decode"><tt>base64::decode()</tt></a> если входная
последовательность состоит из количества символов не кратного 4.</p><h3 id="base64--status"><span class="h3_num">2.5.5</span><tt>base64::status</tt></h3><pre class="code">
enum class base64::status
{
    ok,
    invalid_length,
    invalid_digit
};
using base64::status_t = base64::status; // for C++98
</pre><p>Коды статусов разбора входной последовательности, возвращаемые
<a href="#base64--try_decode"><tt>base64::try_decode()</tt></a>.</p><h3 id="base64--encode"><span class="h3_num">2.5.6</span><tt>base64::encode()</tt></h3><pre class="code">
// Bytes -&gt; Text
template&#60;class ByteReader, class CharWriter&gt;
void base64::encode(ByteReader reader, CharWriter writer);
</pre><p>Кодирует байты из <tt>reader</tt> и записывает результирующие символы во
<tt>writer</tt>.</p><p><tt>ByteReader</tt> должен моделировать concept
<tt>Reader&#60;unsigned char&gt;</tt>. См. <a href="#readers"><tt>__vic/readers/</tt></a>.</p><p><tt>CharWriter</tt> должен моделировать concept <tt>Writer&#60;char&gt;</tt>.
См. <a href="#writers"><tt>__vic/writers/</tt></a>.</p><div class="section">Пример</div><pre class="code">
#include&#60;__vic/readers/string.h&gt;
#include&#60;__vic/writers/string.h&gt;

using bytes = std::string;
using bytes_reader = __vic::string_reader;

std::string encode_base64(const bytes &#38;s)
{
    std::string res;
    res.reserve(__vic::base64::encoded_length(s.length()));
    __vic::base64::encode(bytes_reader(s), __vic::string_writer(res));
    return res;
}
</pre><h3 id="base64--decode"><span class="h3_num">2.5.7</span><tt>base64::decode()</tt></h3><pre class="code">
// Text -&gt; Bytes
template&#60;class CharReader, class ByteWriter&gt;
void base64::decode(CharReader reader, ByteWriter writer);
</pre><p>Декодирует символы из <tt>reader</tt> и записывает результирующие байты во
<tt>writer</tt>. Если входная последовательность имеет неправильный Base64
формат, бросается исключение наследник <a href="#base64--bad_format"><tt>base64::bad_format</tt></a>.</p><p><tt>CharReader</tt> должен моделировать concept <tt>Reader&#60;char&gt;</tt>.
См. <a href="#readers"><tt>__vic/readers/</tt></a>.</p><p><tt>ByteWriter</tt> должен моделировать concept
<tt>Writer&#60;unsigned char&gt;</tt>. См. <a href="#writers"><tt>__vic/writers/</tt></a>.</p><div class="section">Пример</div><pre class="code">
#include&#60;__vic/readers/string.h&gt;
#include&#60;__vic/writers/string.h&gt;

using bytes = std::string;
using bytes_writer = __vic::string_writer;

bytes decode_base64(const std::string &#38;s)
{
    bytes res;
    res.reserve(__vic::base64::max_decoded_length(s.length()));
    __vic::base64::decode(__vic::string_reader(s), bytes_writer(res));
    return res;
}
</pre><h3 id="base64--try_decode"><span class="h3_num">2.5.8</span><tt>base64::try_decode()</tt></h3><pre class="code">
// Text -&gt; Bytes
template&#60;class CharReader, class ByteWriter&gt;
base64::status_t base64::try_decode(CharReader reader, ByteWriter writer);
</pre><p>То же самое, что <a href="#base64--decode"><tt>base64::decode()</tt></a>, но возвращает
<a href="#base64--status"><tt>base64::status</tt></a> отличный от <tt>base64::status::ok</tt> в случае
неправильного формата входной последовательности вместо бросания исключений.</p><h3 id="base64--encoded_length"><span class="h3_num">2.5.9</span><tt>base64::encoded_length()</tt></h3><pre class="code">
constexpr size_t base64::encoded_length(size_t orig_len);
</pre><p>Высчитывает длину закодированной последовательности символов на основе длины
входной последовательности в байтах.</p><h3 id="base64--max_decoded_length"><span class="h3_num">2.5.10</span><tt>base64::max_decoded_length()</tt></h3><pre class="code">
constexpr size_t base64::max_decoded_length(size_t orig_len);
</pre><p>Оценивает максимальную длину декодированной последовательности байтов на
основе длины входной последовательности символов. Точная длина зависит от
символов <tt>'='</tt> на конце закодированной последовательности.</p><h2 id="bin_file.h"><span class="h2_num">2.6</span><tt>__vic/bin_file.h</tt></h2><h3 id="bin_file"><span class="h3_num">2.6.1</span><tt>bin_file</tt></h3><pre class="code">
class bin_file : private non_copyable
{
public:
    enum in_t { in };
    enum out_t { out };
    enum append_t { append };

    bin_file();
    bin_file(const char *fname, in_t);
    bin_file(const char *fname, out_t);
    bin_file(const char *fname, append_t);
    ~bin_file();

    // BEGIN C++11
    bin_file(bin_file &#38;&#38;o) noexcept;
    bin_file &#38;operator=(bin_file &#38;&#38;o) noexcept;
    // END C++11

    bool open_in(const char *fname);
    bool open_out(const char *fname);
    bool open_append(const char *fname);

    size_t read_max(void *buf, size_t n);
    size_t read_some(void *buf, size_t n);

    void write_all(const void *buf, size_t n);

    bool is_open() const;
    void close();
    bool close_nt() noexcept;

    void swap(bin_file &#38;o) noexcept;

    [[noreturn]] void throw_last_error(const char *msg);
    void throw_if_closed(const char *msg);
};
</pre><p>Небуферизированный двоичный файл. Независимая от ОС обёртка низкоуровневого
системного API.</p><p>Доступны следующие режимы открытия:</p><ul><li><tt>in</tt> - открыть существующий файл для чтения;</li><li><tt>out</tt> - создать новый файл для записи, перетереть старый,
        если уже существует;</li><li><tt>append</tt> - открыть существующий файл для добавления (запись в
        конец файла), создать новый, если не существует.</li></ul><div class="section">Члены класса</div><div><pre class="prototype">enum in_t { in }</pre><pre class="prototype">enum out_t { out }</pre><pre class="prototype">enum append_t { append }</pre><blockquote><p>Тэги конструкторов.</p></blockquote></div><div><pre class="prototype">bin_file()</pre><blockquote><div><u>Постусловие</u>: <tt>is_open() == false()</tt></div></blockquote></div><div><pre class="prototype">bin_file(const char *fname, in_t)</pre><pre class="prototype">bin_file(const char *fname, out_t)</pre><pre class="prototype">bin_file(const char *fname, append_t)</pre><blockquote><p>Вызывают <tt>open_in(fname)</tt>, <tt>open_out(fname)</tt> или
<tt>open_append(fname)</tt>, соответственно. <tt>is_open()</tt> или
<tt>throw_if_closed()</tt> должен быть вызван после для проверки результата.</p></blockquote></div><div><pre class="prototype">~bin_file()</pre><blockquote><p>Закрывает файл, если <tt>is_open() == true</tt>.</p></blockquote></div><div><pre class="prototype">bin_file(bin_file &#38;&#38;o) noexcept <span class="sign">[C++11]</span></pre><pre class="prototype">bin_file &#38;operator=(bin_file &#38;&#38;o) noexcept <span class="sign">[C++11]</span></pre><blockquote><p>Операции перемещения для режима C++11.</p></blockquote></div><div><pre class="prototype">bool open_in(const char *fname)</pre><pre class="prototype">bool open_out(const char *fname)</pre><pre class="prototype">bool open_append(const char *fname)</pre><blockquote><p>Открыть файл для чтения, записи или добавления, соответственно. Возвращает
<tt>is_open()</tt>.</p><div><u>Предусловие</u>: <tt>is_open() == false</tt></div></blockquote></div><div><pre class="prototype">bool is_open() const</pre><blockquote><p>Возвращает <tt>true</tt> если файл открыт.</p></blockquote></div><div><pre class="prototype">size_t read_max(void *buf, size_t n)</pre><blockquote><p>Пытается прочитать <tt>n</tt> байтов в указанный буфер. Возвращает количество
байтов, которое удалось прочитать. Возвращённое значение может быть меньше
запрошенного только в случае, если достигнут конец файла. При ошибках бросает
исключения.</p><div><u>Предусловие</u>: <tt>is_open() == true</tt></div></blockquote></div><div><pre class="prototype">size_t read_some(void *buf, size_t n)</pre><blockquote><p>Читает не более <tt>n</tt> байтов в указанный буфер. Возвращает количество
прочитанных байтов или <tt>0</tt> при достижении конца файлов. Функция
сразу возвращает управление, как только прочитан блок байтов любого размера.
При ошибках бросает исключения.</p><div><u>Предусловие</u>: <tt>is_open() == true</tt></div></blockquote></div><div><pre class="prototype">void write_all(const void *buf, size_t n)</pre><blockquote><p>Записывает весь переданный буфер в файл. При ошибках бросает исключения.</p><div><u>Предусловие</u>: <tt>is_open() == true</tt></div></blockquote></div><div><pre class="prototype">void close()</pre><blockquote><p>Закрывает открытый файл. При ошибках бросает исключения.</p><div><u>Предусловие</u>: <tt>is_open() == true</tt></div><div><u>Постусловие</u>: <tt>is_open() == false</tt></div></blockquote></div><div><pre class="prototype">bool close_nt() noexcept</pre><blockquote><p>Аналог <tt>close()</tt>, но никогда не бросает исключений. Вместо этого
возвращает <tt>false</tt> при ошибках.</p></blockquote></div><div><pre class="prototype">void swap(bin_file &#38;o) noexcept</pre><blockquote><p>Обменивается значением с <tt>o</tt>.</p></blockquote></div><div><pre class="prototype">[[noreturn]] void throw_last_error(const char *msg)</pre><blockquote><p>Бросает исключение с описанием последней ошибки, если оно доступно. В любом
случае <tt>what()</tt> будет содержать <tt>msg</tt> в виде подстроки.</p></blockquote></div><div><pre class="prototype">void throw_if_closed(const char *msg)</pre><blockquote><p>Вызывает <tt>throw_last_error(msg)</tt>, если <tt>!is_open()</tt>.</p></blockquote></div><div class="section">Пример</div><pre class="code">
// Copy file
__vic::bin_file in("file", __vic::bin_file::in);
in.throw_if_closed("Cannot open file")
__vic::bin_file out("file.copy", __vic::bin_file::out);
out.throw_if_closed("Cannot create file")

char buf[512];
while(size_t n = in.read_some(buf, sizeof buf))
    out.write_all(buf, n);

out.close();
// in will be closed by destructor
</pre><h2 id="bits.h"><span class="h2_num">2.7</span><tt>__vic/bits.h</tt></h2><p>Инструменты для манипуляции битами и байтами.</p><h3 id="lo_nibble"><span class="h3_num">2.7.1</span><tt>lo_nibble()</tt>, <tt>hi_nibble()</tt></h3><pre class="code">
constexpr uint8_t lo_nibble(uint8_t byte);
constexpr uint8_t hi_nibble(uint8_t byte);
</pre><p>Возвращают значение младшего/старшего полубайта (тетрады), соответственно.
</p><h3 id="msb_ones"><span class="h3_num">2.7.2</span><tt>msb_ones()</tt>, <tt>lsb_ones()</tt></h3><pre class="code">
template&#60;class T&gt; T lsb_ones(unsigned bits_num);
template&#60;class T&gt; T msb_ones(unsigned bits_num);
</pre><p>Возвращают значение типа <tt>T</tt> со всеми младшими/старшими
<tt>bits_num</tt> битами заполненными <tt>1</tt>, соответственно. Все остальные
биты установлены в <tt>0</tt>.</p><h3 id="get_lsbs"><span class="h3_num">2.7.3</span><tt>get_lsbs()</tt></h3><pre class="code">
template&#60;class T&gt; T get_lsbs(T v, unsigned bits_num);
</pre><p>Возвращает <tt>bits_num</tt> младших битов значения <tt>v</tt>. Другими
словами, заполняет нулями все, кроме младших <tt>bits_num</tt> битов.</p><h3 id="ord"><span class="h3_num">2.7.4</span><tt>ord()</tt></h3><pre class="code">
constexpr int ord(char ch);
</pre><p>Возвращает код символа от 0 до 255.</p><div><u>Постусловие</u>: ord(ch) &gt;= 0</div><h3 id="popcount"><span class="h3_num">2.7.5</span><tt>popcount()</tt></h3><pre class="code">
unsigned popcount(unsigned v);
unsigned popcount(unsigned long v);
unsigned popcount(unsigned long long v);
unsigned popcount(unsigned short v);
unsigned popcount(unsigned char v);
</pre><p>Возвращает количество единичных битов в данном значении.</p><h3 id="msb_position"><span class="h3_num">2.7.6</span><tt>msb_position()</tt></h3><pre class="code">
unsigned msb_position(unsigned v)
unsigned msb_position(unsigned long v);
unsigned msb_position(unsigned long long v);
unsigned msb_position(unsigned short v);
unsigned msb_position(unsigned char v);
</pre><div><u>Предусловие</u>: <tt>v != 0</tt></div><p>Возвращает позицию самого значимого единичного бита. Результат неопределён,
если <tt>v == 0</tt>.</p><h3 id="ispow2"><span class="h3_num">2.7.7</span><tt>ispow2()</tt></h3><pre class="code">
template&#60;class UInt&gt;
bool ispow2(UInt n);
</pre><div><u>Предусловие</u>: <tt>UInt</tt> - беззнаковый целый тип</div><p>Возвращает <tt>true</tt>, если <tt>n</tt> является целой степенью 2.</p><h3 id="ceil2"><span class="h3_num">2.7.8</span><tt>ceil2()</tt></h3><pre class="code">
template&#60;class UInt&gt;
UInt ceil2(UInt n);
</pre><div><u>Предусловие</u>: <tt>UInt</tt> - беззнаковый целый тип</div><p>Возвращает минимальное значение <tt>m</tt>, такое что <tt>ispow(m) &#38;&#38;
m &gt;= n</tt>. Если <tt>m</tt> непредставимо типом <tt>UInt</tt>, результат
неопределён.</p><h3 id="floor2"><span class="h3_num">2.7.9</span><tt>floor2()</tt></h3><pre class="code">
template&#60;class UInt&gt;
UInt floor2(UInt n);
</pre><div><u>Предусловие</u>: <tt>UInt</tt> - беззнаковый целый тип</div><p>Если <tt>n != 0</tt>, возвращает максимальное значение <tt>m</tt>, такое что
<tt>ispow2(m) &#38;&#38; m &#60;= n</tt>. В противном случае возвращается
<tt>0</tt>.</p><h3 id="ceil_log2"><span class="h3_num">2.7.10</span><tt>ceil_log2()</tt></h3><pre class="code">
template&#60;class UInt&gt;
unsigned ceil_log2(UInt n);
</pre><div><u>Предусловие</u>: <tt>UInt</tt> - беззнаковый целый тип</div><p>Возвращает <tt>ceil(log2(n))</tt>, если <tt>n != 0</tt>, или 0 в
противном случае.</p><h3 id="floor_log2"><span class="h3_num">2.7.11</span><tt>floor_log2()</tt></h3><pre class="code">
template&#60;class UInt&gt;
unsigned floor_log2(UInt n);
</pre><div><u>Предусловие</u>: <tt>UInt</tt> - беззнаковый целый тип</div><p>Возвращает <tt>floor(log2(n))</tt>, если <tt>n != 0</tt>, или 0 в
противном случае.</p><h3 id="rotl"><span class="h3_num">2.7.12</span><tt>rotl()</tt>, <tt>rotr()</tt></h3><pre class="code">
unsigned long long rotl(unsigned long long v, int shift);
unsigned long      rotl(unsigned long v, int shift);
unsigned           rotl(unsigned v, int shift);
unsigned short     rotl(unsigned short v, int shift);
unsigned char      rotl(unsigned char v, int shift);

unsigned long long rotr(unsigned long long v, int shift);
unsigned long      rotr(unsigned long v, int shift);
unsigned           rotr(unsigned v, int shift);
unsigned short     rotr(unsigned short v, int shift);
unsigned char      rotr(unsigned char v, int shift);
</pre><p>Функции выполняют циклический побитовый сдвиг (rotation) влево
(<tt>rotl</tt>) или вправо (<tt>rotr</tt>).</p><div><u>Предусловие</u>: <tt>0 &#60;= shift &#38;&#38; shift &#60; sizeof(v)*CHAR_BIT</tt></div><h3 id="swapped_nibbles"><span class="h3_num">2.7.13</span><tt>swapped_nibbles()</tt></h3><pre class="code">
constexpr uint8_t swapped_nibbles(uint8_t b);
</pre><p>Меняет местами младший и старший полубайт значения и возвращает его.</p><h2 id="date_time.h"><span class="h2_num">2.8</span><tt>__vic/date_time.h</tt></h2><p>Работа с датой и временем.</p><h3 id="is_leap_year"><span class="h3_num">2.8.1</span><tt>is_leap_year()</tt></h3><pre class="code">
constexpr bool is_leap_year(int year);
</pre><p>Определяет, является ли данный год високосным, согласно Григорианскому
календарю.</p><h3 id="days_in_month"><span class="h3_num">2.8.2</span><tt>days_in_month()</tt></h3><pre class="code">
int days_in_month(int month, int year);
</pre><p>Возвращает количество дней в данном месяце. Месяц - это число от 1 до 12.
Второй параметр используется только, если месяц - 2 (февраль), в остальных
случаях просто игнорируется.</p><h3 id="days_between_years"><span class="h3_num">2.8.3</span><tt>days_between_years()</tt></h3><pre class="code">
long days_between_years(unsigned year1, unsigned year2);
</pre><p>Возвращает разность в днях между началами годов <tt>year2</tt> и
<tt>year1</tt>.</p><h3 id="invalid_date"><span class="h3_num">2.8.4</span><tt>invalid_date</tt></h3><pre class="code">
class invalid_date; // : public std::exception
</pre><p>Исключение, бросаемое в случае неправильного элемента даты или времени.</p><h3 id="validate_date_time"><span class="h3_num">2.8.5</span><tt>validate_date()</tt>, <tt>validate_time()</tt>,
<tt>validate_date_time()</tt></h3><pre class="code">
void validate_date(int yy, int mm, int dd);
void validate_time(int hh, int mi, int ss);
void validate_date_time(int yy, int mm, int dd, int hh, int mi, int ss);
</pre><p>Проверяет правильность даты/времени. Проверяются следующие ограничения:</p><ul><li><tt>yy</tt> (год) - не может быть <tt>0</tt>,</li><li><tt>mm</tt> (месяц) - <tt>1..12</tt>,</li><li><tt>dd</tt> (день месяца) - <tt>1..{28..31}</tt>, в зависимости
        от месяца,</li><li><tt>hh</tt> (час) - <tt>0..23</tt>,</li><li><tt>mi</tt> (минута) - <tt>0..59</tt>,</li><li><tt>ss</tt> (секунда) - <tt>0..59</tt>.</li></ul><p>В случае нарушения какого-то из ограничений бросается <tt>invalid_date</tt>.
</p><div><u><b>Замечание</b></u>: Специальные значения, такие как <tt>24:00:00</tt> (полночь в конце дня)
или <tt>59:60</tt> (високосная секунда) рассматриваются как неправильные!</div><h2 id="endian.h"><span class="h2_num">2.9</span><tt>__vic/endian.h</tt></h2><p>Утилиты для манипуляций порядком байт.</p><h3 id="endianness"><span class="h3_num">2.9.1</span><tt>endianness</tt></h3><pre class="code">
namespace endian {
enum endianness
{
    unknown = 0,
    little  = 1234,
    big     = 4321,
    pdp     = 3412,
    native  = <span class="nonterminal">&#60;one-of-the-above&gt;</span>
};
} // namespace

using endian::endianness;
</pre><p>Константы, соответсвующие различным порядкам байт. <tt>endian::native</tt>
принимает значение одной из констант, в зависимости от текущей платформы
(подобно макросу <tt>__BYTE_ORDER__</tt> в UNIX-подобных системах).
Предполагается использование данных констант для специализации шаблонов или
проверках времени компиляции (например с использованием <tt>static_assert</tt>).
</p><div class="section">Примеры</div><pre class="code">
template&#60;__vic::endianness &gt; struct some_algo; // not implemented

// Реализация для little-endian
template&#60;&gt; struct some_algo&#60;__vic::endian::little&gt;
{
    static void doit() { ... }
};
// Реализация для big-endian
template&#60;&gt; struct some_algo&#60;__vic::endian::big&gt;
{
    static void doit() { ... }
};

// Автоматически выбрать подходящую для используемой платформы реализацию
some_algo&#60;__vic::endian::native&gt;::doit();
</pre><pre class="code">
static_assert(__vic::endian::native == __vic::endian:little,
    "Litte-endian is expected");
</pre><h3 id="endian--from"><span class="h3_num">2.9.2</span><tt>endian::from_...()</tt></h3><pre class="code">
template&#60;class T&gt; [[nodiscard]] constexpr T endian::from_little(T v);
template&#60;class T&gt; [[nodiscard]] constexpr T endian::from_big(T v);
</pre><p>Возвращают значение, представленное в порядке байт, используемом платформой,
преобразованное из litte/big endian, если необходимо.</p><p><tt>T</tt> может быть любым интегральным типом или enum размера не более,
чем <tt>sizeof(long long)</tt>.</p><div class="section">Пример</div><pre class="code">
uint16_t v;
read_bytes(&#38;v, 2); // serialized as big endian
std::cout &#60;&#60; "The value is " &#60;&#60; __vic::endian::from_big(v) &#60;&#60; '\n';
</pre><h3 id="endian--to"><span class="h3_num">2.9.3</span><tt>endian::to_...()</tt></h3><pre class="code">
template&#60;class T&gt; [[nodiscard]] constexpr T endian::to_little(T v);
template&#60;class T&gt; [[nodiscard]] constexpr T endian::to_big(T v);
</pre><p>Возвращают значение, представленное в litte/big endian.</p><p><tt>T</tt> может быть любым интегральным типом или enum размера не более,
чем <tt>sizeof(long long)</tt>.</p><div class="section">Пример</div><pre class="code">
uint16_t v = __vic::endian::to_big(...);
write_bytes(&#38;v, 2); // serialize as big endian
</pre><h3 id="swab"><span class="h3_num">2.9.4</span><tt>swab16()</tt>, <tt>swab32()</tt>, <tt>swab64()</tt></h3><pre class="code">
[[nodiscard]] constexpr uint16_t swab16(uint16_t v);
[[nodiscard]] constexpr uint32_t swab32(uint32_t v);
[[nodiscard]] constexpr uint64_t swab64(uint64_t v);
</pre><p>Быстрые утилиты для обращения порядка байт (обычно реализуются с помощью
специфичных для компилятора intrinsics).</p><div class="section">Пример</div><pre class="code">
static_assert(__vic::swab32(0x01020304) == 0x04030201);
</pre><h2 id="error.h"><span class="h2_num">2.10</span><tt>__vic/error.h</tt></h2><p>Инструменты обработки ошибок.</p><h3 id="exception"><span class="h3_num">2.10.1</span><tt>exception</tt></h3><pre class="code">
class exception : public std::exception
{
public:
    exception();
    explicit exception(const char *message);
    const char *what() const noexcept;
protected:
    void set_message(const char *message);
};
</pre><p>Небольшое расширение <tt>std::exception</tt> - объект хранит сообщение об
ошибке, переданное в конструкторе, которое потом возвращает <tt>what()</tt>.
Может быть использован как базовый или конкретный класс исключения. Не
использует и не зависит от <tt>std::string</tt>, в отличие от
<tt>std::logic_error</tt> и <tt>std::runtime_error</tt>. Также Вам нет нужды
решать, какое из последних следует использовать в каждом конкретном случае.</p><div class="section">Члены класса</div><div><pre class="prototype">exception()</pre><blockquote><p>Создаёт объект с пустым сообщением об ошибке.</p></blockquote></div><div><pre class="prototype">explicit exception(const char *message)</pre><blockquote><p>Создаёт объект с указанным сообщением об ошибке.</p></blockquote></div><div><pre class="prototype">const char *what() const noexcept</pre><blockquote><p>Возвращает установленное ранее сообщение.</p></blockquote></div><div><pre class="prototype">void set_message(const char *message)</pre><blockquote><p>Устанавливает новое сообщение.</p></blockquote></div><div class="section">Пример</div><pre class="code">
struct custom_exception : public __vic::exception
{
    explicit custom_exception(const char *msg) : __vic::exception(msg) {}
};

throw custom_exception("Error condition description");
</pre><h3 id="libc_error"><span class="h3_num">2.10.2</span><tt>libc_error</tt></h3><pre class="code">
class libc_error : public std::exception
{
public:
    explicit libc_error(int err_no = errno);
    explicit libc_error(const char *prompt, int err_no = errno);

    const char *what() const noexcept;
    int code() const;
    int get_errno() const;
};
</pre><p>Класс предназначен для замены стандартного механизма обработки ошибок
в мире C - <tt>errno</tt> - на механизм исключений. Также класс пригоден для
использования в многопоточных приложениях вместо не всегда реентерабельного
вызова <tt>std::strerror()</tt>.</p><p>Ниже приведён фрагмент кода, типичный для языка C:</p><pre class="code">
// C:

int fd;
if((fd = open("qqqq", O_RDONLY)) == -1)
{
    perror("open");
    if(errno == ENOENT) exit(1);
}
</pre><p>Если файл не найден, программа напечатает</p><pre class="code">
open: No such file or directory
</pre><p>в <tt>stderr</tt> и выйдет, вернув в ОС значение <tt>1</tt>.</p><p>Какие проблемы присущи этому коду? Во-первых, не у каждой программы есть
<tt>stderr</tt>, поэтому библиотечная функция не может сама выводить туда
сообщения об ошибках. Во-вторых, значение глобальной переменной <tt>errno</tt>
может быть затёрто любым следующим вызовом, если его не сохранить. В-третьих,
решение о завершении процесса должна принимать конечная программа. Обычная
библиотечная функция не может брать на себя такие полномочия. В-четвёртых,
в общем случае программа на С++ не может вызывать <tt>std::exit()</tt>, так
как не будут вызваны деструкторы активных объектов, что может разрушить логику
работы программы.</p><p>Ниже приведён адаптированный пример для C++ с использованием описываемого
класса:</p><pre class="code">
// C++:

try
{
    int fd = open("qqqq", O_RDONLY);
    if(fd == -1) throw __vic::libc_error("open");
    // or just
    // if(fd == -1) throw __vic::libc_error();
}
catch(const __vic::libc_error &#38;ex)
{
    std::cerr &#60;&#60; ex.what() &#60;&#60; '\n';
    if(ex.code() == ENOENT) return 1;
}
</pre><p>Как видно, функция просто корректно отслеживает ошибочную ситуацию и
сообщает о ней вызывающей среде. Далее вызывающая сторона уже сама может
принять решение об обработке ошибки. В простейшем случае она поступает также
как предыдущая C-программа: печатает сообщение в стандартный поток вывода
ошибок и завершает выполнение. Кроме того, код ошибки надёжно сохранён в
исключении и ни кем не перетрётся.</p><div><u><b>Замечание</b></u>: Обычно исключения данного класса не должны бросаться явно! Используйте
<a href="#throw_errno"><tt>throw_errno()</tt></a> для их генерации.</div><div class="section">Члены класса</div><div><pre class="prototype">explicit libc_error(int err_no = errno)</pre><blockquote><p><tt>err_no</tt> - код ошибки.</p><div><u>Постусловие</u>: <tt>code() == err_no</tt></div></blockquote></div><div><pre class="prototype">explicit libc_error(const char *prompt, int err_no = errno)</pre><blockquote><p><tt>prompt</tt> - заголовок выводимого сообщения. Параметр имеет такой же
смысл, как и параметр <tt>std::perror()</tt>.</p></blockquote></div><div><pre class="prototype">const char *what() const noexcept</pre><blockquote><p>Возвращает описание ошибки в формате <tt>std::perror()</tt>.</p></blockquote></div><div><pre class="prototype">int code() const</pre><pre class="prototype">int get_errno() const</pre><blockquote><p>Возвращает хранимый код ошибки.</p></blockquote></div><h2 id="fixed_vector.h"><span class="h2_num">2.11</span><tt>__vic/fixed_vector.h</tt></h2><h3 id="fixed_vector"><span class="h3_num">2.11.1</span><tt>fixed_vector</tt></h3><pre class="code">
template&#60;class T&gt;
class fixed_vector : private non_copyable
{
public:
    using value_type     = T;
    using iterator       = <span class="nonterminal">&#60;implementation-defined&gt;</span>;
    using const_iterator = <span class="nonterminal">&#60;implementation-defined&gt;</span>;

    fixed_vector();
    explicit fixed_vector(size_t max_size);
    ~fixed_vector();

    // BEGIN C++11
    fixed_vector(fixed_vector &#38;&#38;o) noexcept;
    fixed_vector &#38;operator=(fixed_vector &#38;&#38;o) noexcept;
    template&#60;class... Args&gt; T &#38;emplace_back(Args &#38;&#38;... args)
    // END C++11

    // size in objects
    size_t size() const;
    size_t capacity() const;
    bool full() const;
    bool empty() const;

    void recreate(size_t new_max_size, bool size_exact = false);
    void *alloc(); // returns pointer to memory for object allocation
    void push_allocated(); // adds last allocated object to the container
    void pop_back();
    void clear();
    void swap(fixed_vector &#38;o) noexcept;

    // element access
    T &#38;operator[](size_t i);
    iterator begin();
    iterator end();
    T &#38;front();
    T &#38;back();

    const T &#38;operator[](size_t i) const;
    const_iterator begin() const;
    const_iterator end() const;
    const_iterator cbegin() const;
    const_iterator cend() const;
    const T &#38;front() const;
    const T &#38;back() const;
};
template&#60;class T&gt;
void swap(fixed_vector&#60;T&gt; &#38;o1, fixed_vector&#60;T&gt; &#38;o2) noexcept;
</pre><p>Стандартные контейнеры в C++98 не позволяют хранить в себе объекты, которые
нельзя копировать (недоступны копирующий конструктор и копирующее присваивание).
Даже в C++11 элементы контейнера, вроде <tt>std::vector</tt>, должны быть как
минимум noexcept-перемещаемыми. Данный класс решает эту проблему и представляет
собой массив некопируемых объектов, или <tt>std::vector</tt>,
<tt>capacity()</tt> которого не растёт автоматически.</p><p>Без использования <tt>emplace_back()</tt> невозможно создать произвольный
новый объект непосредственно в памяти контейнера. В C++98 forwarding ссылки
вообще отсутствуют, делая почти невозможным передачу произвольных параметров в
конструктор элемента. В <tt>fixed_vector</tt> это ограничение обходится с
использованием следующего механизма. Создание элемента происходит в несколько
фаз:</p><ol><li>Запрос в контейнере блока памяти, достаточного для размешения
        объекта - <tt>alloc()</tt>,</li><li>Создание объекта в полученной памяти с помощью placement new -
        <tt>new(ptr) type(...)</tt>,</li><li>Фиксация успешно созданного объекта в контейнере -
        <tt>push_allocated()</tt>.</li></ol><p>Пример кода смотрите в конце статьи.</p><p>При создании задаётся максимальная ёмкость контейнера. Изменить в будущем
её можно, но только разрушив содержащиеся в нём объекты, то есть пересоздав
контейнер.</p><p>Всегда следует использовать функцию <tt>emplace_back()</tt> для создания
элементов, когда она доступна. Если же нет, то использовать небезопасный
интерфейс, описанный выше, с большой осторожностью. Он достаточно страшный и
подверженный ошибкам, но выполняет свою функцию. После того, как элемент
размещён в контейнере, работать с ним также удобно, как и с любым другим
копируемым объектом в стандартных контейнерах. В любом случае, в целом это
гораздо удобнее и эффективнее использования альтернатив, таких как создание
объектов в куче с последующим хранением в контейнере указателей на них, даже
если нам доступен <tt>std::unique_ptr</tt> для управления временем жизни
объектов.</p><div class="section">Члены класса</div><div><pre class="prototype">typename value_type</pre><blockquote><p>Тип элементов.</p></blockquote></div><div><pre class="prototype">typename iterator</pre><pre class="prototype">typename const_iterator</pre><blockquote><p>Итераторы.</p></blockquote></div><div><pre class="prototype">fixed_vector()</pre><blockquote><p>Создаёт объект без выделения памяти под элементы.</p><div><u>Постусловие</u>: <tt>capacity() == 0</tt></div></blockquote></div><div><pre class="prototype">explicit fixed_vector(size_t max_size)</pre><blockquote><p>Создаёт контейнер ёмкости <tt>max_size</tt> элементов.</p><div><u>Постусловие</u>: <tt>capacity() == max_size</tt></div></blockquote></div><div><pre class="prototype">~fixed_vector()</pre><blockquote><p>Вызывает <tt>clear()</tt>.</p></blockquote></div><div><pre class="prototype">fixed_vector(fixed_vector &#38;&#38;o) noexcept <span class="sign">[C++11]</span></pre><pre class="prototype">fixed_vector &#38;operator=(fixed_vector &#38;&#38;o) noexcept <span class="sign">[C++11]</span></pre><blockquote><p>Операции перемещения для режима C++11.</p></blockquote></div><div><pre class="prototype">size_t size() const</pre><pre class="prototype">size_t capacity() const</pre><blockquote><p>Текущее и максимальное количество элементов в данном экземпляре контейнера.
</p></blockquote></div><div><pre class="prototype">bool empty() const</pre><blockquote><p>Возвращает <tt>size() == 0</tt>.</p></blockquote></div><div><pre class="prototype">bool full() const</pre><blockquote><p>Возвращает <tt>size() == capacity()</tt>.</p></blockquote></div><div><pre class="prototype">void recreate(size_t new_max_size, bool size_exact = false)</pre><blockquote><p>Пересоздаёт контейнер. Сначала вызывается <tt>clear()</tt>, затем
перевыделяется буфер, если <tt>new_max_size &gt; capacity()</tt> или <tt>size_exact
== true</tt> и <tt>new_max_size != capacity()</tt>.</p><div><u>Постусловие</u>: <tt>capacity() &gt;= new_max_size &#38;&#38; empty() == true</tt>
(если <tt>size_exact == true</tt>, то <tt>capacity() == new_max_size &#38;&#38;
empty() == true</tt>)</div></blockquote></div><div><pre class="prototype">void *alloc()</pre><blockquote><p>Возвращает указатель на блок памяти, достаточный для размещения экземпляра
<tt>value_type</tt>.</p><div><u>Предусловие</u>: <tt>!full()</tt></div><div><u>Замечание</u>: Используйте <tt>emplace_back()</tt> в режиме C++11.</div></blockquote></div><div><pre class="prototype">void push_allocated()</pre><blockquote><p>Фиксирует успешно созданный объект в контейнере, увеличивая <tt>size()</tt>
на единицу.</p></blockquote></div><div><pre class="prototype">template&#60;class... Args&gt; T &#38;emplace_back(Args &#38;&#38;... args) <span class="sign">[C++11]</span></pre><blockquote><p>Конструирует новый объект в контейнере с помощью переданных аргументов и
увеличивает <tt>size()</tt> на единицу (<tt>alloc()</tt> + <tt>new</tt> +
<tt>push_allocated()</tt> одним вызовом). Возвращает ссылку на новый элемент.
</p><div><u>Предусловие</u>: <tt>!full()</tt></div></blockquote></div><div><pre class="prototype">void pop_back()</pre><blockquote><p>Удаляет из контейнера последний элемент.</p><div><u>Предусловие</u>: <tt>!empty()</tt></div></blockquote></div><div><pre class="prototype">void clear()</pre><blockquote><p>Разрушает все элементы контейнера в порядке обратном порядку создания.</p><div><u>Постусловие</u>: <tt>size() == 0</tt> (<tt>empty() == true</tt>)</div></blockquote></div><div><pre class="prototype">void swap(fixed_vector &#38;o)</pre><pre class="prototype">template&#60;class T&gt; void swap(fixed_vector&#60;T&gt; &#38;o1, fixed_vector&#60;T&gt; &#38;o2) noexcept</pre><blockquote><p>Обменивается значением с <tt>o</tt>.</p></blockquote></div><div><pre class="prototype">T &#38;operator[](size_t i)</pre><pre class="prototype">const T &#38;operator[](size_t i) const</pre><blockquote><p>Доступ к элементам контейнера по индексу.</p><div><u>Предусловие</u>: <tt>i &#60; size()</tt></div></blockquote></div><div><pre class="prototype">T &#38;front()</pre><pre class="prototype">const T &#38;front() const</pre><pre class="prototype">T &#38;back()</pre><pre class="prototype">const T &#38;back() const</pre><blockquote><p>Доступ к первому и последнему элементу контейнера.</p><div><u>Предусловие</u>: <tt>!empty()</tt></div></blockquote></div><div><pre class="prototype">iterator begin()</pre><pre class="prototype">const_iterator begin() const</pre><pre class="prototype">const_iterator cbegin() const</pre><pre class="prototype">iterator end()</pre><pre class="prototype">const_iterator end() const</pre><pre class="prototype">const_iterator cend() const</pre><blockquote><p>Доступ к элементам через итераторы.</p></blockquote></div><div class="section">Пример</div><pre class="code">
// Создаём вектор на два объекта класса C
__vic::fixed_vector&#60;C&gt; v(2);

// Создание элемента в режиме C++98:
new(v.alloc()) C(...); // Запрашиваем блок памяти и создаём в нём объект
v.push_allocated();    // Фиксируем в контейнере успешно созданный объект

// Создание элемента в режиме C++11:
v.emplace_back(...);
</pre><h2 id="fs.h"><span class="h2_num">2.12</span><tt>__vic/fs.h</tt></h2><p>Утилиты для работы с файловой системой.</p><div><u><b>Замечание</b></u>: Для всех путей ожидается использование кодировки UTF-8!</div><h3 id="path_exists"><span class="h3_num">2.12.1</span><tt>path_exists()</tt>, <tt>file_exists()</tt>, <tt>dir_exists()</tt>
</h3><pre class="code">
bool path_exists(const char *path);
bool path_exists(const std::string &#38;path);

bool file_exists(const char *path);
bool file_exists(const std::string &#38;path);

bool dir_exists(const char *path);
bool dir_exists(const std::string &#38;path);
</pre><p><tt>path_exists()</tt> проверяет, существует ли путь в фаловой системе.
Вторая и третья функции дополнительно, кроме существования, проверяют,
ссылается ли путь на регулярный файл или на каталог, соответсвенно.</p><h3 id="mkdir"><span class="h3_num">2.12.2</span><tt>mkdir()</tt>, <tt>mkdir_if_absent()</tt></h3><pre class="code">
void mkdir(const char *path);
void mkdir(const std::string &#38;path);

bool mkdir_if_absent(const char *path);
bool mkdir_if_absent(const std::string &#38;path);
</pre><p>Создаёт каталог. Бросает исключения в случае ошибок.
<tt>mkdir_if_absent()</tt> возвращает <tt>false</tt> вместо исключения, если
каталог с таким именем уже существует.</p><h3 id="rmdir"><span class="h3_num">2.12.3</span><tt>rmdir()</tt>, <tt>rmdir_if_exists()</tt></h3><pre class="code">
void rmdir(const char *path);
void rmdir(const std::string &#38;path);

bool rmdir_if_exists(const char *path);
bool rmdir_if_exists(const std::string &#38;path);
</pre><p>Удаляет пустой каталог. Бросает исключения в случае ошибок.
<tt>rmdir_if_exists()</tt> возвращает <tt>false</tt> вместо исключения, если
каталога с таким именем не существует.</p><h3 id="get_current_dir"><span class="h3_num">2.12.4</span><tt>get_current_dir()</tt></h3><pre class="code">
std::string get_current_dir();
</pre><p>Возвращает текущий рабочий каталог.</p><h3 id="remove_file"><span class="h3_num">2.12.5</span><tt>remove_file()</tt>, <tt>remove_file_if_exists()</tt>,
<tt>remove_file_nt()</tt></h3><pre class="code">
void remove_file(const char *path);
void remove_file(const std::string &#38;path);

bool remove_file_if_exists(const char *path);
bool remove_file_if_exists(const std::string &#38;path);

bool remove_file_nt(const char *path) noexcept;
bool remove_file_nt(const std::string &#38;path) noexcept;
</pre><p>Удаляет файл. Бросает исключения в случае ошибок.</p><p><tt>remove_file_if_exists()</tt> возвращает <tt>false</tt> вместо
исключения, если файл с таким именем не существует.</p><p><tt>remove_file_nt()</tt> вообще не бросает исключений, а возвращает
<tt>false</tt> в случае ошибок.</p><h3 id="copy_file"><span class="h3_num">2.12.6</span><tt>copy_file()</tt>, <tt>copy_file_if_exists()</tt>,
<tt>copy_file_replace()</tt>, <tt>copy_file_replace_if_exists()</tt></h3><pre class="code">
void copy_file(
    const char *src_path, const char *dest_path, bool replace = false);
void copy_file(
    const std::string &#38;src_path, const std::string &#38;dest_path,
    bool replace = false);

bool copy_file_if_exists(
    const char *src_path, const char *dest_path, bool replace = false);
bool copy_file_if_exists(
    const std::string &#38;src_path, const std::string &#38;dest_path,
    bool replace = false);

void copy_file_replace(
    const char *src_path, const char *dest_path);
void copy_file_replace(
    const std::string &#38;src_path, const std::string &#38;dest_path);

bool copy_file_replace_if_exists(
    const char *src_path, const char *dest_path);
bool copy_file_replace_if_exists(
    const std::string &#38;src_path, const std::string &#38;dest_path);
</pre><p>Создаёт новый файл <tt>dest_path</tt>, являющийся копией файла
<tt>src_path</tt>. Вызов заканчивается ошибкой, если новый файл существует и
<tt>replace == false</tt>.</p><p><tt>copy_file_if_exists()</tt> возвращает <tt>false</tt> вместо исключения,
если файла с именем <tt>src_path</tt> не существует.</p><p><tt>copy_file_replace()</tt> - то же самое, что <tt>copy_file(..., true)</tt>.
</p><p><tt>copy_file_replace_if_exists()</tt> - то же самое, что
<tt>copy_file_if_exists(..., true)</tt>.</p><h3 id="move_file"><span class="h3_num">2.12.7</span><tt>move_file()</tt>, <tt>move_file_if_exists()</tt>,
<tt>move_file_replace()</tt>, <tt>move_file_replace_if_exists()</tt></h3><pre class="code">
void move_file(const char *src_path, const char *dest_path);
void move_file(const std::string &#38;src_path, const std::string &#38;dest_path);

bool move_file_if_exists(const char *src_path, const char *dest_path);
bool move_file_if_exists(
    const std::string &#38;src_path, const std::string &#38;dest_path);

void move_file_replace(const char *src_path, const char *dest_path);
void move_file_replace(
    const std::string &#38;src_path, const std::string &#38;dest_path);

bool move_file_replace_if_exists(
    const char *src_path, const char *dest_path);
bool move_file_replace_if_exists(
    const std::string &#38;src_path, const std::string &#38;dest_path);
</pre><p>Перемещает файл <tt>src_path</tt> в новое место, указанное в
<tt>dest_path</tt>.</p><p>Функции с суффиксом <tt>_replace</tt> перетирают целевой файл, если он
существует, остальные - возвращают ошибку в таком случае.</p><p><tt>move_file_if_exists()</tt> возвращает <tt>false</tt> вместо ошибки,
если файл с именем <tt>src_path</tt> не существует.</p><h3 id="rename_file"><span class="h3_num">2.12.8</span><tt>rename_file()</tt>, <tt>rename_file_if_exists()</tt>,
    <tt>rename_file_replace()</tt>, <tt>rename_file_replace_if_exists()</tt></h3><pre class="code">
void rename_file(const char *src_name, const char *dest_name);
void rename_file(const std::string &#38;src_name, const std::string &#38;dest_name);

bool rename_file_if_exists(const char *src_name, const char *dest_name);
bool rename_file_if_exists(
    const std::string &#38;src_name, const std::string &#38;dest_name);

void rename_file_replace(const char *src_name, const char *dest_name);
void rename_file_replace(
    const std::string &#38;src_name, const std::string &#38;dest_name);

bool rename_file_replace_if_exists(
    const char *src_name, const char *dest_name);
bool rename_file_replace_if_exists(
    const std::string &#38;src_name, const std::string &#38;dest_name);
</pre><p>Переименовывает файл <tt>src_path</tt> в <tt>dest_path</tt>. Новый путь
должен находиться на той же самой физической файловой системе.</p><p>В отличие от <tt>std::rename()</tt>, вызов функций без суффикса
<tt>_replace</tt> заканчивается ошибкой, если файл с именем <tt>dest_path</tt>
уже существует.</p><p><tt>rename_file_if_exists()</tt> возвращает <tt>false</tt> вместо
исключения, если файла с именем <tt>src_path</tt> не существует.</p><h3 id="file_size"><span class="h3_num">2.12.9</span><tt>file_size()</tt></h3><pre class="code">
uintmax_t file_size(const char *path);
uintmax_t file_size(const std::string &#38;path);
</pre><p>Возвращает размер файла в байтах.</p><h2 id="iterator.h"><span class="h2_num">2.13</span><tt>__vic/iterator.h</tt></h2><p>Инструменты работы с итераторами.</p><h3 id="begin-array"><span class="h3_num">2.13.1</span><tt>begin(T[])</tt>, <tt>end(T[])</tt>, <tt>cbegin(T[])</tt>,
<tt>cend(T[])</tt></h3><pre class="code">
template&#60;class T, size_t N&gt; constexpr T *begin(T (&#38;arr)[N]);
template&#60;class T, size_t N&gt; constexpr T *end(T (&#38;arr)[N]);

template&#60;class T, size_t N&gt; constexpr const T *cbegin(T (&#38;arr)[N]);
template&#60;class T, size_t N&gt; constexpr const T *cend(T (&#38;arr)[N]);
</pre><p>Возвращают указатели на начало и за конец массива.</p><div class="section">Пример</div><pre class="code">
int vals[] = { 1, 2, 3 };
std::list&#60;int&gt; lst(__vic::begin(vals), __vic::end(vals));
assert(lst.size() == 3);
</pre><h3 id="advance"><span class="h3_num">2.13.2</span><tt>advance()</tt></h3><pre class="code">
template&#60;class Iter&gt;
void advance(Iter &#38;it, Iter end, size_t n);
</pre><p>Функция похожа на <tt>std::advance()</tt>, но отличается по формату вызова
и поведению. Главные отличия:</p><ol><li>Позволяет двигаться только вперёд (<tt>++</tt>),</li><li>Контролирует выход за границу диапазона. Прекращает работу, если
        достигнут <tt>end</tt>.</li></ol><h3 id="next"><span class="h3_num">2.13.3</span><tt>next()</tt>, <tt>prev()</tt></h3><pre class="code">
template&#60;class ForwardIterator&gt;
ForwardIterator next(ForwardIterator it);

template&#60;class ForwardIterator&gt;
ForwardIterator next(ForwardIterator it, size_t n);

template&#60;class BidirectionalIterator&gt;
BidirectionalIterator prev(BidirectionalIterator it);

template&#60;class BidirectionalIterator&gt;
BidirectionalIterator prev(BidirectionalIterator it, size_t n);
</pre><p><tt>next()</tt> возвращает значение итератора, передвинутое вперёд на
<tt>n</tt> позиций. <tt>prev()</tt> делает то же самое, но в противоположную
сторону. В отличие от одноимённых функций из STL C++11, смещение не может быть
отрицательным. Версии с одним параметром просто вызывают
<tt>++it</tt>/<tt>--it</tt> и возвращают результат.</p><div class="section">Пример</div><pre class="code">
template&#60;class Container&gt;
void f(const Container &#38;c)
{
    // Начать обход со второго элемента
    // v.begin() + 1 работает только для RandomAccessIterator
    // ++v.begin() может вообще не скомпилироваться
    for(auto it = __vic::next(c.begin()); it != c.end(); ++it) ...;
}
</pre><h2 id="logger.h"><span class="h2_num">2.14</span><tt>__vic/logger.h</tt></h2><h3 id="logger"><span class="h3_num">2.14.1</span><tt>logger</tt></h3><pre class="code">
class logger : private non_copyable
{
public:
    enum class severity : unsigned char
    {
        trace,
        debug,
        info,
        warning,
        error,
        fatal
    };
    using severity_t = severity; // use this alias as a type name
    struct output
    {
        virtual void publish_record(severity_t , const char * , size_t ) = 0;
    protected:
        ~output() = default;
    };
    class settings_t
    {
        struct output &#38;output() const;
        severity_t level() const;
    };
    class record;

    explicit logger(output &#38;out, severity_t = severity::info);
    explicit logger(settings_t s);
    ~logger();

    severity_t level() const;
    void level(severity_t new_level);
    settings_t settings() const;
    output &#38;reset_output(output &#38;out);
    output &#38;get_output();
    const output &#38;get_output() const;

    static constexpr size_t min_buffer_size = ...;
    void shrink_buffer(size_t limit);

    void message(severity_t severity, const char *msg, size_t msg_len);
    void message(severity_t severity, const char *msg);
    void message(severity_t severity, const std::string &#38;msg);

    void trace(const char *msg);
    void debug(const char *msg);
    void info(const char *msg);
    void warning(const char *msg);
    void error(const char *msg);
    void fatal(const char *msg);

    void trace(const std::string &#38;msg);
    void debug(const std::string &#38;msg);
    void info(const std::string &#38;msg);
    void warning(const std::string &#38;msg);
    void error(const std::string &#38;msg);
    void fatal(const std::string &#38;msg);

    record trace();
    record debug();
    record info();
    record warning();
    record error();
    record fatal();

    bool trace_visible() const;
    bool debug_visible() const;
    bool info_visible() const;
    bool warning_visible() const;
    bool error_visible() const;
    bool fatal_visible() const;
};
class logger::record
{
public:
    record(logger &#38;log, severity_t sev);
    ~record();

    record append(const char *str, size_t str_len);

    template&#60;class T&gt; record operator&#60;&#60;(const T &#38;v);
};
const char *to_string(logger::severity_t s);
</pre><p>Front-end логгера. Реализует построение записей с помощью оператора
<tt>&#60;&#60;</tt>, подобно стандартной библиотеке потоков <tt>iostream</tt>.
Каждая запись лога имеет назначенный приоритет. Логгер может фильтровать вывод
записей по этому приоритету. Предопределены 6 уровней приоритета (в порядке
возрастания):</p><ol><li>TRACE - подробная отладка,</li><li>DEBUG - отладка,</li><li>INFO - информационное сообщение,</li><li>WARNING - незначительная ошибка или подозрительная ситуация,</li><li>ERROR - серьёзная ошибка, но приложение может продолжать
        работу,</li><li>FATAL - критическая ошибка, приложение не может продолжить
        выполнение.</li></ol><p>INFO является уровнем логирования по умолчанию. Если сообщение (запись)
имеет приоритет ниже текущего уровня логирования, то оно игнорируется и никуда
не выводится.</p><p>Для создания сообщений с нужным приоритетом предоставляется набор одноимённых
функций. Например, <tt>info()</tt> для сообщений INFO. Также есть универсальная
функция <tt>message()</tt>, в которой приоритет задаётся параметром, но, обычно,
следует использовать специфичные функции.</p><p>Существует 2 способа создания сообщений. Первый прост и обычен:</p><pre class="code">
log.trace("Trace message");
log.debug("Debug message");
log.info("Info message");
log.warning("Warning message");
log.error("Recoverable error");
log.fatal("Fatal error");
</pre><p>Второй немного более сложен, но предоставляет гораздо большие возможности:</p><pre class="code">
log.error() &#60;&#60; "Cannot open file " &#60;&#60; filename &#60;&#60; '!';
log.warning() &#60;&#60; "Loop iteration no " &#60;&#60; i;
</pre><p>Вызов функции без параметров создаёт объект типа <tt>logger::record</tt> с
соответствующим приоритетом. Теперь в него можно писать сообщение с
использованием оператора <tt>&#60;&#60;</tt>. Сформированная запись будет
выведена в лог по завершении вычисления «полного выражения» (термин из
Стандарта)</p><p>Если сформировать запись лога сложно или невозможно одним выражением, то
следует явно создать объект <tt>logger::record</tt> и писать в него. Запись
будет выведена с лог при вызове деструктора данного объекта:</p><pre class="code">
{
    logger::record rec = log.info(); // Начало формирования записи
    rec &#60;&#60; "List elements: ";
    for(auto el : list) rec &#60;&#60; el &#60;&#60; ", ";
    // Сформированная запись попадёт в лог при выходе из блока
}
</pre><div><u><b>Замечание</b></u>: В целях повышения эффективности используйте обычную функциональную запись,
если строка уже готова для вывода:</div><pre class="code">
log.info("Message");
// а не
log.info() &#60;&#60; "Message";
</pre><p>Вывод записей с приоритетами DEBUG и TRACE обычно отключен в нормальных
условиях. Такие записи хоть и не попадут в лог, но время на их форматирование
всё равно будет тратиться. Поэтому перед попыткой сформировать какую-нибудь
отладочную запись с помощью операторов <tt>&#60;&#60;</tt> проверьте, включена ли
отладка, с помощью вызова <tt>debug_visible()</tt> или <tt>trace_visible()</tt>:
</p><pre class="code">
if(log.debug_visible())
    log.debug() &#60;&#60; ...; // формируем запись
</pre><p>Это не относится к обычным вызовам <tt>debug(msg)</tt> и <tt>trace(msg)</tt>,
которым передаётся уже готовая к выводу строка, и никакого дополнительного
форматирования не требуется.</p><p>Для использования <tt>logger</tt> нужно реализовать абстрактный базовый класс
<tt>logger::output</tt> (определить <tt>publish_record()</tt>). Реализация
должна вывести куда-то сформированную запись, например, в файл или БД.
<tt>output</tt>, переданный в <tt>logger</tt> при конструировании, впоследствии
можно заменить с помощью вызова <tt>reset_output()</tt>.</p><div class="section">Члены класса</div><div><pre class="prototype">severity::trace</pre><pre class="prototype">severity::debug</pre><pre class="prototype">severity::info</pre><pre class="prototype">severity::warning</pre><pre class="prototype">severity::error</pre><pre class="prototype">severity::fatal</pre><blockquote><p>Константы приоритетов и уровней логирования. Данная форма используется как в
режиме C++11, так и в C++98.</p></blockquote></div><div><pre class="prototype">typename severity_t</pre><blockquote><p>Используйте данный идентификатор, если коду требуется совместимость с режимом
C++98. Начиная с C++11 это просто синоним <tt>severity</tt>.</p></blockquote></div><div><pre class="prototype">class output</pre><blockquote><p>Интерфейс back-end'а логирования.</p></blockquote></div><div><pre class="prototype">void output::publish_record(severity_t sev, const char *buf, size_t buf_len)</pre><blockquote><p>Реализация этой чисто виртуальной функции должна вывести содержимое
<tt>buf</tt> длиной <tt>buf_len</tt> в лог как одну запись. Функция вызывается
только когда переданный <tt>sev &gt;= level()</tt>. Реализация может полагаться на
это предусловие.</p></blockquote></div><div><pre class="prototype">class settings_t</pre><blockquote><p>Хранит настройки логгера: уровень логирования и ссылку на вывод
(<tt>level()</tt> + <tt>get_output()</tt>).</p></blockquote></div><div><pre class="prototype">explicit logger(output &#38;out, severity_t level = severity::info)</pre><blockquote><p>Создаёт логгер с данным выводом и уровнем логирования. Время жизни объекта,
на который ссылается <tt>out</tt>, должно превосходить время жизни логгера!</p><div><u>Постусловие</u>: <tt>this-&gt;level() == level &#38;&#38; &#38;this-&gt;get_output() == &#38;out</tt></div></blockquote></div><div><pre class="prototype">explicit logger(settings_t s)</pre><blockquote><p>Создаёт логгер с указанными настройками.</p></blockquote></div><div><pre class="prototype">severity_t level() const</pre><blockquote><p>Возвращает текущий уровень логирования.</p></blockquote></div><div><pre class="prototype">void level(severity_t new_level)</pre><blockquote><p>Устанавливает уровень логирования.</p><div><u>Постусловие</u>: <tt>level() == new_level</tt></div></blockquote></div><div><pre class="prototype">settings_t settings() const</pre><blockquote><p>Возвращает текущие настройки.</p></blockquote></div><div><pre class="prototype">output &#38;reset_output(output &#38;out)</pre><blockquote><p>Устанавливает новый вывод и возвращает старый.</p><div><u>Постусловие</u>: <tt>&#38;get_output() == &#38;out</tt></div></blockquote></div><div><pre class="prototype">output &#38;get_output()</pre><pre class="prototype">const output &#38;get_output() const</pre><blockquote><p>Возвращает ссылку на текущий вывод.</p></blockquote></div><div><pre class="prototype">static constexpr size_t min_buffer_size</pre><blockquote><p>Минимальный размер внутреннего буфера в байтах.</p></blockquote></div><div><pre class="prototype">void shrink_buffer(size_t limit)</pre><blockquote><p>Устанавливает размер внутреннего буфера в <tt>min_buffer_size</tt>, если он
превосходит <tt>limit</tt> байтов. Позволяет предотвратить бесконрольное
разрастание используемой памяти при выводе записей большого размера.</p></blockquote></div><div><pre class="prototype">void message(severity_t severity, const char *msg, size_t msg_len)</pre><pre class="prototype">void message(severity_t severity, const char *msg)</pre><pre class="prototype">void message(severity_t severity, const std::string &#38;msg)</pre><blockquote><p>Выводит сообщение с заданным приоритетом.</p></blockquote></div><div><pre class="prototype">void trace(const char *msg)</pre><pre class="prototype">void trace(const std::string &#38;msg)</pre><pre class="prototype">void debug(const char *msg)</pre><pre class="prototype">void debug(const std::string &#38;msg)</pre><pre class="prototype">void info(const char *msg)</pre><pre class="prototype">void info(const std::string &#38;msg)</pre><pre class="prototype">void warning(const char *msg)</pre><pre class="prototype">void warning(const std::string &#38;msg)</pre><pre class="prototype">void error(const char *msg)</pre><pre class="prototype">void error(const std::string &#38;msg)</pre><pre class="prototype">void fatal(const char *msg)</pre><pre class="prototype">void fatal(const std::string &#38;msg)</pre><blockquote><p>Выводит сообщение с соответствующим приоритетом.</p></blockquote></div><div><pre class="prototype">logger::record trace()</pre><pre class="prototype">logger::record debug()</pre><pre class="prototype">logger::record info()</pre><pre class="prototype">logger::record warning()</pre><pre class="prototype">logger::record error()</pre><pre class="prototype">logger::record fatal()</pre><blockquote><p>Создаёт новую запись c соответствующим приоритетом и позволяет писать в неё
части сообщения с помощью оператора <tt>&#60;&#60;</tt>.</p></blockquote></div><div><pre class="prototype">bool trace_visible() const</pre><pre class="prototype">bool debug_visible() const</pre><pre class="prototype">bool info_visible() const</pre><pre class="prototype">bool warning_visible() const</pre><pre class="prototype">bool error_visible() const</pre><pre class="prototype">bool fatal_visible() const</pre><blockquote><p>Возвращает <tt>true</tt>, если запись с указанным уровнем логирования будет
выведена в лог при текущих настройках. Использование данных функций позволяет
исключить форматирование сообщений, которые всё равно не попадут в лог.</p></blockquote></div><div><pre class="prototype">record::record(logger &#38;log, severity_t sev)</pre><blockquote><p>Создаёт запись лога с указанным приоритетом. Обычно вместо явного вызова
данного конструктора следует использовать функции <tt>logger</tt>’а, вроде
<tt>info()</tt> без параметров, для создания объекта.</p></blockquote></div><div><pre class="prototype">record::~record()</pre><blockquote><p>Выводит сформированную запись в лог.</p></blockquote></div><div><pre class="prototype">record record::append(const char *str, size_t str_len)</pre><blockquote><p>Добавляет строку к сообщению.</p></blockquote></div><div><pre class="prototype">template&#60;class T&gt; record record::operator&#60;&#60;(const T &#38;v)</pre><blockquote><p>Набор инсертеров для различных типов данных. Вызывают <tt>sb &#60;&#60; v</tt>,
где <tt>sb</tt> имеет тип <tt>__vic::string_buffer</tt>.</p></blockquote></div><div class="section">Свободные функции</div><div><pre class="prototype">const char *to_string(logger::severity_t s)</pre><blockquote><p>Преобразует приоритет записи лога в текстовое представление, которое можно,
например, вывести в лог. Пример: для <tt>severity::debug</tt> возвращается
"<tt>DEBUG</tt>" и т.п.</p></blockquote></div><div class="section">Пример</div><pre class="code">
/////////////////////////////////////////////////////////////////////////////
// Вывод сообщений в std::clog с указанием приоритета
class coutput : public __vic::logger::output
{
public:
    void publish_record(__vic::logger::severity_t s,
                            const char *rec, size_t rec_n)
    {
        std::clog &#60;&#60; to_string(s) &#60;&#60; ": ";
        std::clog.write(rec, rec_n) &#60;&#60; std::endl;
    }
};
/////////////////////////////////////////////////////////////////////////////

int main()
{
    coutput log_output:
    __vic::logger log(log_output, __vic::logger::severity::debug);

    log.info("Application is started");

    for(int i = 0; i &#60; 5; i++)
        log.debug() &#60;&#60; "Loop i = " &#60;&#60; i;

    log.warning("Application end");
}
</pre><p>Результат:</p><pre class="code">
INFO: Application is started
DEBUG: Loop i = 0
DEBUG: Loop i = 1
DEBUG: Loop i = 2
DEBUG: Loop i = 3
DEBUG: Loop i = 4
WARNING: Application end
</pre><h2 id="memory.h"><span class="h2_num">2.15</span><tt>__vic/memory.h</tt></h2><p>Утилиты для работы с памятью.</p><h3 id="load_unaligned"><span class="h3_num">2.15.1</span><tt>load_unaligned()</tt></h3><pre class="code">
template&#60;class T&gt;
T load_unaligned(const void *p);
</pre><p>Загружает значение с потенциально невыровненного адреса не вызывая ошибку
шины (<tt>SIGBUS</tt>).</p><div class="section">Пример</div><pre class="code">
const void *p = ...;
// int data = *static_cast&#60;const int *&gt;(p); // потенциальная ошибка шины
int data = __vic::load_unaligned&#60;int&gt;(p);
</pre><h2 id="mutex.h"><span class="h2_num">2.16</span><tt>__vic/mutex.h</tt></h2><h3 id="mutex"><span class="h3_num">2.16.1</span><tt>mutex</tt></h3><pre class="code">
class mutex : private non_copyable
{
public:
    mutex();
    ~mutex();

    void lock();
    bool try_lock();
    bool unlock() noexcept;
};
</pre><p>Обычный нерекурсивный мьютекс.</p><div class="section">Замечания по использованию</div><p>В большинстве случаев, явного использования <tt>lock()</tt> и
<tt>unlock()</tt> нужно избегать. Вместо этого используйте класс
<a href="#mutex_lock"><tt>mutex_lock</tt></a> для управления блокировкими. Он обеспечивает
безопасность при исключениях и удобен для использования.</p><p>В режиме C++11 <tt>std::mutex</tt> может быть более подходящим вариантом.</p><div class="section">Члены класса</div><div><pre class="prototype">mutex()</pre><blockquote><p>Создаёт незаблокированный мьютекс.</p></blockquote></div><div><pre class="prototype">~mutex()</pre><blockquote><p>Уничтожает мьютекс.</p></blockquote></div><div><pre class="prototype">void lock()</pre><blockquote><p>Захватывает блокировку на мьютексе. Ждёт его освобождения, если он уже
захвачен другим потоком в данный момент.</p></blockquote></div><div><pre class="prototype">bool try_lock()</pre><blockquote><p>Пытается захватить мьютекс. Немедленно возвращает <tt>false</tt> без
ожидания, если он уже захвачен другим потоком.</p></blockquote></div><div><pre class="prototype">bool unlock() noexcept</pre><blockquote><p>Освобождает ранее захваченный мьютекс. Иногда может возвращать <tt>false</tt>
в случае ошибок, но в общем случае обнаружение ошибок не гарантируется.</p></blockquote></div><div class="section">Пример</div><p>См. <a href="#mutex_lock"><tt>mutex_lock</tt></a>.</p><h3 id="mutex_lock"><span class="h3_num">2.16.2</span><tt>mutex_lock</tt></h3><pre class="code">
class mutex_lock : private non_copyable
{
public:
    enum adopt_t { adopt };

    explicit mutex_lock(mutex &#38;mtx);
    mutex_lock(mutex &#38;mtx, adopt_t);
    ~mutex_lock();
};
</pre><p>Управляет блокировкой на мьютексе. Снимает блокировку по окончании времени
жизни объекта.</p><div class="section">Члены класса</div><div><pre class="prototype">adopt</pre><blockquote><p>Тэг конструктора, подавляет захват мьютекса.</p></blockquote></div><div><pre class="prototype">explicit mutex_lock(mutex &#38;mtx)</pre><blockquote><p>Захватывает <tt>mtx</tt>.</p></blockquote></div><div><pre class="prototype">~mutex_lock()</pre><blockquote><p>Освобождает <tt>mtx</tt>.</p></blockquote></div><div><pre class="prototype">mutex_lock(mutex &#38;mtx, adopt_t)</pre><blockquote><p>Принимает уже захваченный <tt>mtx</tt>. См. пример.</p></blockquote></div><div class="section">Пример</div><pre class="code">
// Типичное использование
__vic::mutex mtx;
void reentrant_function()
{
    __vic::mutex_lock lock(mtx);
    // Критическая секция до конца этого блока
    ...
}

// Использование незахватывающего конструктора
if(mtx.try_lock()) // Пытаемся захватить мьютекс
{
    // Мьютекс успешно захвачен
    __vic::mutex_lock lock(mtx, __vic::mutex_lock::adopt);
    // Критическая секция до конца этого блока
    ...
}
else
{
    // Мьютекс удерживается другим потоком
    ...
}
</pre><h2 id="packon.h"><span class="h2_num">2.17</span><tt>__vic/packon.h</tt> &#38; <tt>__vic/packoff.h</tt></h2><p>Включение первого файла отключает выравнивание полей структур. Другими
словами, включает «упаковку структур» - размер структуры - это строго сумма
размеров его полей. Включение второго файла восстанавливает выравнивание,
используемое по умолчанию. Таким образом, пара директив <tt>#include</tt>
формируют секцию исходного файла с отключенным выравниванием сруктур.</p><div><u><b>Замечание</b></u>: Каждый <tt>#include&#60;__vic/packon.h&gt;</tt> должен иметь соответсвующий
<tt>#include&#60;__vic/packoff.h&gt;</tt>.</div><div class="section">Пример</div><pre class="code">
struct unpacked
{
    bool f1;
    int f2;
};
static_assert(sizeof(unpacked) &gt;= sizeof(bool) + sizeof(int),
    "Total struct size can exceed the sum of members sizes");

#include&#60;__vic/packon.h&gt; // выравнивание отключено, начиная отсюда

struct packed
{
    bool f1;
    int f2;
};
static_assert(sizeof(packed) == sizeof(bool) + sizeof(int),
    "Total struct size is exactly the sum of members sizes");

#include&#60;__vic/packoff.h&gt; // выравнивание снова включено
</pre><h2 id="readers"><span class="h2_num">2.18</span><tt>__vic/readers/</tt></h2><h3 id="reader-concept"><span class="h3_num">2.18.1</span><tt>Reader</tt> concept</h3><pre class="code">
template&#60;class ElementT&gt;
class <span class="nonterminal">Reader</span>
{
public:
    Reader(Reader &#38;&#38;o); or Reader(const Reader &#38;o);
    bool read(ElementT &#38;v); // throws on errors
};
</pre><p>Concept, используемый алгоритмами библиотеки для поэлементного чтения
логической последовательности элементов типа <tt>ElementT</tt>. Является
обобщением и переработкой concept'а <tt>InputIterator</tt>. В частности,
он лучше обрабатывает потоки ввода/вывода, строки с нулевым терминатором и
другие последовательности, в которых <tt>end</tt>-итератор не имеет смысла или
его получение дорого. В то же время, традиционные пары итераторов
[<tt>begin</tt>,<tt>end</tt>) являются просто частным случаем и полностью
поддерживаются адаптером <tt>__vic::iterator_reader</tt>.</p><p>В случаях, когда конкретный класс удовлетворяет требованиям данного concept
для некоторого <tt>ElementT = T</tt>, говорят, что он <b>моделирует</b> concept
<tt>Reader&#60;T&gt;</tt>.</p><p>Каждый экземпляр класса должен быть move- или copy-constructible.</p><div class="section">Члены класса</div><div><pre class="prototype">bool read(ElementT &#38;v)</pre><blockquote><p>Пытается получить следующий элемент последовательности. Возвращает
<tt>true</tt> и помещает прочитанное значение в <tt>v</tt> в случае успеха.
Возвращает <tt>false</tt>, если больше элементов не осталось (EOF). Бросает
исключения в остальных случаях.</p></blockquote></div><h3 id="iterator_reader"><span class="h3_num">2.18.2</span><tt>iterator_reader</tt></h3><pre class="code">
#include&#60;__vic/readers/iterator.h&gt;

template&#60;class InputIterator,
         class T = typename std::iterator_traits&#60;InputIterator&gt;::value_type&gt;
class iterator_reader
{
public:
    iterator_reader(InputIterator begin, InputIterator end);
    bool read(T &#38;v);
    InputIterator position() const;
};

template&#60;class InputIterator&gt; iterator_reader&#60;InputIterator&gt;
make_iterator_reader(InputIterator begin, InputIterator end);

template&#60;class T, class InputIterator&gt; iterator_reader&#60;InputIterator,T&gt;
make_iterator_reader_for(InputIterator begin, InputIterator end);
</pre><p>Адаптер для традиционной [<tt>begin</tt>,<tt>end</tt>) пары итераторов.</p><p>Дополнительная функция <tt>position()</tt> возвращает текущую позицию
итератора внутри диапазона.</p><p>Может быть создан с помощью конструктора или одной из функций
<tt>make_...</tt>.</p><h3 id="iterator_reader_n"><span class="h3_num">2.18.3</span><tt>iterator_reader_n</tt></h3><pre class="code">
#include&#60;__vic/readers/iterator.h&gt;

template&#60;class InputIterator,
         class T = typename std::iterator_traits&#60;InputIterator&gt;::value_type&gt;
class iterator_reader_n
{
public:
    iterator_reader_n(InputIterator begin, size_t n);
    bool read(T &#38;v);
    InputIterator position() const;
};

template&#60;class InputIterator&gt; iterator_reader_n&#60;InputIterator&gt;
make_iterator_reader_n(InputIterator begin, size_t n);

template&#60;class T, class InputIterator&gt; iterator_reader_n&#60;InputIterator,T&gt;
make_iterator_reader_n_for(InputIterator begin, size_t n);
</pre><p>Адаптер для итератора со счётчиком элементов.</p><p>Дополнительная функция <tt>position()</tt> возвращает текущую позицию
итератора внутри диапазона.</p><p>Может быть создан с помощью конструктора или одной из функций
<tt>make_...</tt>.</p><h3 id="container_reader"><span class="h3_num">2.18.4</span><tt>container_reader</tt></h3><pre class="code">
#include&#60;__vic/readers/container.h&gt;

template&#60;class Cont, class T = typename Cont::value_type&gt;
class container_reader
{
public:
    explicit container_reader(const Cont &#38;c);
    bool read(T &#38;v);
    typename Cont::const_iterator position() const;
};

template&#60;class Cont&gt;
container_reader&#60;Cont&gt; make_container_reader(const Cont &#38;c);

template&#60;class T, class Cont&gt;
container_reader&#60;Cont,T&gt; make_container_reader_for(const Cont &#38;c);
</pre><p>Адаптер для контейнеров в стиле STL, имеющих члены <tt>begin()</tt> и
<tt>end()</tt>.</p><p>Дополнительная функция <tt>position()</tt> возвращает текущую позицию
итератора внутри диапазона.</p><p>Может быть создан с помощью конструктора или одной из функций
<tt>make_...</tt>.</p><h3 id="cstring_reader"><span class="h3_num">2.18.5</span><tt>cstring_reader</tt></h3><pre class="code">
#include&#60;__vic/readers/cstring.h&gt;

template&#60;class charT&gt;
class basic_cstring_reader
{
public:
    explicit basic_cstring_reader(const charT *s);
    bool read(charT &#38;ch);
    const charT *position() const;
};

template&#60;&gt;
class basic_cstring_reader&#60;char&gt;
{
public:
    explicit basic_cstring_reader(const char *s);
    bool read(char &#38;ch);
    bool read(unsigned char &#38;ch);
    const char *position() const;
};
using cstring_reader = basic_cstring_reader&#60;char&gt;;

template&#60;class charT&gt;
basic_cstring_reader&#60;charT&gt; make_cstring_reader(const charT *s);
</pre><p>Адаптер для C-строк с нулевым терминатором.</p><p>Дополнительная функция <tt>position()</tt> возвращает текущую позицию
указателя внутри строки.</p><p>Специализация для <tt>char</tt> моделирует как <tt>Reader&#60;char&gt;</tt>,
так и<tt>Reader&#60;unsigned char&gt;</tt>.</p><p>Может быть создан с помощью конструктора или функции <tt>make_...</tt>.</p><h3 id="string_reader"><span class="h3_num">2.18.6</span><tt>string_reader</tt></h3><pre class="code">
#include&#60;__vic/readers/string.h&gt;

template&#60;
    class charT,
    class Tr = std::char_traits&#60;charT&gt;,
    class Al = std::allocator&#60;charT&gt;
&gt;
class basic_string_reader
{
public:
    explicit basic_string_reader(const std::basic_string&#60;charT,Tr,Al&gt; &#38;s);
    bool read(charT &#38;ch);
    const charT *position() const;
};

template&#60;class Tr, class Al&gt;
class basic_string_reader&#60;char,Tr,Al&gt;
{
public:
    explicit basic_string_reader(const std::basic_string&#60;char,Tr,Al&gt; &#38;s);
    bool read(char &#38;ch);
    bool read(unsigned char &#38;ch);
    const char *position() const;
};
using string_reader = basic_string_reader&#60;char&gt;;

template&#60;class charT, class Tr, class Al&gt;
basic_string_reader&#60;charT,Tr,Al&gt;
    make_string_reader(const std::basic_string&#60;charT,Tr,Al&gt; &#38;s);
</pre><p>Адаптер для <tt>std::basic_string</tt>.</p><p>Дополнительная функция <tt>position()</tt> возвращает текущую позицию
указателя внутри строки.</p><p>Специализация для <tt>char</tt> моделирует как <tt>Reader&#60;char&gt;</tt>,
так и <tt>Reader&#60;unsigned char&gt;</tt>.</p><p>Может быть создан с помощью конструктора или функции <tt>make_...</tt>.</p><h3 id="cstream_reader"><span class="h3_num">2.18.7</span><tt>cstream_reader</tt></h3><pre class="code">
#include&#60;__vic/readers/cstream.h&gt;

class cstream_reader
{
public:
    explicit cstream_reader(std::FILE *fp);
    bool read(char &#38;ch) { return __vic::read(fp, ch); }
    bool read(unsigned char &#38;ch) { return __vic::read(fp, ch); }
};

cstream_reader make_cstream_reader(std::FILE *fp);
</pre><p>Моделирует <tt>Reader&#60;char&gt;</tt> и <tt>Reader&#60;unsigned char&gt;</tt> для
<tt>std::FILE</tt>.</p><p>Может быть создан с помощью конструктора или функции <tt>make_...</tt>.</p><h2 id="readonly_cstring.h"><span class="h2_num">2.19</span><tt>__vic/readonly_cstring.h</tt></h2><h3 id="readonly_cstring"><span class="h3_num">2.19.1</span><tt>readonly_cstring</tt></h3><pre class="code">
class readonly_cstring
{
public:
    readonly_cstring();
    readonly_cstring(const char *str);
    readonly_cstring(const char *begin, const char *end);
    readonly_cstring(const char *chars, size_t n);
    readonly_cstring(const readonly_cstring &#38;str);
    ~readonly_cstring() noexcept;

    // BEGIN C++11
    readonly_cstring(readonly_cstring &#38;&#38;str) noexcept;
    readonly_cstring &#38;operator=(readonly_cstring &#38;&#38;str) noexcept;
    // END C++11

    readonly_cstring &#38;operator=(const char *str);
    readonly_cstring &#38;operator=(const readonly_cstring &#38;str);
    readonly_cstring &#38;assign(const char *begin, const char *end);
    readonly_cstring &#38;assign(const char *chars, size_t n);

    char *reserve(size_t n);

    int compare(const char *str) const;
    bool empty() const;
    const char *c_str() const;
    operator const char*() const;

    void swap(readonly_cstring &#38;str) noexcept;
};

int compare(const readonly_cstring &#38;s1, const readonly_cstring &#38;s2);
int compare(const readonly_cstring &#38;s1, const char *s2);
int compare(const char *s1, const readonly_cstring &#38;s2);

bool operator==(const readonly_cstring &#38;s1, const readonly_cstring &#38;s2);
bool operator!=(const readonly_cstring &#38;s1, const readonly_cstring &#38;s2);
bool operator&#60;(const readonly_cstring &#38;s1, const readonly_cstring &#38;s2);
bool operator&gt;(const readonly_cstring &#38;s1, const readonly_cstring &#38;s2);
bool operator&#60;=(const readonly_cstring &#38;s1, const readonly_cstring &#38;s2);
bool operator&gt;=(const readonly_cstring &#38;s1, const readonly_cstring &#38;s2);

bool operator==(const readonly_cstring &#38;s1, const char *s2);
bool operator!=(const readonly_cstring &#38;s1, const char *s2);
bool operator&#60;(const readonly_cstring &#38;s1, const char *s2);
bool operator&gt;(const readonly_cstring &#38;s1, const char *s2);
bool operator&#60;=(const readonly_cstring &#38;s1, const char *s2);
bool operator&gt;=(const readonly_cstring &#38;s1, const char *s2);

bool operator==(const char *s1, const readonly_cstring &#38;s2);
bool operator!=(const char *s1, const readonly_cstring &#38;s2);
bool operator&#60;(const char *s1, const readonly_cstring &#38;s2);
bool operator&gt;(const char *s1, const readonly_cstring &#38;s2);
bool operator&#60;=(const char *s1, const readonly_cstring &#38;s2);
bool operator&gt;=(const char *s1, const readonly_cstring &#38;s2);

void swap(readonly_cstring &#38;s1, readonly_cstring &#38;s2) noexcept;
</pre><p>Простой класс неизменяемой строки с нулевым терминатором, автоматически
управляющий памятью. Имеет простейшую предсказуемую структуру, что может быть
полезно для обеспечения двоичной совместимости или в случаях, когда
использование <tt>std::string</tt> нежелательно по каким-либо причинам.
Функциональность класса также минимальна. Она обеспечивает копирование и
хранение строки, а также доступ к ней на чтение. Модифицировать строку нельзя –
только заменять полностью на другую.</p><p>Если Вам нужно хранить в классе строковое значение, то использование данного
типа для строкового поля – это хороший вариант. Это более удобно, универсально
и безопасно, чем массив символов (<tt>char[]</tt>) и часто более эффективно,
чем <tt>std::string</tt>, хотя, конечно, менее универсально. Если строку
предстоит часто редактировать (не считая полной замены), то лучше рассмотреть
альтернативные варианты представления, например <tt>__vic::string_buffer</tt>.
Класс <tt>readonly_cstring</tt> разработан не для этих целей.</p><div class="section">Гарантии, предоставляемые дизайном класса</div><ul><li>Пустой указатель корректно воспринимается как пустая строка.</li><li>Преобразователь в C-строку (<tt>const char *</tt>) всегда возвращает
        корректный указатель, никогда не возвращается <tt>nullptr</tt>.</li><li>Хранимая строка занимает в памяти ровно столько места, сколько ей
        требуется. Никогда не резервируется дополнительная память.</li><li>Набор полей-данных состоит только из одного поля – указателя на
        хранимую строку. Поэтому, если компилятор не применяет выравнивание,
        размер объекта будет равен размеру указателя.</li></ul><div class="section">Члены класса</div><div><pre class="prototype">readonly_cstring()</pre><blockquote><p>Создаёт пустую строку.</p><div><u>Постусловие</u>: <tt>empty() == true</tt></div></blockquote></div><div><pre class="prototype">readonly_cstring(const char *str)</pre><pre class="prototype">readonly_cstring(const readonly_cstring &#38;str)</pre><blockquote><p>Создаёт копию <tt>str</tt>.</p></blockquote></div><div><pre class="prototype">readonly_cstring(const char *begin, const char *end)</pre><pre class="prototype">readonly_cstring(const char *chars, size_t n)</pre><blockquote><p>Создаёт строку из диапазона символов.</p></blockquote></div><div><pre class="prototype">readonly_cstring &#38;operator=(const char *str)</pre><pre class="prototype">readonly_cstring &#38;operator=(const readonly_cstring &#38;str)</pre><blockquote><p>Присваивает <tt>str</tt>.</p></blockquote></div><div><pre class="prototype">readonly_cstring(readonly_cstring &#38;&#38;str) noexcept <span class="sign">[C++11]</span></pre><pre class="prototype">readonly_cstring &#38;operator=(readonly_cstring &#38;&#38;str) noexcept <span class="sign">[C++11]</span></pre><blockquote><p>Операции перемещения для режима C++11.</p></blockquote></div><div><pre class="prototype">readonly_cstring &#38;assign(const char *begin, const char *end)</pre><pre class="prototype">readonly_cstring &#38;assign(const char *chars, size_t n)</pre><blockquote><p>Присваивает строку из диапазона символов.</p></blockquote></div><div><pre class="prototype">char *reserve(size_t n)</pre><blockquote><p>Резервирует внутренний буфер в <tt>n</tt> символов и возвращает указатель на
него. Бывает полезно для использования с функциями вроде <tt>std::sprintf()</tt>.
</p><div><u>Замечание</u>: Используйте как можно реже данную опасную функцию!</div></blockquote></div><div><pre class="prototype">int compare(const char *str) const</pre><blockquote><p>Сравнивает строку с <tt>str</tt>. Возвращаемые значения аналогичны
<tt>std::strcmp</tt>.</p></blockquote></div><div><pre class="prototype">bool empty() const</pre><blockquote><p>Возвращает <tt>true</tt>, если строка пустая.</p></blockquote></div><div><pre class="prototype">const char *c_str() const</pre><pre class="prototype">operator const char*() const</pre><blockquote><p>Возвращает указатель на хранимую строку. Возвращаемый указатель никогда не
бывает пустым.</p></blockquote></div><div><pre class="prototype">void swap(readonly_cstring &#38;str) noexcept</pre><blockquote><p>Меняется содержимым с <tt>str</tt>.</p></blockquote></div><div class="section">Свободные функции</div><div><pre class="prototype">int compare(const readonly_cstring &#38;s1, const readonly_cstring &#38;s2)</pre><pre class="prototype">int compare(const readonly_cstring &#38;s1, const char *s2)</pre><pre class="prototype">int compare(const char *s1, const readonly_cstring &#38;s2)</pre><blockquote><p>Сравнивает две строки аналогично <tt>std::strcmp</tt>.</p></blockquote></div><div><pre class="prototype">bool operator==(const readonly_cstring &#38;s1, const readonly_cstring &#38;s2)</pre><pre class="prototype">...</pre><pre class="prototype">bool operator&gt;=(const char *s1, const readonly_cstring &#38;s2)</pre><blockquote><p>Полный набор операторов сравнения <tt>readonly_cstring</tt> и
<tt>const char *</tt> в различных сочетаниях.</p></blockquote></div><div><pre class="prototype">void swap(readonly_cstring &#38;s1, readonly_cstring &#38;s2) noexcept</pre><blockquote><p>Специализация стандартного алгоритма.</p></blockquote></div><div class="section">Пример</div><pre class="code">
class C
{
    __vic::readonly_cstring st;
public:
    explicit C(const char *str) : st(str) {}
    const char *get_str() const { return st; }
};
</pre><h2 id="set_of_chars.h"><span class="h2_num">2.20</span><tt>__vic/set_of_chars.h</tt></h2><h3 id="set_of_chars"><span class="h3_num">2.20.1</span><tt>set_of_chars</tt></h3><pre class="code">
class set_of_chars
{
public:
    constexpr set_of_chars();
    template&#60;class Iter&gt; constexpr set_of_chars(Iter begin, Iter end);
    constexpr set_of_chars(std::initializer_list&#60;char&gt; set); // C++11
    constexpr set_of_chars(const char *c_str);

    constexpr bool contains(char ch) const;

    constexpr void add(char ch);
    constexpr void remove(char ch);

    template&#60;class Iter&gt; constexpr void add(Iter begin, Iter end);
    constexpr void add(const char *c_str);
    constexpr void add(std::initializer_list&#60;char&gt; set); // C++11

    template&#60;class Iter&gt; void assign(Iter begin, Iter end);
    void assign(const char *c_str)
    void assign(std::initializer_list&#60;char&gt; set); // C++11

    void clear();
};
</pre><p>Компактная (всего 32 байта) и очень быстрая реализация множества символов.
Операция <tt>contains()</tt> всегда выполняется за константное время, независимо
от аргумента и количества элементов во множестве.</p><div class="section">Члены класса</div><div><pre class="prototype">constexpr set_of_chars()</pre><blockquote><p>Создаёт пустое множество.</p><div><u>Постусловие</u>: <tt>contains(char(ch)) == false</tt> для любого символа
</div></blockquote></div><div><pre class="prototype">template&#60;class Iter&gt; constexpr set_of_chars(Iter begin, Iter end)</pre><pre class="prototype">constexpr set_of_chars(std::initializer_list&#60;char&gt; set) <span class="sign">[C++11]</span></pre><blockquote><p>Создаёт множество, заполненное символами из указанного диапазона значений.
</p><div><u>Замечание</u>: <tt>constexpr</tt> только начиная с C++14!</div></blockquote></div><div><pre class="prototype">constexpr set_of_chars(const char *c_str)</pre><blockquote><p>Создаёт множество, заполненное символами указанной C-строки, исключая
нулевой терминатор.</p><div><u>Замечание</u>: <tt>constexpr</tt> только начиная с C++14!</div></blockquote></div><div><pre class="prototype">bool contains(char ch) const</pre><blockquote><p>Проверяет, содержит ли множество <tt>ch</tt>.</p></blockquote></div><div><pre class="prototype">constexpr void add(char ch)</pre><blockquote><p>Добавляет <tt>ch</tt> во множество.</p><div><u>Постусловие</u>: <tt>contains(ch) == true</tt></div><div><u>Замечание</u>: <tt>constexpr</tt> только начиная с C++14!</div></blockquote></div><div><pre class="prototype">constexpr void remove(char ch)</pre><blockquote><p>Удаляет <tt>ch</tt> из множества.</p><div><u>Постусловие</u>: <tt>contains(ch) == false</tt></div><div><u>Замечание</u>: <tt>constexpr</tt> только начиная с C++14!</div></blockquote></div><div><pre class="prototype">template&#60;class Iter&gt; constexpr void add(Iter begin, Iter end)</pre><pre class="prototype">constexpr void add(std::initializer_list&#60;char&gt; set) <span class="sign">[C++11]</span></pre><blockquote><p>Вызывает <tt>add(ch)</tt> для каждого значения из диапазона.</p><div><u>Замечание</u>: <tt>constexpr</tt> только начиная с C++14!</div></blockquote></div><div><pre class="prototype">constexpr void add(const char *c_str)</pre><blockquote><p>Вызывает <tt>add(ch)</tt> для каждого символа C-строки, исключая нулевой
терминатор.</p><div><u>Замечание</u>: <tt>constexpr</tt> только начиная с C++14!</div></blockquote></div><div><pre class="prototype">template&#60;class Iter&gt; void assign(Iter begin, Iter end)</pre><pre class="prototype">void assign(const char *c_str)</pre><pre class="prototype">void assign(std::initializer_list&#60;char&gt; set) <span class="sign">[C++11]</span></pre><blockquote><p>Вызывает <tt>clear()</tt>, затемn <tt>add()</tt> с указанными параметрами.
</p></blockquote></div><div><pre class="prototype">void clear()</pre><blockquote><p>Удаляет все элементы из множества.</p><div><u>Постусловие</u>: <tt>contains(char(ch)) == false</tt> для любого символа
</div></blockquote></div><h2 id="stdint.h"><span class="h2_num">2.21</span><tt>__vic/stdint.h</tt></h2><p><tt>&#60;stdint.h&gt;</tt> из ISO C99 для C++98. Начиная с C++11 - просто
перенаправление на <tt>&#60;cstdint&gt;</tt>.</p><p>Дополнительно содержит некоторые метафункции для шаблонного
метапрограммирования.</p><h3 id="intN_t"><span class="h3_num">2.21.1</span>Целые с точной длиной</h3><p>Гарантируется, что следующие типы доступны в <b>глобальном пространстве
имён</b>:</p><ul><li><tt>int8_t</tt></li><li><tt>int16_t</tt></li><li><tt>int32_t</tt></li><li><tt>int64_t</tt></li><li><tt>uint8_t</tt></li><li><tt>uint16_t</tt></li><li><tt>uint32_t</tt></li><li><tt>uint64_t</tt></li></ul><h3 id="int_leastN_t"><span class="h3_num">2.21.2</span>Целые с минимальной длиной</h3><p>Гарантируется, что следующие типы доступны в <b>глобальном пространстве
имён</b>:</p><ul><li><tt>int_least8_t</tt></li><li><tt>int_least16_t</tt></li><li><tt>int_least32_t</tt></li><li><tt>int_least64_t</tt></li><li><tt>uint_least8_t</tt></li><li><tt>uint_least16_t</tt></li><li><tt>uint_least32_t</tt></li><li><tt>uint_least64_t</tt></li></ul><h3 id="int_fastN_t"><span class="h3_num">2.21.3</span>Быстрейшие целые с минимальной длиной</h3><p>Гарантируется, что следующие типы доступны в <b>глобальном пространстве
имён</b>:</p><ul><li><tt>int_fast8_t</tt></li><li><tt>int_fast16_t</tt></li><li><tt>int_fast32_t</tt></li><li><tt>int_fast64_t</tt></li><li><tt>uint_fast8_t</tt></li><li><tt>uint_fast16_t</tt></li><li><tt>uint_fast32_t</tt></li><li><tt>uint_fast64_t</tt></li></ul><h3 id="intmax_t"><span class="h3_num">2.21.4</span>Целые наибольшего размера</h3><p>Гарантируется, что следующие типы доступны в <b>глобальном пространстве
имён</b>:</p><ul><li><tt>intmax_t</tt></li><li><tt>uintmax_t</tt></li></ul><h3 id="intptr_t"><span class="h3_num">2.21.5</span>Целые, вмещающие указатели на объекты</h3><p>Гарантируется, что следующие типы доступны в <b>глобальном пространстве
имён</b>:</p><ul><li><tt>intptr_t</tt></li><li><tt>uintptr_t</tt></li></ul><h3 id="int_exactly_bytes"><span class="h3_num">2.21.6</span><tt>int_exactly_bytes&#60;&gt;</tt>, <tt>uint_exactly_bytes&#60;&gt;</tt></h3><pre class="code">
template&#60;unsigned SizeInBytes&gt;
struct int_exactly_bytes
{
    using type = <span class="nonterminal">&#60;signed-integer-type-of-the-corresponding-size&gt;</span>;
};

template&#60;unsigned SizeInBytes&gt;
struct uint_exactly_bytes
{
    using type = <span class="nonterminal">&#60;unsigned-integer-type-of-the-corresponding-size&gt;</span>;
};

// BEGIN C++11
template&#60;unsigned N&gt;
using int_exact_bytes = typename int_exactly_bytes&#60;N&gt;::type;

template&#60;unsigned N&gt;
using uint_exact_bytes = typename uint_exactly_bytes&#60;N&gt;::type;
// END C++11
</pre><p>Метафункции, возвращающие знаковый/беззнаковый целый тип для указанного
размера в байтах. Более короткие псевдонимы доступны в режиме C++11 и выше.
Допустимые значения для <tt>SizeInBytes</tt>: <tt>1</tt>, <tt>2</tt>,
<tt>4</tt>, <tt>8</tt>.</p><div class="section">Пример</div><pre class="code">
typedef __vic::int_exactly_bytes&#60; sizeof(void *) &gt;::type my_intptr_t;
// or in C++11
using my_intptr_t = __vic::int_exact_bytes&#60; sizeof(void *) &gt;
assert( sizeof(my_intptr) == sizeof(intptr_t) );
</pre><h2 id="stdio_file.h"><span class="h2_num">2.22</span><tt>__vic/stdio_file.h</tt></h2><p>C++ обёртки для <tt>std::FILE</tt>.</p><h3 id="stdio_file"><span class="h3_num">2.22.1</span><tt>stdio_file</tt></h3><pre class="code">
class stdio_file : private non_copyable
{
public:
    explicit stdio_file(std::FILE *fp = nullptr);
    stdio_file(const char *name, const char *mode);
    ~stdio_file();

    // BEGIN C++11
    stdio_file(stdio_file &#38;&#38;o) noexcept;
    stdio_file &#38;operator=(stdio_file &#38;&#38;o) noexcept;
    // END C++11

    bool open(const char *name, const char *mode);
    bool is_open() const;
    void close();
    bool close_nt() noexcept;

    void swap(stdio_file &#38;o) noexcept;
    std::FILE *detach_handle() noexcept;
    std::FILE *attach_handle(std::FILE *fp) noexcept;
    std::FILE *handle() const;
    operator std::FILE*() const;
};
</pre><p>Тонкая RAII-обёртка для <tt>std::FILE *</tt>. Контролирует время жизни
файла. Автоматический преобразователь типа позволяет использовать объекты
данного типа в контекстах, требующих <tt>FILE *</tt>.</p><div><u><b>Замечание</b></u>: Хоть деструктор объекта и закрывает незакрытый поток, но лучше
использовать явный вызов <tt>close()</tt>. При закрытии потока также могут
происходить ошибки, и <tt>close()</tt> проинформирует о них исключением.
Деструктор же их просто проигнорирует, и они останутся незамечены приложением.
</div><div class="section">Члены класса</div><div><pre class="prototype">explicit stdio_file(std::FILE *fp = nullptr)</pre><blockquote><p>Создаёт обёртку для уже имеющегося указателя потока.</p><div><u>Предусловие</u>: <tt>fp</tt> указывает на открытый файл или <tt>nullptr</tt>.
</div></blockquote></div><div><pre class="prototype">stdio_file(const char *name, const char *mode)</pre><blockquote><p>Вызывает <tt>open(name, mode)</tt>. Необходимо проверить результат открытия
последующим вызовом <tt>is_open()</tt>!</p></blockquote></div><div><pre class="prototype">~stdio_file()</pre><blockquote><p>Вызывает <tt>std::fclose()</tt>, если <tt>is_open() == true</tt>.</p></blockquote></div><div><pre class="prototype">stdio_file(stdio_file &#38;&#38;o) noexcept <span class="sign">[C++11]</span></pre><pre class="prototype">stdio_file &#38;operator=(stdio_file &#38;&#38;o) noexcept <span class="sign">[C++11]</span></pre><blockquote><p>Операции перемещения для режима C++11.</p></blockquote></div><div><pre class="prototype">bool open(const char *name, const char *mode)</pre><blockquote><p>Вызывает <tt>std::fopen(name, mode)</tt>. Возвращает <tt>true</tt> в случае
успеха.</p><div><u>Предусловие</u>: <tt>is_open() == false</tt></div></blockquote></div><div><pre class="prototype">bool is_open() const</pre><blockquote><p>Возвращает <tt>true</tt> если файл открыт.</p></blockquote></div><div><pre class="prototype">void close()</pre><blockquote><p>Вызывает <tt>std::fclose()</tt>. Проверка на то, открыт ли файл, не
производится! Если <tt>std::fclose()</tt> возвращает ошибку, то бросается
исключение.</p><div><u>Предусловие</u>: <tt>is_open() == true</tt></div><div><u>Постусловие</u>: <tt>is_open() == false</tt></div></blockquote></div><div><pre class="prototype">bool close_nt() noexcept</pre><blockquote><p>Аналог <tt>close()</tt>, но никогда не бросает исключений, а возвращает
<tt>false</tt> в случае ошибок.</p></blockquote></div><div><pre class="prototype">void swap(stdio_file &#38;o) noexcept</pre><blockquote><p>Обменивается значением с <tt>o</tt>.</p></blockquote></div><div><pre class="prototype">std::FILE *detach_handle() noexcept</pre><blockquote><p>Освобождает файл из-под контроля объекта.</p><div><u>Постусловие</u>: <tt>is_open() == false</tt></div></blockquote></div><div><pre class="prototype">std::FILE *attach_handle(std::FILE *fp) noexcept</pre><blockquote><p>Помещает <tt>fp</tt> под контроль объекта и возвращает предыдущее хранимое
значение.</p><div><u>Предусловие</u>: <tt>fp</tt> – указатель на открытый файл или <tt>nullptr</tt>.
</div><div><u>Постусловие</u>: <tt>handle() == fp</tt></div></blockquote></div><div><pre class="prototype">std::FILE *handle() const</pre><blockquote><p>Возвращает хранимое завёрнутое значение.</p></blockquote></div><div><pre class="prototype">operator std::FILE*() const</pre><blockquote><p>Позволяет использовать объект как <tt>std::FILE *</tt>.</p></blockquote></div><div class="section">Пример</div><pre class="code">
__vic::stdio_file file("file.txt", "w");
if(!file.is_open()) throw __vic::exception("Cannot open file");
std::fprintf(file, "Message");
file.close();
// fclose() также вызовется автоматически деструктором при исключениях
</pre><h3 id="read-FILE-char"><span class="h3_num">2.22.2</span><tt>read(std::FILE, char&#38;)</tt>,
    <tt>read(std::FILE, unsigned char&#38;)</tt></h3><pre class="code">
bool read(std::FILE *fp, char &#38;ch);
bool read(std::FILE *fp, unsigned char &#38;ch);
</pre><p>Пытается прочитать байт из потока C. Возвращает <tt>true</tt> в случае
успеха, <tt>false</tt> при достижении конца файла или бросает исключение в
случае ошибки.</p><h3 id="write-FILE-char"><span class="h3_num">2.22.3</span><tt>write(std::FILE, char)</tt></h3><pre class="code">
void write(std::FILE *fp, char ch);
</pre><p>Записывает байт в поток C. Бросает исключение в случае ошибки.</p><h3 id="getline-FILE"><span class="h3_num">2.22.4</span><tt>getline(std::FILE)</tt></h3><pre class="code">
bool getline(std::FILE *fp, std::string &#38;str, char delim = '\n');
</pre><p>Аналог <tt>std::getline</tt> для потоков C. Возвращает <tt>false</tt>,
если конец файла достигнут раньше, чем что-то было прочитано.</p><h2 id="str2num.h"><span class="h2_num">2.23</span><tt>__vic/str2num.h</tt></h2><h3 id="decimal_to_number"><span class="h3_num">2.23.1</span><tt>decimal_to_number()</tt></h3><pre class="code">
void decimal_to_number(const std::string &#38;s, long long &#38;res);
void decimal_to_number(const std::string &#38;s, long &#38;res);
void decimal_to_number(const std::string &#38;s, int &#38;res);
void decimal_to_number(const std::string &#38;s, short &#38;res);
void decimal_to_number(const std::string &#38;s, signed char &#38;res);

void decimal_to_number(const std::string &#38;s, unsigned long long &#38;res);
void decimal_to_number(const std::string &#38;s, unsigned long &#38;res);
void decimal_to_number(const std::string &#38;s, unsigned &#38;res);
void decimal_to_number(const std::string &#38;s, unsigned short &#38;res);
void decimal_to_number(const std::string &#38;s, unsigned char &#38;res);

void decimal_to_number(const char *s, long long &#38;res);
void decimal_to_number(const char *s, long &#38;res);
void decimal_to_number(const char *s, int &#38;res);
void decimal_to_number(const char *s, short &#38;res);
void decimal_to_number(const char *s, signed char &#38;res);

void decimal_to_number(const char *s, unsigned long long &#38;res);
void decimal_to_number(const char *s, unsigned long &#38;res);
void decimal_to_number(const char *s, unsigned &#38;res);
void decimal_to_number(const char *s, unsigned short &#38;res);
void decimal_to_number(const char *s, unsigned char &#38;res);

template&#60;class TInteger&gt;
TInteger decimal_to_number(const std::string &#38;s);

template&#60;class TInteger&gt;
TInteger decimal_to_number(const char *s);
</pre><p>Набор функций, преобразующих строки, содержащие десятичное представление
целого числа, в один из стандартных целых типов C++. Входная строка может быть
как C-строкой, так и <tt>std::string</tt>.</p><p>В отличие от стандартных преобразователей, вроде <tt>std::strtol()</tt>,
производится строгая проверка на формат строки и диапазон значения. В частности,
лидирующие пробелы и символы, не являющиеся цифрами, в конце не допустимы. Для
беззнаковых типов недопустим символ '-', который <tt>std::strtoul()</tt> по
непонятной причине воспринимает как корректный.</p><p>В случае ошибок бросаются исключения:</p><ul><li><tt>std::invalid_argument</tt> – строка не является корректным целым
        десятичным числом;</li><li><tt>std::range_error</tt> – строка является корректным числом, но
        результат не представим в диапазоне запрошенного типа (целочисленное
        переполнение).</li></ul><p>Для данных функций доступны две категории прототипов:</p><ol><li>Значение возвращается через дополнительный выходной параметр и</li><li>Значение возвращается естественным образом, а его тип задаётся
        аргументом шаблона.</li></ol><h3 id="decimal_to_number_range"><span class="h3_num">2.23.2</span><tt>decimal_to_number_range()</tt></h3><pre class="code">
template&#60;class T, class InputIterator&gt;
void decimal_to_number_range(InputIterator begin, InputIterator end, T &#38;res);

template&#60;class T, class InputIterator&gt;
T decimal_to_number_range(InputIterator begin, InputIterator end);
</pre><p>Функции являются полным аналогом функций <tt>decimal_to_number()</tt> за
тем исключением, что на вход принимают диапазон символов вместо строки.</p><h3 id="decimal_parser"><span class="h3_num">2.23.3</span><tt>decimal_parser</tt></h3><pre class="code">
template&#60;class T&gt;
class decimal_parser
{
    using status = number_parse_status; // только для краткости
public:
    template&#60;class InputIterator&gt;
    status parse(InputIterator begin, InputIterator end);
    status parse(const std::string &#38;str);
    status parse(const char *str);
    T result() const;
};
</pre><p>Аналог функций <tt>decimal_to_number()</tt>, но ни бросает исключений.
Вместо них <tt>parse()</tt> возвращает коды <a href="#number_parse_status"><tt>number_parse_status</tt></a>.
</p><div class="section">Коды статусов</div><div><pre class="prototype">number_parse_status::ok</pre><blockquote><p>Удачно, результат может быть получен вызовом функции <tt>result()</tt>.</p></blockquote></div><div><pre class="prototype">number_parse_status::invalid_number</pre><blockquote><p>Строка не является корректным десятичным целым.</p></blockquote></div><div><pre class="prototype">number_parse_status::unrepresentable</pre><blockquote><p>Строка, возможно, корректна, но результат не представим в диапазоне
запрошенного типа (целочисленное переполнение).</p></blockquote></div><div class="section">Члены класса</div><div><pre class="prototype">template&#60;class InputIterator&gt;
status parse(InputIterator begin, InputIterator end)</pre><pre class="prototype">status parse(const std::string &#38;str)</pre><pre class="prototype">status parse(const char *str)</pre><blockquote><p>Преобразует диапазон символов или строку в число.</p><div><u>Постусловие</u>: Результат преобразования может быть получен вызовом
<tt>result()</tt>, если возвращён <tt>number_parse_status::ok</tt>.
</div></blockquote></div><div><pre class="prototype">T result() const</pre><blockquote><p>Возвращает результат преобразования последнего вызова <tt>parse()</tt>.</p><div><u>Предусловие</u>: Последний вызов <tt>parse()</tt> вернул
<tt>number_parse_status::ok</tt>.</div></blockquote></div><div class="section">Пример</div><pre class="code">
template&#60;class T&gt;
bool to_number(const std::string &#38;s, T &#38;result) noexcept
{
    __vic::decimal_parser&#60;T&gt; p;
    if(p.parse(s) != __vic::number_parse_status::ok) return false;
    result = p.result();
    returt true; // 'result' содержит результат преобразования
}
</pre><h3 id="number_parse_status"><span class="h3_num">2.23.4</span><tt>number_parse_status</tt></h3><pre class="code">
enum class number_parse_status
{
    ok,
    invalid_number,
    unrepresentable
};
using number_parse_status_t = number_parse_status; // for C++98
</pre><p>Коды статусов результата разбора.</p><div class="section">Типы</div><div><pre class="prototype">typename number_parse_status_t</pre><blockquote><p>Используйте данное имя типа, если коду требуется совместимость с режимом
C++98.</p></blockquote></div><h2 id="string_buffer.h"><span class="h2_num">2.24</span><tt>__vic/string_buffer.h</tt></h2><h3 id="string_buffer"><span class="h3_num">2.24.1</span><tt>string_buffer</tt></h3><pre class="code">
class string_buffer : public std::string
{
public:
    string_buffer();
    explicit string_buffer(size_type n);
    string_buffer(const char *str);
    string_buffer(std::string str);
    string_buffer(string_ref sr);
    string_buffer(const std::string &#38;str, size_type off, size_type n = npos);
    string_buffer(const char *char_buf, size_type n);
    string_buffer(const char *begin, const char *end);
    template&#60;class InputIterator&gt;
    string_buffer(InputIterator begin, InputIterator end);

    string_buffer &#38;operator&#60;&#60;(const char *str);
    string_buffer &#38;operator&#60;&#60;(const std::string &#38;str);
    string_buffer &#38;operator&#60;&#60;(string_ref sr);
    string_buffer &#38;operator&#60;&#60;(char ch);

    string_buffer &#38;operator&#60;&#60;(long long n);
    string_buffer &#38;operator&#60;&#60;(long n);
    string_buffer &#38;operator&#60;&#60;(int n);
    string_buffer &#38;operator&#60;&#60;(short n);
    string_buffer &#38;operator&#60;&#60;(signed char ch);

    string_buffer &#38;operator&#60;&#60;(unsigned long long n);
    string_buffer &#38;operator&#60;&#60;(unsigned long n);
    string_buffer &#38;operator&#60;&#60;(unsigned n);
    string_buffer &#38;operator&#60;&#60;(unsigned short n);
    string_buffer &#38;operator&#60;&#60;(unsigned char ch);

    string_buffer &#38;operator&#60;&#60;(long double n);
    string_buffer &#38;operator&#60;&#60;(double n);
    string_buffer &#38;operator&#60;&#60;(float n);

    string_buffer &#38;operator&#60;&#60;(bool flag);
    string_buffer &#38;operator&#60;&#60;(const void *p);

    string_buffer &#38;operator=(string_ref sr);
    string_buffer &#38;operator+=(string_ref sr);
    string_buffer &#38;assign(string_ref sr);
    string_buffer &#38;append(string_ref sr);

    // improved std::string calls
    string_buffer &#38;assign(const std::string &#38;str,
                            size_type off, size_type n = npos);
    string_buffer &#38;append(const std::string &#38;str,
                            size_type off, size_type n = npos);
    string_buffer &#38;insert(size_type pos, const std::string &#38;str,
                            size_type off, size_type n = npos);

    string_buffer &#38;reserve(size_type n);
    string_buffer &#38;clear();

    // missing container interface of std::string
    reference front();
    reference back();
    const_reference front() const;
    const_reference back() const;
    void pop_back();

    operator const char *() const;
};

string_buffer operator+(const string_buffer &#38;s1, const string_buffer &#38;s2);
string_buffer operator+(const string_buffer &#38;s1, const std::string &#38;s2);
string_buffer operator+(const std::string &#38;s1, const string_buffer &#38;s2);

string_buffer operator+(const string_buffer &#38;s1, const char *s2);
string_buffer operator+(const char *s1, const string_buffer &#38;s2);

string_buffer operator+(const string_buffer &#38;s, char ch);
string_buffer operator+(char ch, const string_buffer &#38;s);

using msg = string_buffer;
</pre><p>Класс является улучшенным и расширенным <tt>std::string</tt>. Он имеет
следующие преимущества:</p><ol><li>Лево-ассоциативная операция конкатенации (<tt>&#60;&#60;</tt>),
позволяющая конструкции, вроде:
<pre class="code">
str &#60;&#60; "Error message: " &#60;&#60; err_msg &#60;&#60; "\n";
</pre></li><li>В конструкторе можно зарезервировать место под строку в целях
оптимизации, чтобы избежать многократного перераспределения буфера, что
значительно улучшает производительность. Часто имеется возможность оценить
максимальный размер строки. Но если она вдруг окажется длиннее, то буфер
автоматически расширится, как и у <tt>std::string</tt>.
<pre class="code">
__vic::string_buffer st(4096);

// Эффект аналогичен
std::string st;
st.reserve(4096);
</pre></li><li>Оператор <tt>&#60;&#60;</tt> воспринимает все фундаментальные типы:
числа, символы, указатели, <tt>bool</tt>.
<pre class="code">
for(int i=0; i&#60;10; i++)
    str &#60;&#60; "i = " &#60;&#60; i &#60;&#60; '\n';
</pre></li><li>Все операции, работающие с <tt>const char *</tt>, корректно воспринимают
пустой указатель как пустую строку. Реализации <tt>std::string</tt> не
проверяют указатель на пустоту и пытаются читать по нему в любом случае.
<pre class="code">
std::string s1("Str");
const char *p = nullptr;
s1.append(p); // Oops.... Null pointer access!

__vic::string_buffer s2("Str");
s2.append(p); // Ok. s2 == "Str" still
s2 = p; // Ok. s2.empty() == true
</pre></li><li>Автоматическое преобразование в <tt>const char *</tt> позволяет
использовать объекты в контекстах, требующих C-строку без явного преобразования.
<pre class="code">
std::string fname(...);
FILE *fp = fopen(fname.c_str(), "r");

__vic::string_buffer fname(...);
FILE *fp = fopen(fname, "r");)
</pre></li><li>Исправлены нерегулярности в дизайне класса <tt>std::string</tt>. Например,
класс является полноценным контейнером с доступом к его началу и концу, но у
него отсутствуют операции <tt>front()</tt> и <tt>back()</tt> в C++98.
Также класс имеет операцию <tt>push_back()</tt>, но не имеет симметричной
<tt>pop_back()</tt>.</li></ol><p>При всех этих улучшениях, объекты данного типа полностью совместимы по
структуре с <tt>std::string</tt> и могут передаваться в контексты, требующие
<tt>std::string</tt>. Никаких дополнительных членов-данных в классе нет.</p><p>Использование инсертера (оператора <tt>&#60;&#60;</tt>) данного класса –
это простейший способ преобразовать число или указатель в строку. Механизм,
конечно, не такой мощный, как использование <tt>std::ostringstream</tt>,
например нельзя задать основание системы счисления или форматирование, но зато
самый простой и эффективный. Для вывода диагностики, к примеру, обычно его
вполне достаточно.</p><p>Также для данного типа введён синоним <tt>msg</tt>, который удобно
использовать для конструирования составных сообщений на лету одним
выражением без введения дополнительных переменных:</p><pre class="code">
oresult res = db_open(db_name);
if(res != 0) throw __vic::exception(
    __vic::msg(64) &#60;&#60; "Cannot open DB " &#60;&#60; db_name &#60;&#60; ". res = " &#60;&#60; res
);
</pre><p>Как  видно в примере, в конструктор в целях оптимизации передан максимальный
ожидаемый размер строки.</p><div class="section">Члены класса</div><div><pre class="prototype">string_buffer()</pre><blockquote><p>Создаёт пустую строку.</p><div><u>Постусловие</u>: <tt>empty() == true</tt></div></blockquote></div><div><pre class="prototype">explicit string_buffer(size_type n)</pre><blockquote><p>Вызывает <tt>reserve(n)</tt>.</p><div><u>Постусловие</u>: <tt>capacity() &gt;= n</tt></div></blockquote></div><div><pre class="prototype">string_buffer(const char *str)</pre><pre class="prototype">string_buffer(std::string str)</pre><blockquote><p>Создаёт копию <tt>str</tt>.</p></blockquote></div><div><pre class="prototype">string_buffer(const std::string &#38;str, size_type off, size_type n = npos)</pre><blockquote><p>Создаёт копию подстроки <tt>str</tt>.</p></blockquote></div><div><pre class="prototype">string_buffer(const char *char_buf, size_type n)</pre><blockquote><p>Создаёт строку из буфера и его длины.</p></blockquote></div><div><pre class="prototype">string_buffer(string_ref sr)</pre><pre class="prototype">string_buffer(const char *begin, const char *end)</pre><pre class="prototype">template&#60;class InputIterator&gt;
string_buffer(InputIterator begin, InputIterator end)</pre><blockquote><p>Создаёт строку из диапазона символов.</p></blockquote></div><div><pre class="prototype">string_buffer &#38;operator&#60;&#60;(const char *str)</pre><pre class="prototype">string_buffer &#38;operator&#60;&#60;(const std::string &#38;str)</pre><pre class="prototype">string_buffer &#38;operator&#60;&#60;(string_ref sr)</pre><pre class="prototype">string_buffer &#38;operator&#60;&#60;(char ch)</pre><blockquote><p>Вызывает <tt>std::string::append()</tt>.</p></blockquote></div><div><pre class="prototype">string_buffer &#38;operator&#60;&#60;(long long n)</pre><pre class="prototype">string_buffer &#38;operator&#60;&#60;(long n)</pre><pre class="prototype">string_buffer &#38;operator&#60;&#60;(int n)</pre><pre class="prototype">string_buffer &#38;operator&#60;&#60;(short n)</pre><pre class="prototype">string_buffer &#38;operator&#60;&#60;(signed char ch)</pre><pre class="prototype">string_buffer &#38;operator&#60;&#60;(unsigned long long n)</pre><pre class="prototype">string_buffer &#38;operator&#60;&#60;(unsigned long n)</pre><pre class="prototype">string_buffer &#38;operator&#60;&#60;(unsigned n)</pre><pre class="prototype">string_buffer &#38;operator&#60;&#60;(unsigned short n)</pre><pre class="prototype">string_buffer &#38;operator&#60;&#60;(unsigned char ch)</pre><pre class="prototype">string_buffer &#38;operator&#60;&#60;(long double n)</pre><pre class="prototype">string_buffer &#38;operator&#60;&#60;(double n)</pre><pre class="prototype">string_buffer &#38;operator&#60;&#60;(float n)</pre><blockquote><p>Добавляет к строке десятичное представление <tt>n</tt>.</p></blockquote></div><div><pre class="prototype">string_buffer &#38;operator&#60;&#60;(const void *p)</pre><blockquote><p>Добавляет к строке значение указателя в формате <tt>std::printf</tt>.</p></blockquote></div><div><pre class="prototype">string_buffer &#38;operator&#60;&#60;(bool flag)</pre><blockquote><p>Добавляет к строке <tt>1</tt> (для <tt>true</tt>) или <tt>0</tt> (для
<tt>false</tt>).</p></blockquote></div><div><pre class="prototype">string_buffer &#38;operator=(string_ref sr)</pre><pre class="prototype">string_buffer &#38;operator+=(string_ref sr)</pre><pre class="prototype">string_buffer &#38;assign(string_ref sr)</pre><pre class="prototype">string_buffer &#38;append(string_ref sr)</pre><blockquote><p>Операции для <tt>string_ref</tt>.</p></blockquote></div><div><pre class="prototype">string_buffer &#38;reserve(size_type n)</pre><pre class="prototype">string_buffer &#38;clear()</pre><blockquote><p>Вызывают одноимённую операцию <tt>std::string</tt> и дополнительно возвращают
ссылку на себя, что позволяет использовать вызовы в составных выражениях.</p></blockquote></div><div><pre class="prototype">reference front()</pre><pre class="prototype">reference back()</pre><pre class="prototype">const_reference front() const</pre><pre class="prototype">const_reference back() const</pre><pre class="prototype">void pop_back()</pre><blockquote><p>Недостающие операции интерфейса <tt>std::string</tt> в C++98.</p></blockquote></div><div><pre class="prototype">operator const char *() const</pre><blockquote><p>Вызывает <tt>std::string::c_str()</tt>.</p></blockquote></div><div><pre class="prototype">string_buffer operator+(const string_buffer &#38;s1, const string_buffer &#38;s2)</pre><pre class="prototype">string_buffer operator+(const string_buffer &#38;s1, const std::string &#38;s2)</pre><pre class="prototype">string_buffer operator+(const std::string &#38;s1, const string_buffer &#38;s2)</pre><pre class="prototype">string_buffer operator+(const string_buffer &#38;s1, const char *s2)</pre><pre class="prototype">string_buffer operator+(const char *s1, const string_buffer &#38;s2)</pre><pre class="prototype">string_buffer operator+(const string_buffer &#38;s, char ch)</pre><pre class="prototype">string_buffer operator+(char ch, const string_buffer &#38;s)</pre><blockquote><p>Конкатенация строк и символов.</p></blockquote></div><h2 id="string_ref.h"><span class="h2_num">2.25</span><tt>__vic/string_ref.h</tt></h2><h3 id="string_ref"><span class="h3_num">2.25.1</span><tt>string_ref</tt></h3><pre class="code">
template&#60;class charT&gt;
class basic_string_ref
{
public:
    using value_type = charT;
    using iterator = const value_type *;
    using const_iterator = iterator;

    // Constructors
    basic_string_ref();
    basic_string_ref(const charT *str);
    basic_string_ref(const charT *chars, size_t n);
    basic_string_ref(const charT *begin, const charT *end);
    template&#60;class Traits, class Alloc&gt;
    explicit basic_string_ref(
        const std::basic_string&#60;charT,Traits,Alloc&gt; &#38;str);
    basic_string_ref(
        typename std::basic_string&#60;charT&gt;::const_iterator begin,
        typename std::basic_string&#60;charT&gt;::const_iterator end);
    // BEGIN C++11
    basic_string_ref(std::initializer_list&#60;charT&gt; );
    // END C++11

    // Accessors
    iterator begin() const;
    iterator end() const;
    iterator cbegin() const;
    iterator cend() const;

    charT front() const;
    charT back() const;
    charT operator[](size_t i) const;
    const charT *data() const;

    bool empty() const;
    size_t size() const;
    size_t length() const;

    int compare(basic_string_ref s) const;

    // Converters
    std::basic_string&#60;charT&gt; str() const;
    template&#60;class Traits&gt;
    std::basic_string&#60;charT,Traits&gt; str() const;
    template&#60;class Traits, class Alloc&gt;
    std::basic_string&#60;charT,Traits,Alloc&gt; str(const Alloc &#38;a = Alloc())const;

    operator std::basic_string&#60;charT&gt;() const;
};

using string_ref = basic_string_ref&#60;char&gt; ;

template&#60;class charT&gt;
bool operator==(basic_string_ref&#60;charT&gt; s1, basic_string_ref&#60;charT&gt; s2);
template&#60;class charT&gt;
bool operator!=(basic_string_ref&#60;charT&gt; s1, basic_string_ref&#60;charT&gt; s2);
template&#60;class charT&gt;
bool operator&#60;(basic_string_ref&#60;charT&gt; s1, basic_string_ref&#60;charT&gt; s2);
template&#60;class charT&gt;
bool operator&gt;(basic_string_ref&#60;charT&gt; s1, basic_string_ref&#60;charT&gt; s2);
template&#60;class charT&gt;
bool operator&#60;=(basic_string_ref&#60;charT&gt; s1, basic_string_ref&#60;charT&gt; s2);
template&#60;class charT&gt;
bool operator&gt;=(basic_string_ref&#60;charT&gt; s1, basic_string_ref&#60;charT&gt; s2);

#ifdef __VIC_DEFINE_OSTREAM_INSERTERS
template&#60;class charT, class Traits&gt;
std::basic_ostream&#60;charT,Traits&gt; &#38;operator&#60;&#60;(
    std::basic_ostream&#60;charT,Traits&gt; &#38;os, const basic_string_ref&#60;charT&gt; &#38;sr);
#endif
</pre><p>Класс преставляет собой ссылку на протяжённый диапазон символов, доступных
только для чтения. При использовании в качестве возвращаемого типа он
значительно легче, чем <tt>std::string</tt>, потому что не требует копирования
строки и выделения дополнительной памяти. Но при использовании в контексте,
требующем <tt>std::string</tt>, происходит автоматическое преобразование.
Рассмотрим пример:</p><pre class="code">
class C
{
    std::string v;
public:
    std::string       get_v_1() const { return v; }
    __vic::string_ref get_v_2() const { return v; }
};
</pre><p>Как видно, в классе хранится поле в виде строки. Для доступа на чтение к
нему описаны две функции. Первая традиционно возвращает <tt>std::string</tt>,
вторая – <tt>string_ref</tt>. При доступе через первую функцию каждый раз
создаётся временная строка, при доступе через первую – просто возвращается
ссылка.</p><p>Другой сценарий использования – это входной аргумент, строка используемая
только для чтения. Класс - универсальная замена для <tt>const std::string
&#38;</tt>. В большинстве случаев он также может быть использован вместо
<tt>const char *</tt>. Накладными расходами в этом случае будет проход по
строке в поисках NULL-терминатора, который всё равно нужно сделать в случаях,
когда в любом случае нужен конец строки или её длина. Рассмотрим три набора
перегруженных функций:</p><pre class="code">
void f1(const std::string &#38; );

void f2(const std::string &#38; );
void f2(const char * );

void f3(string_ref );
</pre><p>Каждый из них может быть использован как</p><pre class="code">
fx("Nul-terminated string");
</pre><p>так и как</p><pre class="code">
fx(std::string("std::string"));
</pre><p>Но в случае с <tt>f1()</tt> в первом случае будет лишнее копирование строки
в кучу только для того чтобы его прочитать. В случае с <tt>f2()</tt> нужно
писать несколько перегрузок функции, и если с одним аргументом это не является
сильно утруждающим, то при увеличении их количества количество комбинаций
сильно увеличивается. Последний вариант с <tt>f3()</tt> является таким же
удобным и универсальным, как с <tt>f1()</tt>, но при этом он более
«дружественный» к строковым литералам и строкам из мира C – копирования их в
динамическую память и превращения в <tt>std::string</tt> не происходит.</p><div class="section">Члены класса</div><div><pre class="prototype">basic_string_ref()</pre><blockquote><div><u>Постусловие</u>: <tt>empty() == true</tt></div></blockquote></div><div><pre class="prototype">basic_string_ref(const charT *str)</pre><pre class="prototype">template&#60;class Traits, class Alloc&gt;
basic_string_ref(const std::basic_string&#60;charT,Traits,Alloc&gt; &#38;str)</pre><blockquote><p>Создают ссылку на <tt>str</tt>.</p><div><u>Постусловие</u>: <tt>*this == str</tt></div></blockquote></div><div><pre class="prototype">basic_string_ref(const charT *chars, size_t n)</pre><pre class="prototype">basic_string_ref(const charT *begin, const charT *end)</pre><pre class="prototype">basic_string_ref(const charT *chars, size_t n)</pre><pre class="prototype">basic_string_ref(
    typename std::basic_string&#60;charT&gt;::const_iterator begin,
    typename std::basic_string&#60;charT&gt;::const_iterator end)</pre><pre class="prototype">basic_string_ref(std::initializer_list&#60;charT&gt; ) <span class="sign">[C++11]</span></pre><blockquote><p>Создают ссылку на диапазон символов.</p></blockquote></div><div><pre class="prototype">iterator begin() const</pre><pre class="prototype">iterator cbegin() const</pre><pre class="prototype">const charT *data() const</pre><blockquote><p>Начало диапазона символов.</p></blockquote></div><div><pre class="prototype">iterator end() const</pre><pre class="prototype">iterator cend() const</pre><blockquote><p>Конец диапазона символов.</p></blockquote></div><div><pre class="prototype">charT front() const</pre><pre class="prototype">charT back() const</pre><blockquote><p>Первый и последний символ диапазона, соответственно.</p><div><u>Предусловие</u>: <tt>!empty()</tt></div></blockquote></div><div><pre class="prototype">charT operator[](size_t i) const</pre><blockquote><p><tt>i</tt>-й символ строки.</p><div><u>Предусловие</u>: <tt>i &#60; length()</tt></div></blockquote></div><div><pre class="prototype">bool empty() const</pre><blockquote><p>Возвращает <tt>begin() == end()</tt>.</p></blockquote></div><div><pre class="prototype">size_t size() const</pre><pre class="prototype">size_t length() const</pre><blockquote><p>Длина строки.</p></blockquote></div><div><pre class="prototype">int compare(basic_string_ref s) const</pre><blockquote><p>Сравнивает строку с <tt>s</tt>. Возвращаемые значения аналогичны
<tt>std::string::compare()</tt>.</p></blockquote></div><div><pre class="prototype">std::basic_string&#60;charT&gt; str() const</pre><pre class="prototype">template&#60;class Traits&gt;
std::basic_string&#60;charT,Traits&gt; str() const</pre><pre class="prototype">template&#60;class Traits, class Alloc&gt;
std::basic_string&#60;charT,Traits,Alloc&gt; str(const Alloc &#38;a = Alloc()) const</pre><blockquote><p>Явный преобразователь в <tt>std::basic_string</tt>.</p></blockquote></div><div><pre class="prototype">operator std::basic_string&#60;charT&gt;() const</pre><blockquote><p>Неявный преобразователь в <tt>std::basic_string</tt>.</p></blockquote></div><div class="section">Свободные функции</div><div><pre class="prototype">template&#60;class charT&gt;
bool operator==(basic_string_ref&#60;charT&gt; s1, basic_string_ref&#60;charT&gt; s2)</pre><pre class="prototype">template&#60;class charT&gt;
bool operator!=(basic_string_ref&#60;charT&gt; s1, basic_string_ref&#60;charT&gt; s2)</pre><pre class="prototype">template&#60;class charT&gt;
bool operator&#60;(basic_string_ref&#60;charT&gt; s1, basic_string_ref&#60;charT&gt; s2)</pre><pre class="prototype">template&#60;class charT&gt;
bool operator&gt;(basic_string_ref&#60;charT&gt; s1, basic_string_ref&#60;charT&gt; s2)</pre><pre class="prototype">template&#60;class charT&gt;
bool operator&#60;=(basic_string_ref&#60;charT&gt; s1, basic_string_ref&#60;charT&gt; s2)</pre><pre class="prototype">template&#60;class charT&gt;
bool operator&gt;=(basic_string_ref&#60;charT&gt; s1, basic_string_ref&#60;charT&gt; s2)</pre><blockquote><p>Полный набор операторов сравнения.</p></blockquote></div><div><pre class="prototype">template&#60;class charT, class Traits&gt;
std::basic_ostream&#60;charT,Traits&gt; &#38;operator&#60;&#60;(
    std::basic_ostream&#60;charT,Traits&gt; &#38;os, const basic_string_ref&#60;charT&gt; &#38;sr)</pre><blockquote><p>Инсертер в стандартный выходной поток. Определён (а также
<tt>&#60;ostream&gt;</tt> включён) только, если определён макрос
<tt>__VIC_DEFINE_OSTREAM_INSERTERS</tt> перед включением.</p></blockquote></div><div class="section">Пример</div><pre class="code">
C c; // описание класса см. выше
__vic::string_ref s = c. get_v_2();

// печать строки разными способами
for(__vic::string_ref::iterator it = s.begin(); it != s.end(); ++it)
    std::cout &#60;&#60; *it;

// C++11
for(auto ch : s) std::cout &#60;&#60; ch;

std::copy(s.begin(), s.end(), std::ostream_iterator&#60;char&gt;(std::cout));

std::cout &#60;&#60; s;

// автоматическое преобразование в std::string
std::string ss = s;
</pre><h2 id="string_utils.h"><span class="h2_num">2.26</span><tt>__vic/string_utils.h</tt></h2><p>Различные утилиты для работы со строками.</p><h3 id="trim"><span class="h3_num">2.26.1</span>Набор функций <tt>trim</tt></h3><pre class="code">
char *trim(char *str);
char *trim_front(char *str);
char *trim_back(char *str);
char *trim(char *str, char ch);
char *trim_front(char *str, char ch);
char *trim_back(char *str, char ch);
char *trim(char *str, const char *set);
char *trim_front(char *str, const char *set);
char *trim_back(char *str, const char *set);

std::string &#38;trim(std::string &#38;str);
std::string &#38;trim_front(std::string &#38;str);
std::string &#38;trim_back(std::string &#38;str);
std::string &#38;trim(std::string &#38;str, char ch);
std::string &#38;trim_front(std::string &#38;str, char ch);
std::string &#38;trim_back(std::string &#38;str, char ch);
std::string &#38;trim(std::string &#38;str, const char *set);
std::string &#38;trim_front(std::string &#38;str, const char *set);
std::string &#38;trim_back(std::string &#38;str, const char *set);

std::string trimmed(const std::string &#38;str);
std::string trimmed_front(const std::string &#38;str);
std::string trimmed_back(const std::string &#38;str);
std::string trimmed(const std::string &#38;str, char ch);
std::string trimmed_front(const std::string &#38;str, char ch);
std::string trimmed_back(const std::string &#38;str, char ch);
std::string trimmed(const std::string &#38;str, const char *set);
std::string trimmed_front(const std::string &#38;str, const char *set);
std::string trimmed_back(const std::string &#38;str, const char *set);
</pre><p>Набор функций, обрезающих нежелательные символы по краям строки. Обрезаемые
символы можно задавать. Задать можно как одиночный символ <tt>ch</tt>, так и
набор <tt>set</tt>. Если набор не задан, то подразумеваются все пробельные
ASCII-символы. Используются следующие правила именования:</p><ul><li><tt>trim</tt> – обрезает строку с обоих концов,</li><li><tt>trim_front</tt> – обрезает строку в начале,</li><li><tt>trim_back</tt> – обрезает строку в конце.</li></ul><p>Функции <tt>trim</tt> модифицируют переданную строку и возвращают указатель
или ссылку на неё. Если это по каким-то причинам нежелательно, то следует
использовать набор функций <tt>trimmed</tt>.</p><ul><li><tt>trimmed</tt> – возвращает обрезанную строку в качестве выходного
        значения, не модифицируя входной параметр.</li></ul><p>Реализация функций <tt>trim</tt> выполнена с расчётом, что у строки может
не быть символов, подлежащих обрезанию. В подобных случаях никаких модификаций
не производится, и функция возвращает управление сразу после проверки. С точки
зрения эффективности, затраты на такие вызовы минимальны.</p><p>Все значения <tt>nullptr</tt> воспринимаются как пустая строка.</p><div class="section">Примеры</div><pre class="code">
char st1[] = "\t value    \n";

// CHOICE:
__vic::trim(st1);       // result: "value"
__vic::trim_front(st1); // result: "value    \n"
__vic::trim_back(st1);  // result: "\t value"

std::string st2("...value123");

// CHOICE:
// trim dot chars
__vic::trim_front(st1, '.');        // result: "value123"
// trim all digits
__vic::trim_back(st1, "123456789"); // result: "...value"
</pre><h3 id="sift"><span class="h3_num">2.26.2</span><tt>sift()</tt></h3><pre class="code">
char *sift(char *str, const char *trash_chars);
std::string &#38;sift(std::string &#38;str, const char *trash_chars);
</pre><p>Удаляет из строки все символы из указанного набора. Все значения
<tt>nullptr</tt> воспринимаются как пустая строка.</p><div class="section">Пример</div><pre class="code">
char st[] = "..ab.c..d.e.";
__vic::sift(st, ".");
assert(std::strcmp(st, "abcde") == 0);
</pre><h3 id="sift_if"><span class="h3_num">2.26.3</span><tt>sift_if()</tt></h3><pre class="code">
template&#60;class Pred&gt;
char *sift(char *str, Pred pred);
template&#60;class Pred&gt;
std::string &#38;sift(std::string &#38;str, Pred pred);
</pre><p>Удаляет из строки все символы, удовлетворяющие предикату <tt>pred</tt>.
Все значения <tt>nullptr</tt> воспринимаются как пустая строка.</p><h3 id="pad_front"><span class="h3_num">2.26.4</span><tt>pad_front()</tt></h3><pre class="code">
std::string &#38;pad_front(std::string &#38;str, size_t size, char pad_ch = ' ');
char *pad_front(char *str, size_t size, char pad_ch = ' ');
</pre><p>Дополняет строку до длины <tt>size</tt> в начале символами
<tt>pad_ch</tt>. Ничего не происходит, если строка уже имеет длину
<tt>size</tt> или большую, либо указатель - null. Возвращает <tt>str</tt>.</p><h3 id="pad_back"><span class="h3_num">2.26.5</span><tt>pad_back()</tt></h3><pre class="code">
std::string &#38;pad_back(std::string &#38;str, size_t size, char pad_ch = ' ');
char *pad_back(char *str, size_t size, char pad_ch = ' ');
</pre><p>Дополняет строку до длины <tt>size</tt> в конце символами
<tt>pad_ch</tt>. Ничего не происходит, если строка уже имеет длину
<tt>size</tt> или большую, либо указатель - null. Возвращает <tt>str</tt>.</p><h3 id="starts_with"><span class="h3_num">2.26.6</span><tt>starts_with()</tt></h3><pre class="code">
bool starts_with(const char *s, char pref);
bool starts_with(const char *s, const char *pref);
bool starts_with(const char *s, const char *pref, size_t pref_len);

bool starts_with(const std::string &#38;s, char pref);
bool starts_with(const std::string &#38;s, const char *pref);
bool starts_with(const std::string &#38;s, const std::string &#38;pref);
bool starts_with(const std::string &#38;s, const char *pref, size_t pref_len);

bool starts_with(const char *s, size_t s_len, char pref);
bool starts_with(const char *s, size_t s_len, const char *pref);
bool starts_with(const char *s, size_t s_len, const char *pref, size_t pref_len);
</pre><p>Возвращает <tt>true</tt>, если строка <tt>s</tt> начинается с указанного
префикса.</p><h3 id="ends_with"><span class="h3_num">2.26.7</span><tt>ends_with()</tt></h3><pre class="code">
bool ends_with(const char *s, char suff);
bool ends_with(const char *s, const char *suff);
bool ends_with(const char *s, const char *suff, size_t suff_len);

bool ends_with(const std::string &#38;s, char suff);
bool ends_with(const std::string &#38;s, const char *suff);
bool ends_with(const std::string &#38;s, const std::string &#38;suff);
bool ends_with(const std::string &#38;s, const char *suff, size_t suff_len);

bool ends_with(const char *s, size_t s_len, char suff);
bool ends_with(const char *s, size_t s_len, const char *suff);
bool ends_with(const char *s, size_t s_len, const char *suff, size_t suff_len);
</pre><p>Возвращает <tt>true</tt>, если строка <tt>s</tt> оканчивается указанным
суффиксом.</p><h2 id="tchar.h"><span class="h2_num">2.27</span><tt>__vic/tchar.h</tt></h2><p>Обобщенные (generic) функции для манипуляции С-строками независимо от
используемого ими типа символов, подобно <tt>std::char_traits&#60;&gt;</tt>.
Использование данных функций в шаблонах нередко значительно сокращает
потребность в написании специализаций для различных типов символов.</p><p>Все функции находятся в пространстве имён <tt>__vic::tchar</tt>.</p><p>Большинство функций являются просто обобщёнными обёртками для функций,
вроде <tt>strcpy</tt>, <tt>wcscpy</tt> и т.п. Поисковые функции имеют более
осмысленные имена, чем их аналоги в билиотеке C, и унифицированные параметры:
они всегда принимают указатели и никогда индексы. Также набор функций дополнен
«логически симметричными», но отсутствующими в стандартной билиотеке.
Поисковые функции возвращают <tt>nullptr</tt> в случае неудачи.</p><div class="section">Пример</div><pre class="code">
template&#60;class charT&gt;
charT *generic_dup(const charT *st)
{
    namespace tchar = __vic::tchar;

    charT *st_copy = new charT[tchar::length(st) + 1];
    tchar::copy(st_copy, st);
    return st_copy;
}
</pre><h3 id="tchar--length"><span class="h3_num">2.27.1</span><tt>tchar::length()</tt></h3><pre class="code">
template&#60;class charT&gt;
size_t tchar::length(const charT *str);
</pre><p>Длина строки в элементах. Обобщённый <tt>strlen</tt> / <tt>wcslen</tt>.</p><h3 id="tchar--empty"><span class="h3_num">2.27.2</span><tt>tchar::empty()</tt></h3><pre class="code">
template&#60;class charT&gt;
bool tchar::empty(const charT *str);
</pre><p>Проверяет, является ли <tt>str</tt> <tt>nullptr</tt> или пустой строкой.</p><h3 id="tchar--end"><span class="h3_num">2.27.3</span><tt>tchar::end()</tt></h3><pre class="code">
namespace tchar {

template&#60;class charT&gt;
const charT *end(const charT *str);

template&#60;class charT&gt;
charT *end(charT *str);

}
</pre><p>Указатель на NULL-терминатор. Обобщённый <tt>strchr(str, '\0')</tt> /
<tt>wcschr(str, L'\0')</tt>.</p><div><u><b>Замечание</b></u>: Некоторые «кривые» реализации <tt>std::strchr()</tt>, например в  MinGW,
возвращают неконстантный <tt>char *</tt>, даже если аргумент - <tt>const char
*</tt>. В связи с этим, данные функции могут быть использованы как обход
данной проблемы.</div><h3 id="tchar--compare"><span class="h3_num">2.27.4</span><tt>tchar::compare()</tt></h3><pre class="code">
template&#60;class charT&gt;
int tchar::compare(const charT *str1, const charT *str2);
</pre><p>Сравнивает две строки. Обобщённый <tt>strcmp</tt> / <tt>wcscmp</tt>.</p><h3 id="tchar--equal"><span class="h3_num">2.27.5</span><tt>tchar::equal()</tt></h3><pre class="code">
template&#60;class charT&gt;
bool tchar::equal(const charT *str1, const charT *str2);
</pre><p>Проверяет двестроки на равенство.</p><div><u>Предусловие</u>: <tt>str1 != nullptr &#38;&#38; str2 != nullptr</tt></div><h3 id="tchar--copy"><span class="h3_num">2.27.6</span><tt>tchar::copy()</tt></h3><pre class="code">
template&#60;class charT&gt;
charT *tchar::copy(charT *dest, const charT *src);
</pre><p>Копирует строку. Обобщённый <tt>strcpy</tt> / <tt>wcscpy</tt>.</p><h3 id="tchar--move"><span class="h3_num">2.27.7</span><tt>tchar::move()</tt></h3><pre class="code">
template&#60;class charT&gt;
charT *tchar::move(charT *dest, const charT *src);
</pre><p>Сдвигает строку в памяти (<tt>memmove</tt>).</p><h3 id="tchar--concat"><span class="h3_num">2.27.8</span><tt>tchar::concat()</tt></h3><pre class="code">
template&#60;class charT&gt;
charT *tchar::concat(charT *dest, const charT *src);
</pre><p>Конкатенирует две строки. Обобщённый <tt>strcat</tt> / <tt>wcscat</tt>.</p><h3 id="tchar--find"><span class="h3_num">2.27.9</span><tt>tchar::find()</tt></h3><pre class="code">
namespace tchar {

template&#60;class charT&gt;
const charT *find(const charT *str, charT ch);

template&#60;class charT&gt;
charT *find(charT *str, charT ch);

template&#60;class charT&gt;
const charT *find(const charT *str, const charT *sub);

template&#60;class charT&gt;
charT *find(charT *str, const charT *sub);

}
</pre><p>Ищет первое вхождение символа или подстроки. Обобщённые
<tt>strchr</tt> / <tt>wcschr</tt> / <tt>strstr</tt> / <tt>wcsstr</tt>.</p><h3 id="tchar--rfind"><span class="h3_num">2.27.10</span><tt>tchar::rfind()</tt></h3><pre class="code">
namespace tchar {

template&#60;class charT&gt;
const charT *rfind(const charT *str, charT ch);

template&#60;class charT&gt;
charT *rfind(charT *str, charT ch);

}
</pre><p>Ищет последнее вхождение символа. Обобщённые <tt>strrchr</tt> /
<tt>wcsrchr</tt>.</p><h3 id="tchar--find_if"><span class="h3_num">2.27.11</span><tt>tchar::find_if()</tt></h3><pre class="code">
namespace tchar {

template&#60;class charT, class Pred&gt;
const charT *find_if(const charT *str, Pred pred);

template&#60;class charT, class Pred&gt;
charT *find_if(charT *str, Pred pred);

}
</pre><p>Ищет первое вхождение символа, удовлетворяющего указанному предикату.</p><h3 id="tchar--find_if_not"><span class="h3_num">2.27.12</span><tt>tchar::find_if_not()</tt></h3><pre class="code">
namespace tchar {

template&#60;class charT, class Pred&gt;
const charT *find_if_not(const charT *str, Pred pred);

template&#60;class charT, class Pred&gt;
charT *find_if_not(charT *str, Pred pred);

}
</pre><p>Ищет первое вхождение символа, не удовлетворяющего указанному предикату.</p><h3 id="tchar--rfind_if"><span class="h3_num">2.27.13</span><tt>tchar::rfind_if()</tt></h3><pre class="code">
namespace tchar {

template&#60;class charT, class Pred&gt;
const charT *rfind_if(const charT *str, Pred pred);

template&#60;class charT, class Pred&gt;
charT *rfind_if(charT *str, Pred pred);

}
</pre><p>Ищет последнее вхождение символа, удовлетворяющего указанному предикату.</p><h3 id="tchar--rfind_if_not"><span class="h3_num">2.27.14</span><tt>tchar::rfind_if_not()</tt></h3><pre class="code">
namespace tchar {

template&#60;class charT, class Pred&gt;
const charT *rfind_if_not(const charT *str, Pred pred);

template&#60;class charT, class Pred&gt;
charT *rfind_if_not(charT *str, Pred pred);

}
</pre><p>Ищет последнее вхождение символа, не удовлетворяющего указанному предикату.
</p><h3 id="tchar--find_first_of"><span class="h3_num">2.27.15</span><tt>tchar::find_first_of()</tt></h3><pre class="code">
namespace tchar {

template&#60;class charT&gt;
const charT *find_first_of(const charT *str, const charT *set);

template&#60;class charT&gt;
charT *find_first_of(charT *str, const charT *set);

}
</pre><p>Ищет первое вхождение символа из указанного набора. Обобщённый
<tt>strpbrk</tt> / <tt>wcspbrk</tt>.</p><h3 id="tchar--find_first_not_of"><span class="h3_num">2.27.16</span><tt>tchar::find_first_not_of()</tt></h3><pre class="code">
namespace tchar {

template&#60;class charT&gt;
const charT *find_first_not_of(const charT *str, const charT *set);

template&#60;class charT&gt;
charT *find_first_not_of(charT *str, const charT *set);

}
</pre><p>Ищет первое вхождение символа, отсутствующего в указанном наборе.
Обобщённый <tt>strspn</tt> / <tt>wcsspn</tt>.</p><h3 id="tchar--find_last_of"><span class="h3_num">2.27.17</span><tt>tchar::find_last_of()</tt></h3><pre class="code">
namespace tchar {

template&#60;class charT&gt;
const charT *find_last_of(const charT *str, const charT *set);

template&#60;class charT&gt;
charT *find_last_of(charT *str, const charT *set);

}
</pre><p>Ищет последнее вхождение символа из указанного набора.</p><h3 id="tchar--find_last_not_of"><span class="h3_num">2.27.18</span><tt>tchar::find_last_not_of()</tt></h3><pre class="code">
namespace tchar {

template&#60;class charT&gt;
const charT *find_last_not_of(const charT *str, const charT *set);

template&#60;class charT&gt;
charT *find_last_not_of(charT *str, const charT *set);

}
</pre><p>Ищет последнее вхождение символа, отсутсвующего в указанном наборе.</p><h3 id="tchar--skip"><span class="h3_num">2.27.19</span><tt>tchar::skip()</tt></h3><pre class="code">
namespace tchar {

template&#60;class charT&gt;
const charT *skip(const charT *str, charT ch);

template&#60;class charT&gt;
charT *skip(charT *str, charT ch);

}
</pre><p>Пропускает все вхождения указанного символа и возвращает указатель.
Если другие символы в строке отсутствуют, возвращает указатель на
NULL-терминатор.</p><h2 id="thread.h"><span class="h2_num">2.28</span><tt>__vic/thread.h</tt></h2><p>Поддержка вычислительных потоков.</p><h3 id="thread"><span class="h3_num">2.28.1</span><tt>thread</tt></h3><pre class="code">
class thread : private non_copyable
{
public:
    class id;
    using native_handle_type = <span class="nonterminal">&#60;implementation-defined&gt;</span>;

    thread();
    virtual ~thread();

    // BEGIN C++11
    thread(thread &#38;&#38;o) noexcept;
    thread &#38;operator=(thread &#38;&#38;o) noexcept;
    // END C++11

    void start();
    void cancel();
    void join();

    bool alive() const;
    bool joinable() const;

    id get_id() const;
    native_handle_type handle() const;
protected:
    virtual void worker() = 0;
};
</pre><p>Абстрактный базовый класс потоков. Реализует pattern «Active object».
Унаследуйте данный класс и определите функцию <tt>worker()</tt>, содержимое
которой будет выполнено в новом потоке после вызова <tt>start()</tt>. Затем
где-то в Вашей программе Вы должны будете вызвать <tt>join()</tt> для
освобождения ресурсов ОС, ассоциированных с порождённым потоком.</p><div><u><b>Замечание</b></u>: Объект должен всегда жить дольше, чем ассоциированный с ним поток ОС.
Если это соглашение будет нарушено, программа будет завершена вызовом
<tt>std::terminate()</tt>.</div><div class="section">Члены класса</div><div><pre class="prototype">thread()</pre><blockquote><div><u>Постусловие</u>: <tt>joinable() == false</tt></div></blockquote></div><div><pre class="prototype">~thread()</pre><blockquote><p>Вызывает <tt>std::terminate()</tt>, если нарушено предусловие.</p><div><u>Предусловие</u>: <tt>joinable() == false || alive() == false</tt></div></blockquote></div><div><pre class="prototype">thread(thread &#38;&#38;o) noexcept <span class="sign">[C++11]</span></pre><blockquote><p>Перемещающий конструктор для режима C++11.</p></blockquote></div><div><pre class="prototype">thread &#38;operator=(thread &#38;&#38;o) noexcept <span class="sign">[C++11]</span></pre><blockquote><p>Перемещающее присваивание для режима C++11. Вызывает
<tt>std::terminate()</tt>, если нарушено предусловие.</p><div><u>Предусловие</u>: <tt>joinable() == false || alive() == false</tt></div></blockquote></div><div><pre class="prototype">void start()</pre><blockquote><p>Порождает новый поток и вызывает в нём <tt>worker()</tt>.</p><div><u>Предусловие</u>: <tt>joinable() == false</tt></div><div><u>Постусловие</u>: <tt>joinable() == true</tt></div></blockquote></div><div><pre class="prototype">void cancel()</pre><blockquote><p>Прерывает выполнение потока.</p><div><u>Предусловие</u>: <tt>joinable() == true</tt></div><div><u>Постусловие</u>: <tt>joinable() == true</tt></div></blockquote></div><div><pre class="prototype">void join()</pre><blockquote><p>Ждёт завершения работы потока, если он выполняется в данный момент, и делает
его <tt>joinable() == false</tt>.</p><div><u>Предусловие</u>: <tt>joinable() == true</tt></div><div><u>Постусловие</u>: <tt>joinable() == false</tt></div></blockquote></div><div><pre class="prototype">bool alive() const</pre><blockquote><p>Возращает <tt>true</tt>, если выполнение потока ещё не завершилось
(он находится в функции <tt>worker()</tt>).</p><div><u>Предусловие</u>: <tt>joinable() == true</tt></div></blockquote></div><div><pre class="prototype">bool joinable() const</pre><blockquote><p>Возвращает <tt>true</tt>, если объект имеет соответсвующий объект ОС
(поток), созданный вызовом <tt>start()</tt> и ещё не уничтоженный вызовом
<tt>join()</tt>.</p></blockquote></div><div><pre class="prototype">id get_id() const</pre><blockquote><p>Возвращает ID потока.</p></blockquote></div><div><pre class="prototype">native_handle_type handle() const</pre><blockquote><p>Возвращает дескриптор потока, используемый в данной ОС.</p></blockquote></div><h3 id="thread--id"><span class="h3_num">2.28.2</span><tt>thread::id</tt></h3><pre class="code">
class thread::id
{
public:
    id();
    explicit operator bool() const;
    native_handle_type handle() const;
};
bool operator==(thread::id a, thread::id b);
bool operator!=(thread::id a, thread::id b);
</pre><p>Уникальный идентификатор потока. Может содержать значение, ассоциированное
с потоком или специальное значение, не ассоциированное ни с одним потоком.</p><div class="section">Члены класса</div><div><pre class="prototype">id()</pre><blockquote><p>Создаёт специальное значение не ассоциированное ни с одним потоком.</p><div><u>Постусловие</u>: <tt>bool(*this) == false</tt></div></blockquote></div><div><pre class="prototype">explicit operator bool() const</pre><blockquote><p>Возвращает <tt>true</tt>, если объект хранит ID какого-то потока.</p></blockquote></div><div><pre class="prototype">native_handle_type handle() const</pre><blockquote><p>Возвращает дескриптор потока, используемый в данной ОС.</p><div><u>Предусловие</u>: <tt>bool(*this) == true</tt></div></blockquote></div><div><pre class="prototype">bool operator==(thread::id a, thread::id b)</pre><pre class="prototype">bool operator!=(thread::id a, thread::id b)</pre><blockquote><p>Проверяет, ассоциированы ли <tt>a</tt> и <tt>b</tt> с одним и тем же
потоком (либо оба содержат значение по умолчанию).</p><div><u>Инвариант</u>: <tt>id() == id()</tt></div></blockquote></div><h3 id="this_thread"><span class="h3_num">2.28.3</span><tt>this_thread</tt></h3><pre class="code">
namespace this_thread
{
    thread::id get_id();
    void sleep_ms(unsigned msec);
}
</pre><p>Набор функций для манипуляции с текущим (вызывающим) потоком.</p><div><pre class="prototype">thread::id get_id()</pre><blockquote><p>Возвращает ID вызывающего потока.</p></blockquote></div><div><pre class="prototype">void sleep_ms(unsigned msec)</pre><blockquote><p>Приостанавливает выполнение вызывающего потока на указанное время в
миллисекундах.</p></blockquote></div><h2 id="throw_errno.h"><span class="h2_num">2.29</span><tt>__vic/throw_errno.h</tt></h2><h3 id="throw_errno"><span class="h3_num">2.29.1</span><tt>throw_errno()</tt></h3><pre class="code">
[[noreturn]] void throw_errno(const char *prompt);
[[noreturn]] void throw_errno(const char *prompt, int err_no);
</pre><p>Бросает исключение, содержащее глобальное значение <tt>errno</tt> или
данное <tt>err_no</tt>, соответственно. По умолчанию в данный момент типом
исключения будет <a href="#libc_error"><tt>libc_error</tt></a>, однако это можно изменить во время
компоновки переопределением данных функций. Например, можно использовать
<tt>std::system_error</tt>. Для этого просто создайте cpp-файл со следующим
содержимым в своём проекте:</p><pre class="code">
#include&#60;__vic/throw_errno.h&gt;
#include&#60;system_error&gt;
#include&#60;cerrno&gt;

namespace __vic {

//----------------------------------------------------------------------------
// Override library functions to throw std::system_error
//----------------------------------------------------------------------------
void throw_errno(const char *prompt, int err_no)
{
    throw std::system_error(err_no, std::system_category(), prompt);
}
//----------------------------------------------------------------------------
void throw_errno(const char *prompt)
{
    throw_errno(prompt, errno);
}
//----------------------------------------------------------------------------

} // namespace
</pre><div class="section">Пример</div><pre class="code">
ssize_t written = ::write(fd, buf, buf_size);
if(written &#60; 0) __vic::throw_errno("write");
// ...
</pre><h2 id="to_text.h"><span class="h2_num">2.30</span><tt>__vic/to_text.h</tt></h2><p>Преобразователи типов в текстовое представление.</p><h3 id="to_text_append"><span class="h3_num">2.30.1</span><tt>to_text_append()</tt></h3><pre class="code">
void to_text_append(long long n, std::string &#38;str);
void to_text_append(long n, std::string &#38;str);
void to_text_append(int n, std::string &#38;str);
void to_text_append(short n, std::string &#38;str);
void to_text_append(signed char n, std::string &#38;str);

void to_text_append(unsigned long long , std::string &#38;str);
void to_text_append(unsigned long n, std::string &#38;str);
void to_text_append(unsigned n, std::string &#38;str);
void to_text_append(unsigned short n, std::string &#38;str);
void to_text_append(unsigned char n, std::string &#38;str);

void to_text_append(long double n, std::string &#38;str);
void to_text_append(double n, std::string &#38;str);
void to_text_append(float n, std::string &#38;str);

void to_text_append(bool f, std::string &#38;str);

void to_text_append(const void *p, std::string &#38;str);
</pre><p>Преобразователи несимвольных типов C++ в некоторое текстовое представление.
Второй параметр <tt>str</tt> - выходной параметр, к нему добавляется результат.
</p><div><u><b>Замечание</b></u>: Типы <tt>signed char</tt> и <tt>unsigned char</tt> воспринимаются как
целые, а не символы!</div><div><pre class="prototype">void to_text_append(long long n, std::string &#38;str)</pre><pre class="prototype">void to_text_append(long n, std::string &#38;str)</pre><pre class="prototype">void to_text_append(int n, std::string &#38;str)</pre><pre class="prototype">void to_text_append(short n, std::string &#38;str)</pre><pre class="prototype">void to_text_append(signed char n, std::string &#38;str)</pre><pre class="prototype">void to_text_append(unsigned long long n, std::string &#38;str)</pre><pre class="prototype">void to_text_append(unsigned long n, std::string &#38;str)</pre><pre class="prototype">void to_text_append(unsigned n, std::string &#38;str)</pre><pre class="prototype">void to_text_append(unsigned short n, std::string &#38;str)</pre><pre class="prototype">void to_text_append(unsigned  char n, std::string &#38;str)</pre><pre class="prototype">void to_text_append(long double n, std::string &#38;str)</pre><pre class="prototype">void to_text_append(double n, std::string &#38;str)</pre><pre class="prototype">void to_text_append(float n, std::string &#38;str)</pre><blockquote><p>Преобразуют число в десятичное представление.</p></blockquote></div><div><pre class="prototype">void to_text_append(bool f, std::string &#38;str)</pre><blockquote><p>Преобразует булев тип в <tt>0</tt> или <tt>1</tt>.</p></blockquote></div><div><pre class="prototype">void to_text_append(const void *p, std::string &#38;str)</pre><blockquote><p>Преобразует указатель в некоторое платформо-специфичное представление.</p></blockquote></div><div class="section">Пример</div><pre class="code">
int n = 5;
std::string st = "n = ";
__vic::to_text_append(n, st);
assert(st == "n = 5");
</pre><h2 id="type_traits.h"><span class="h2_num">2.31</span><tt>__vic/type_traits.h</tt></h2><p>Поддержка метапрограммирования с помощью шаблонов.</p><p>Все метафункции-предикаты имеют член в виде булевой статической константы
по имени <tt>value</tt> и, как правило, порождены от
<tt>integral_constant</tt>.</p><p>Все метафункции-преобразователи типов имеют член-тип по имени <tt>type</tt>,
являющийся результатом преобразования.</p><p>Все шаблонные псевдонимы доступны только в режиме C++11.</p><h3 id="integral_constant"><span class="h3_num">2.31.1</span><tt>integral_constant</tt></h3><pre class="code">
template&#60;class T, T Val&gt;
struct integral_constant
{
    using value_type = T;
    using type = integral_constant&#60;T, Val&gt;;

    static constexpr T value = Val;
};
</pre><p>Базовый класс большиства метафункций с <tt>value</tt>.</p><h3 id="true_type"><span class="h3_num">2.31.2</span><tt>true_type</tt></h3><pre class="code">
using true_type = integral_constant&#60;bool, true&gt;;
</pre><p>Базовый класс метафункций-предикатов со значением <tt>true</tt>.</p><h3 id="false_type"><span class="h3_num">2.31.3</span><tt>false_type</tt></h3><pre class="code">
using false_type = integral_constant&#60;bool, false&gt;;
</pre><p>Базовый класс метафункций-предикатов со значением <tt>false</tt>.</p><h3 id="is_same"><span class="h3_num">2.31.4</span><tt>is_same</tt></h3><pre class="code">
template&#60;class T1, class T2&gt; struct is_same;
</pre><p>Предикат. Истинен, если <tt>T1</tt> и <tt>T2</tt> - это в точности один и
тот же тип.</p><h3 id="is_const"><span class="h3_num">2.31.5</span><tt>is_const</tt></h3><pre class="code">
template&#60;class T&gt; struct is_const;
</pre><p>Предикат. Истинен, если <tt>T</tt> имеет квалификатор <tt>const</tt>.</p><h3 id="is_signed_integer"><span class="h3_num">2.31.6</span><tt>is_signed_integer</tt></h3><pre class="code">
template&#60;class T&gt; struct is_signed_integer;
</pre><p>Предикат. Истинен, если <tt>T</tt> - «стандартный целый тип со знаком»
(см. Стандарт).</p><h3 id="is_unsigned_integer"><span class="h3_num">2.31.7</span><tt>is_unsigned_integer</tt></h3><pre class="code">
template&#60;class T&gt; struct is_unsigned_integer;
</pre><p>Предикат. Истинен, если <tt>T</tt> - «стандартный целый беззнаковый тип»
(см. Стандарт).</p><h3 id="remove_const"><span class="h3_num">2.31.8</span><tt>remove_const</tt></h3><pre class="code">
template&#60;class T&gt; struct remove_const;
template&#60;class T&gt; using remove_const_t = typename remove_const&#60;T&gt;::type;
</pre><p>Преобразователь типа. Удаляет у типа самый верхний квалификатор
<tt>const</tt>, либо просто возвращает <tt>T</tt>, если такого квалификатора
нет.</p><h3 id="remove_volatile"><span class="h3_num">2.31.9</span><tt>remove_volatile</tt></h3><pre class="code">
template&#60;class T&gt; struct remove_volatile;
template&#60;class T&gt; using remove_volatile_t = typename remove_volatile&#60;T&gt;::type;
</pre><p>Преобразователь типа. Удаляет у типа самый верхний квалификатор
<tt>volatile</tt>, либо просто возвращает <tt>T</tt>, если такого квалификатора
нет.</p><h3 id="remove_cv"><span class="h3_num">2.31.10</span><tt>remove_cv</tt></h3><pre class="code">
template&#60;class T&gt; struct remove_cv;
template&#60;class T&gt; using remove_cv_t = typename remove_cv&#60;T&gt;::type;
</pre><p>Преобразователь типа. Удаляет у типа самые верхние квалификаторы
<tt>const</tt> и/или <tt>volatile</tt>, либо просто возвращает <tt>T</tt>,
если таких квалификаторов нет.</p><h3 id="remove_reference"><span class="h3_num">2.31.11</span><tt>remove_reference</tt></h3><pre class="code">
template&#60;class T&gt; struct remove_reference;
template&#60;class T&gt; using remove_reference_t = typename remove_reference&#60;T&gt;::type;
</pre><p>Преобразователь типа. Возвращает тип, на который ссылается <tt>T</tt>, либо
просто возвращает <tt>T</tt>, если он не является ссылкой.</p><h3 id="remove_cvref"><span class="h3_num">2.31.12</span><tt>remove_cvref</tt></h3><pre class="code">
template&#60;class T&gt; struct remove_cvref;
template&#60;class T&gt; using remove_cvref_t = typename remove_cvref&#60;T&gt;::type;
</pre><p>Преобразователь типа. Применяет <tt>remove_reference</tt>, затем
<tt>remove_cv</tt> к <tt>T</tt>.</p><h3 id="remove_pointer"><span class="h3_num">2.31.13</span><tt>remove_pointer</tt></h3><pre class="code">
template&#60;class T&gt; struct remove_pointer;
template&#60;class T&gt; using remove_pointer_t = typename remove_pointer&#60;T&gt;::type;
</pre><p>Преобразователь типа. Возвращает тип, на который указывает <tt>T</tt>, либо
просто возвращает <tt>T</tt>, если он не является указателем.</p><h3 id="enable_if"><span class="h3_num">2.31.14</span><tt>enable_if</tt>, <tt>disable_if</tt></h3><pre class="code">
template&#60;bool Test, class T = void&gt;
struct enable_if
{
    using type = T;
};
template&#60;class T&gt;
struct enable_if&#60;false, T&gt; {};

template&#60;bool Test, class T = void&gt;
struct disable_if : enable_if&#60;!Test, T&gt; {};
</pre><p>Классические инструменты для фокусов со SFINAE.</p><h3 id="index_sequence"><span class="h3_num">2.31.15</span><tt>index_sequence</tt>, <tt>make_index_sequence</tt> <span class="sign">[C++11]</span></h3><pre class="code">
template&#60;size_t... I&gt;
struct index_sequence
{
    static constexpr size_t size() { return sizeof...(I); }
};

template&#60;size_t Size&gt;
using make_index_sequence = index_sequence&#60;0, 1, ..., Size-1&gt;;
</pre><p>Реализация <tt>std::index_sequence</tt> из C++14 для C++11.</p><div><u><b>Замечание</b></u>: В отличие от <tt>std::index_sequence</tt>, не является специализацией
какого-то аналога <tt>std::integer_sequence</tt>.</div><h2 id="unicode.h"><span class="h2_num">2.32</span><tt>__vic/unicode.h</tt></h2><p>Утилиты для поддержки <a href="https://www.unicode.org/">Unicode</a>.
</p><h3 id="unicode_t"><span class="h3_num">2.32.1</span><tt>unicode_t</tt></h3><pre class="code">
using unicode_t = char32_t; // since C++11
// или
using unicode_t = uint_least32_t; // C++98
</pre><p>Тип, предназначениый для хранения Unicode
<a href="https://www.unicode.org/glossary/#code_point">code point</a>.</p><h3 id="utf_transcode"><span class="h3_num">2.32.2</span><tt>utf_transcode()</tt></h3><pre class="code">
template&#60;class UTFReader, class UTFWriter&gt;
void utf_transcode(UTFReader r, UTFWriter w);
</pre><p>Алгоритм, читающий code points типа <a href="#unicode_t"><tt>unicode_t</tt></a> из
<tt>UTFReader</tt>, используя <tt>r.read()</tt>, и записывающий их в
<tt>UTFWriter</tt>, используя <tt>w.write()</tt>.</p><h3 id="unicode_code_point_constants"><span class="h3_num">2.32.3</span><tt>Code point constants</tt></h3><pre class="code">
constexpr unicode_t unicode_max = 0x10FFFF;
constexpr unicode_t unicode_bom = 0xFEFF;
constexpr unicode_t unicode_replacement_char = 0xFFFD;
</pre><p>Именованные константы некоторых полезных Unicode code points.</p><h2 id="utf8.status.h"><span class="h2_num">2.33</span><tt>__vic/utf8/status.h</tt></h2><h3 id="utf8--status"><span class="h3_num">2.33.1</span><tt>utf8::status</tt></h3><pre class="code">
enum class utf8::status
{
    ok = 0,
    eof,
    // Errors
    no_leading_byte,
    truncated_code_point,
    overlong_encoding,
    code_point_too_big
};
using utf8::status_t = utf8::status; // for C++98
</pre><p>Значения, возвращаемые функцией <tt>parse()</tt> класса
<a href="#utf8--reader"><tt>utf8::reader</tt></a>.</p><ul><li><tt>ok</tt> - code point успешно прочитан</li><li><tt>eof</tt> - больше нечего читать</li><li><tt>no_leading_byte</tt> - многобайтовая последовательность
        без ведущего байта</li><li><tt>truncated_code_point</tt> - оборванная многобайтовая
        последовательность</li><li><tt>overlong_encoding</tt> - использовано чрезмерно длинное
        представление</li><li><tt>code_point_too_big</tt> - code point имеет слишком большое
        значение</li></ul><h3 id="utf8--is_error"><span class="h3_num">2.33.2</span><tt>utf8::is_error()</tt></h3><pre class="code">
constexpr bool utf8::is_error(utf8::status s);
</pre><p>Возвращает <tt>false</tt> для значений <tt>utf8::status::ok</tt> и
<tt>utf8::status::eof</tt>. В остальных случаях возвращается <tt>true</tt>.</p><h3 id="utf8--throw_if_error"><span class="h3_num">2.33.3</span><tt>utf8::throw_if_error()</tt></h3><pre class="code">
bool utf8::throw_if_error(utf8::status s);
</pre><p>Бросает исключение из <a href="#utf8.exceptions.h"><tt>__vic/utf8/exceptions.h</tt></a> в случае
<tt>is_error(s)</tt>. Возвращает <tt>true</tt> для <tt>utf8::status::ok</tt>
или <tt>false</tt> для <tt>utf8::status::eof</tt>.</p><h2 id="utf8.exceptions.h"><span class="h2_num">2.34</span><tt>__vic/utf8/exceptions.h</tt></h2><pre class="code">
namespace utf8 {

class bad_encoding; // public std::exception
    class no_leading_byte;
    class truncated_code_point;
    class overlong_encoding;
    class code_point_too_big;

} // namespace
</pre><p>Классы исключений, бросаемые функцией <tt>read()</tt> класса
<a href="#utf8--reader"><tt>utf8::reader</tt></a>. Все исключения порождены от абстактного базового
класса <tt>utf8::bad_encoding</tt>. Эквивалентные коды статусов описаны в
<a href="#utf8--status"><tt>utf8::status</tt></a>.</p><h2 id="utf8.reader.h"><span class="h2_num">2.35</span><tt>__vic/utf8/reader.h</tt></h2><h3 id="utf8--reader"><span class="h3_num">2.35.1</span><tt>utf8::reader</tt></h3><pre class="code">
template&#60;class ByteReader&gt;
class utf8::reader
{
public:
    using byte_reader_type = ByteReader;
    ByteReader &#38;get_byte_reader();
    const ByteReader &#38;get_byte_reader() const;

    template&#60;class... Args&gt;
    explicit reader(Args&#38;&#38;... args); // since C++11

    reader(); // C++98 only
    explicit reader(ByteReader r); // C++98 only

    status_t parse(unicode_t &#38;cp);
    bool read(unicode_t &#38;cp);
};

template&#60;class ByteReader&gt;
utf8::reader&#60;ByteReader&gt; utf8::make_reader(ByteReader r);
</pre><p>Вычитывает UTF-8 code points из последовательности байтов.
Последовательность читается посредством <tt>ByteReader</tt>, который
моделирует <tt>Reader&#60;unsigned char&gt;</tt> (см. <a href="#readers"><tt>__vic/readers/</tt></a>).</p><div class="section">Члены класса</div><div><pre class="prototype">ByteReader &#38;get_byte_reader()</pre><pre class="prototype">const ByteReader &#38;get_byte_reader() const</pre><blockquote><p>Возвращает ссылку на используемый byte reader.</p></blockquote></div><div><pre class="prototype">template&#60;class... Args&gt;
explicit reader(Args&#38;&#38;... args) <span class="sign">[C++11]</span></pre><blockquote><p>Передаёт все параметры в используемый byte reader.</p></blockquote></div><div><pre class="prototype">reader() <span class="sign">[C++98 only]</span></pre><pre class="prototype">explicit reader(ByteReader r) <span class="sign">[C++98 only]</span></pre><blockquote><p>Конструкторы для режима C++98.</p></blockquote></div><div><pre class="prototype">status_t parse(unicode_t &#38;cp)</pre><blockquote><p>Пытается извлечь следующий code point из последовательности байтов, используя
<tt>ByteReader</tt>. В случае успеха возвращается <tt>utf8::status::ok</tt>,
code point сохраняется в <tt>cp</tt>. Если байты кончились, возвращается
<tt>utf8::status::eof</tt>. Другие значения возвращаются в случае ошибок,
подробности см. в <a href="#utf8--status"><tt>utf8::status</tt></a>. Для доступа к отдельным байтам
используется <tt>ByteReader::read()</tt>.</p><div><u>Замечание</u>: Функция сама по себе не бросает исключений, но их может бросать
<tt>ByteReader::read()</tt>.</div></blockquote></div><div><pre class="prototype">bool read(unicode_t &#38;cp)</pre><blockquote><p>То же самое, что <tt>parse()</tt>, но возвращает <tt>true</tt> в случае
успеха, <tt>false</tt> в случае EOF, бросает исключения из
<a href="#utf8.exceptions.h"><tt>__vic/utf8/exceptions.h</tt></a> в остальных случаях.</p></blockquote></div><div class="section">Свободные функции</div><div><pre class="prototype">template&#60;class ByteReader&gt;
utf8::reader&#60;ByteReader&gt; utf8::make_reader(ByteReader r)</pre><blockquote><p>Создаёт UTF-8 reader используя указанный <tt>ByteReader</tt>.</p></blockquote></div><div class="section">Пример</div><pre class="code">
#include&#60;__vic/utf8/reader.h&gt;
#include&#60;__vic/readers/string.h&gt;
#include&#60;string&gt;
#include&#60;cstdint&gt;
#include&#60;iostream&gt;

// C++11
using utf8_string_reader = __vic::utf8::reader&#60;__vic::string_reader&gt;;

// C++98
struct utf8_string_reader : __vic::utf8::reader&#60;__vic::string_reader&gt;
{
    explicit utf8_string_reader(const std::string &#38;s)
        : __vic::utf8::reader&#60;__vic::string_reader&gt;(__vic::string_reader(s)) {}
};

void print_utf8_code_points(const string &#38;s)
{
    utf8_string_reader r(s);
    __vic::unicode_t cp;
    while(r.read(cp))
        std::cout &#60;&#60; uint_least32_t(cp) &#60;&#60; '\n';
}
</pre><h2 id="utf8.writer.h"><span class="h2_num">2.36</span><tt>__vic/utf8/writer.h</tt></h2><h3 id="utf8--writer"><span class="h3_num">2.36.1</span><tt>utf8::writer</tt></h3><pre class="code">
template&#60;class ByteWriter&gt;
class utf8::writer
{
public:
    using byte_writer_type = ByteWriter;
    ByteWriter &#38;get_byte_writer();
    const ByteWriter &#38;get_byte_writer() const;

    template&#60;class... Args&gt;
    explicit writer(Args&#38;&#38;... args); // since C++11

    writer(); // C++98 only
    explicit writer(ByteWriter w); // C++98 only

    void write(unicode_t cp);
};

template&#60;class ByteWriter&gt;
utf8::writer&#60;ByteWriter&gt; utf8::make_writer(ByteWriter w);
</pre><p>Пишет UTF-8 code points в последовательность байтов. Для вывода байтов
используется <tt>ByteWriter</tt>, моделирующий <tt>Writer&#60;unsigned char&gt;</tt>
(см. <a href="#writers"><tt>__vic/writers/</tt></a>).</p><div class="section">Члены класса</div><div><pre class="prototype">ByteWriter &#38;get_byte_writer()</pre><pre class="prototype">const ByteWriter &#38;get_byte_writer() const</pre><blockquote><p>Возвращает ссылку на используемый byte writer.</p></blockquote></div><div><pre class="prototype">template&#60;class... Args&gt;
explicit writer(Args&#38;&#38;... args) <span class="sign">[C++11]</span></pre><blockquote><p>Передаёт все параметры в используемый byte writer.</p></blockquote></div><div><pre class="prototype">writer() <span class="sign">[C++98 only]</span></pre><pre class="prototype">explicit writer(ByteWriter r) <span class="sign">[C++98 only]</span></pre><blockquote><p>Конструкторы для режима C++98.</p></blockquote></div><div><pre class="prototype">void write(unicode_t cp)</pre><blockquote><p>Выводит указанный code point согласно правилам кодирования UTF-8.
Для записи отдельных байтов используется <tt>ByteWriter::write()</tt>.</p></blockquote></div><div class="section">Свободные функции</div><div><pre class="prototype">template&#60;class ByteWriter&gt;
utf8::writer&#60;ByteWriter&gt; utf8::make_writer(ByteWriter w)</pre><blockquote><p>Создаёт UTF-8 writer используя указанный <tt>ByteWriter</tt>.</p></blockquote></div><div class="section">Пример</div><pre class="code">
#include&#60;__vic/utf8/writer.h&gt;
#include&#60;__vic/writers/string.h&gt;
#include&#60;string&gt;
#include&#60;vector&gt;

// C++11
using utf8_string_writer = __vic::utf8::writer&#60;__vic::string_writer&gt;;

// C++98
struct utf8_string_writer : __vic::utf8::writer&#60;__vic::string_writer&gt;
{
    explicit utf8_string_writer(std::string &#38;s)
        : __vic::utf8::writer&#60;__vic::string_writer&gt;(__vic::string_writer(s)) {}
};

std::string encode_utf8(const std::vector&#60;__vic::unicode_t&gt; &#38;code_points)
{
    std::string utf8_res;
    utf8_string_writer w(utf8_res);
    for(auto cp : code_points) w.write(cp);
    return utf8_res;
}
</pre><h2 id="utf16.defs.h"><span class="h2_num">2.37</span><tt>__vic/utf16/defs.h</tt></h2><h3 id="utf16--code_unit_t"><span class="h3_num">2.37.1</span><tt>utf16::code_unit_t</tt></h3><pre class="code">
namespace utf16 {

using code_unit_t = char16_t; // since C++11
// или
using code_unit_t = uint_least16_t; // C++98

} // namespace
</pre><p>Тип для UTF-16 <a href="https://unicode.org/glossary/#code_unit">code unit</a>.</p><h2 id="utf16.status.h"><span class="h2_num">2.38</span><tt>__vic/utf16/status.h</tt></h2><h3 id="utf16--status"><span class="h3_num">2.38.1</span><tt>utf16::status</tt></h3><pre class="code">
enum class utf16::status
{
    ok = 0,
    eof,
    // Errors
    truncated_code_unit,
    truncated_code_point,
    invalid_sequence
};
using utf16::status_t = utf16::status; // for C++98
</pre><p>Значения, возвращаемые функцией <tt>parse()</tt> класса
<a href="#utf16--reader"><tt>utf16::reader</tt></a>.</p><ul><li><tt>ok</tt> - code point успешно прочитан</li><li><tt>eof</tt> - больше нечего читать</li><li><tt>truncated_code_unit</tt> - оборванный code unit</li><li><tt>truncated_code_point</tt> - оборванный code point</li><li><tt>invalid_sequence</tt> - байты не кодируют правильный
        UTF-16 code point</li></ul><h3 id="utf16--is_error"><span class="h3_num">2.38.2</span><tt>utf16::is_error()</tt></h3><pre class="code">
constexpr bool utf16::is_error(utf16::status s);
</pre><p>Возвращает <tt>false</tt> для значений <tt>utf16::status::ok</tt> и
<tt>utf16::status::eof</tt>. В остальных случаях возвращается <tt>true</tt>.</p><h3 id="utf16--throw_if_error"><span class="h3_num">2.38.3</span><tt>utf16::throw_if_error()</tt></h3><pre class="code">
bool utf16::throw_if_error(utf16::status s);
</pre><p>Бросает исключение из <a href="#utf16.exceptions.h"><tt>__vic/utf16/exceptions.h</tt></a> в случае
<tt>is_error(s)</tt>. Возвращает <tt>true</tt> для <tt>utf16::status::ok</tt>
или <tt>false</tt> для <tt>utf16::status::eof</tt>.</p><h2 id="utf16.exceptions.h"><span class="h2_num">2.39</span><tt>__vic/utf16/exceptions.h</tt></h2><pre class="code">
namespace utf16 {

class bad_encoding; // public std::exception
    class truncated_code_unit;
    class truncated_code_point;
    class invalid_sequence;

} // namespace
</pre><p>Классы исключений, бросаемые функцией <tt>read()</tt> класса
<a href="#utf16--reader"><tt>utf16::reader</tt></a>. Все исключения порождены от абстактного базового
класса <tt>utf16::bad_encoding</tt>. Эквивалентные коды статусов описаны в
<a href="#utf16--status"><tt>utf16::status</tt></a>.</p><h2 id="utf16.reader.h"><span class="h2_num">2.40</span><tt>__vic/utf16/reader.h</tt></h2><h3 id="utf16--reader"><span class="h3_num">2.40.1</span><tt>utf16::reader</tt></h3><pre class="code">
template&#60;class CodeUnitReader&gt;
class utf16::reader
{
public:
    using code_unit_reader_type = CodeUnitReader;
    CodeUnitReader &#38;get_code_unit_reader();
    const CodeUnitReader &#38;get_code_unit_reader() const;

    template&#60;class... Args&gt;
    explicit reader(Args&#38;&#38;... args);  // since C++11

    reader(); // C++98 only
    explicit reader(CodeUnitReader r); // C++98 only

    status_t parse(unicode_t &#38;cp);
    bool read(unicode_t &#38;cp);
};

template&#60;class CodeUnitReader&gt;
utf16::reader&#60;CodeUnitReader&gt; utf16::make_reader(CodeUnitReader r);
</pre><p>Вычитывает UTF-16 code points из последовательности 2-байтовых
<a href="#utf16--code_unit_t"><tt>utf16::code_unit_t</tt></a>. Последовательность читается посредством
специального reader, имеющего следующую структуру:</p><pre class="code">
class <span class="nonterminal">CodeUnitReader</span>
{
public:
    utf16::status_t read_unit(utf16::code_unit_t &#38;u);
};
</pre><div><pre class="prototype">utf16::status_t read_unit(utf16::code_unit_t &#38;u)</pre><blockquote><p>Пытается вычитать следующий code unit. Возвращает <tt>utf16::status::ok</tt>
в случае успеха, <tt>utf16::status::eof</tt>, если больше не осталось code units,
либо <tt>utf16::status::truncated_code_unit</tt> если доступна только часть
code unit.</p></blockquote></div><div class="section">Члены класса</div><div><pre class="prototype">CodeUnitReader &#38;get_code_unit_reader()</pre><pre class="prototype">const CodeUnitReader &#38;get_code_unit_reader() const</pre><blockquote><p>Возвращает ссылку на используемый code unit reader.</p></blockquote></div><div><pre class="prototype">template&#60;class... Args&gt;
explicit reader(Args&#38;&#38;... args) <span class="sign">[C++11]</span></pre><blockquote><p>Передаёт все параметры в используемый code unit reader.</p></blockquote></div><div><pre class="prototype">reader() <span class="sign">[C++98 only]</span></pre><pre class="prototype">explicit reader(CodeUnitReader r) <span class="sign">[C++98 only]</span></pre><blockquote><p>Конструкторы для режима C++98.</p></blockquote></div><div><pre class="prototype">status_t parse(unicode_t &#38;cp)</pre><blockquote><p>Пытается извлечь следующий code point из последовательности code unit,
используя <tt>CodeUnitReader</tt>. В случае успеха возвращается
<tt>utf16::status::ok</tt>, code point сохраняется в <tt>cp</tt>. Если code
units кончились, возвращается <tt>utf16::status::eof</tt>. Другие значения
возвращаются в случае ошибок, подробности см. в <a href="#utf16--status"><tt>utf16::status</tt></a>.
Для доступа к отдельным code units используется
<tt>CodeUnitReader::read_unit()</tt>.</p><div><u>Замечание</u>: Функция сама по себе не бросает исключений, но их может бросать
<tt>CodeUnitReader::read_unit()</tt>.</div></blockquote></div><div><pre class="prototype">bool read(unicode_t &#38;cp)</pre><blockquote><p>То же самое, что <tt>parse()</tt>, но возвращает <tt>true</tt> в случае
успеха, <tt>false</tt> в случае EOF, бросает исключения из
<a href="#utf16.exceptions.h"><tt>__vic/utf16/exceptions.h</tt></a> в остальных случаях.</p></blockquote></div><div class="section">Свободные функции</div><div><pre class="prototype">template&#60;class CodeUnitReader&gt;
utf16::reader&#60;CodeUnitReader&gt; utf16::make_reader(CodeUnitReader r)</pre><blockquote><p>Создаёт UTF-16 reader используя указанный <tt>CodeUnitReader</tt>.</p></blockquote></div><div class="section">Пример</div><pre class="code">
#include&#60;__vic/utf16/reader.h&gt;
#include&#60;__vic/readers/string.h&gt;
#include&#60;string&gt;
#include&#60;cstdint&gt;
#include&#60;iostream&gt;

class u16string_code_unit_reader
{
    __vic::basic_string_reader&#60;char16_t&gt; r;
public:
    explicit u16string_code_unit_reader(const std::u16string &#38;s) : r(s) {}

    __vic::utf16::status_t read_unit(__vic::utf16::code_unit_t &#38;u)
    {
        if(r.read(u)) return __vic::utf16::status::ok;
        return __vic::utf16::status::eof;
    }
};

void print_utf16_code_points(const std::u16string &#38;s)
{
    __vic::utf16::reader&#60;u16string_code_unit_reader&gt; r(s);
    __vic::unicode_t cp;
    while(r.read(cp))
        std::cout &#60;&#60; uint_least32_t(cp) &#60;&#60; '\n';
}
</pre><h2 id="utf16.writer.h"><span class="h2_num">2.41</span><tt>__vic/utf16/writer.h</tt></h2><h3 id="utf16--writer"><span class="h3_num">2.41.1</span><tt>utf16::writer</tt></h3><pre class="code">
template&#60;class CodeUnitWriter&gt;
class utf16::writer
{
public:
    using code_unit_writer_type = CodeUnitWriter;
    CodeUnitWriter &#38;get_code_unit_writer();
    const CodeUnitWriter &#38;get_code_unit_writer() const;

    template&#60;class... Args&gt;
    explicit writer(Args&#38;&#38;... args); // since C++11

    writer(); // C++98 only
    explicit writer(CodeUnitWriter w); // C++98 only

    void write(unicode_t cp);
};

template&#60;class CodeUnitWriter&gt;
utf16::writer&#60;CodeUnitWriter&gt; utf16::make_writer(CodeUnitWriter w);
</pre><p>Пишет UTF-16 code points в последовательность 2-байтовых
<a href="#utf16--code_unit_t"><tt>utf16::code_unit_t</tt></a>. Для вывода code units используется
<tt>CodeUnitWriter</tt>, моделирующий <tt>Writer&#60;utf16::code_unit_t&gt;</tt>
(см. <a href="#writers"><tt>__vic/writers/</tt></a>).</p><div class="section">Члены класса</div><div><pre class="prototype">CodeUnitWriter &#38;get_code_unit_writer()</pre><pre class="prototype">const CodeUnitWriter &#38;get_code_unit_writer() const</pre><blockquote><p>Возвращает ссылку на используемый code unit writer.</p></blockquote></div><div><pre class="prototype">template&#60;class... Args&gt;
explicit writer(Args&#38;&#38;... args) <span class="sign">[C++11]</span></pre><blockquote><p>Передаёт все параметры в используемый code unit writer.</p></blockquote></div><div><pre class="prototype">writer() <span class="sign">[C++98 only]</span></pre><pre class="prototype">explicit writer(CodeUnitWriter r) <span class="sign">[C++98 only]</span></pre><blockquote><p>Конструкторы для режима C++98.</p></blockquote></div><div><pre class="prototype">void write(unicode_t cp)</pre><blockquote><p>Выводит указанный code point согласно правилам кодирования UTF-16.
Для записи отдельных code units ипользуется <tt>CodeUnitWriter::write()</tt>.
</p></blockquote></div><div class="section">Свободные функции</div><div><pre class="prototype">template&#60;class CodeUnitWriter&gt;
utf16::writer&#60;CodeUnitWriter&gt; utf16::make_writer(CodeUnitWriter w)</pre><blockquote><p>Создаёт UTF-16 writer используя указанный <tt>CodeUnitWriter</tt>.</p></blockquote></div><div class="section">Пример</div><pre class="code">
#include&#60;__vic/utf16/writer.h&gt;
#include&#60;__vic/writers/string.h&gt;
#include&#60;string&gt;
#include&#60;vector&gt;

std::u16string encode_utf16(const std::vector&#60;__vic::unicode_t&gt; &#38;code_points)
{
    std::u16string utf16_res;
    __vic::utf16::writer&#60;__vic::basic_string_writer&#60;char16_t&gt;&gt; w(utf16_res);
    for(auto cp : code_points) w.write(cp);
    return utf16_res;
}
</pre><h2 id="waitable_event.h"><span class="h2_num">2.42</span><tt>__vic/waitable_event.h</tt></h2><h3 id="waitable_event"><span class="h3_num">2.42.1</span><tt>waitable_event</tt></h3><pre class="code">
class waitable_event : private non_copyable
{
public:
    explicit waitable_event(bool signaled = false);
    ~waitable_event();

    void set();
    void reset();
    bool signaled() const;

    void wait();
    bool wait_ms(unsigned msec);

    // BEGIN C++11
    template&#60;class Rep, class Period&gt;
    bool wait_for(const std::chrono::duration&#60;Rep,Period&gt; &#38;d);
    template&#60;class Clock, class Duration&gt;
    bool wait_until(const std::chrono::time_point&#60;Clock,Duration&gt; &#38;t);
    // END C++11
};

</pre><p>Инструмент синхронизации, подобный «Event Object» в ОС Windows. Может
находиться в одном из двух состояний: сигнальном или несигнальном. Поток
может эффективно ждать перехода в сигнальное состояние, используя
предоставляемые wait-функции (с минимальным потреблением ресурсов системы).</p><div class="section">Члены класса</div><div><pre class="prototype">explicit waitable_event(bool signaled = false)</pre><blockquote><div><u>Постусловие</u>: <tt>signaled() == signaled</tt></div></blockquote></div><div><pre class="prototype">bool signaled() const</pre><blockquote><p>Возвращает <tt>true</tt>, если объект находится в сигнальном состоянии.</p></blockquote></div><div><pre class="prototype">void set()</pre><blockquote><p>Устанавливает сигнальное состояние.</p><div><u>Постусловие</u>: <tt>signaled() == true</tt></div></blockquote></div><div><pre class="prototype">void reset()</pre><blockquote><p>Устанавливает несигнальное состояние.</p><div><u>Постусловие</u>: <tt>signaled() == false</tt></div></blockquote></div><div><pre class="prototype">void wait()</pre><blockquote><p>Ждёт сигнального состояния без таймаута.</p><div><u>Постусловие</u>: <tt>signaled() == true</tt></div></blockquote></div><div><pre class="prototype">bool wait_ms(unsigned msec)</pre><blockquote><p>Ждёт сигнального состояния не дольше указанного таймаута в миллисекундах.
Returns <tt>signaled()</tt>.</p><div><u>Замечание</u>: В режиме C++11 используйте <tt>wait_for()</tt>.</div></blockquote></div><div><pre class="prototype">template&#60;class Rep, class Period&gt;
bool wait_for(const std::chrono::duration&#60;Rep,Period&gt; &#38;d) <span class="sign">[C++11]</span></pre><pre class="prototype">template&#60;class Clock, class Duration&gt;
bool wait_until(const std::chrono::time_point&#60;Clock,Duration&gt; &#38;t) <span class="sign">[C++11]</span></pre><blockquote><p>Ждёт сигнального состояния не дольше указанного таймаута. Возвращает
<tt>signaled()</tt>.</p></blockquote></div><h2 id="writers"><span class="h2_num">2.43</span><tt>__vic/writers/</tt></h2><h3 id="writer-concept"><span class="h3_num">2.43.1</span><tt>Writer</tt> concept</h3><pre class="code">
template&#60;class ElementT&gt;
class <span class="nonterminal">Writer</span>
{
public:
    Writer(Writer &#38;&#38;o); or Writer(const Writer &#38;o);
    void write(ElementT v); // throws on errors
};
</pre><p>Concept, используемый алгоритмами библиотеки для поэлементной записи
логической последовательности элементов типа <tt>ElementT</tt>. Является
обобщением и переработкой concept'а <tt>OutputIterator</tt>. В частности,
он лучше обрабатывает потоки ввода/вывода и другие последовательности, в
которых <tt>end</tt>-итератор не имеет смысла или его получение дорого. В то
же время, традиционные выходные итераторы являются частным просто случаем и
полностью поддерживаются адаптером <tt>__vic::iterator_writer</tt>.</p><p>В случаях, когда конкретный класс удовлетворяет требованиям данного concept
для некоторого <tt>ElementT = T</tt>, говорят, что он <b>моделирует</b> concept
<tt>Writer&#60;T&gt;</tt>.</p><p>Каждый экземпляр класса должен быть move- или copy-constructible.</p><div class="section">Члены класса</div><div><pre class="prototype">void write(ElementT v)</pre><blockquote><p>Записывает элемент или бросает исключение в случае ошибки.</p></blockquote></div><h3 id="null_writer"><span class="h3_num">2.43.2</span><tt>null_writer</tt></h3><pre class="code">
#include&#60;__vic/writers/null.h&gt;

class null_writer
{
public:
    template&#60;class T&gt; void write(T v) {}
};

null_writer make_null_writer();
</pre><p>Фиктивный writer, принимающий любые значения и никуда их не выводящий (как
<tt>/dev/null</tt> в UNIX).</p><h3 id="push_back_writer"><span class="h3_num">2.43.3</span><tt>push_back_writer</tt></h3><pre class="code">
#include&#60;__vic/writers/push_back.h&gt;

template&#60;class Cont, class T = typename Cont::value_type&gt;
class push_back_writer
{
public:
    explicit push_back_writer(Cont &#38;c);
    void write(T v) { c-&gt;push_back(v); }
};

template&#60;class Cont&gt;
push_back_writer&#60;Cont&gt; make_push_back_writer(Cont &#38;c);

template&#60;class T, class Cont&gt;
push_back_writer&#60;Cont,T&gt; make_push_back_writer_for(Cont &#38;c);
</pre><p>Адаптер. Использует функцию-член <tt>push_back()</tt> для записи элементов.
Может быть создан с помощью конструктора или одной из функций <tt>make_...</tt>.
</p><h3 id="iterator_writer"><span class="h3_num">2.43.4</span><tt>iterator_writer</tt></h3><pre class="code">
#include&#60;__vic/writers/iterator.h&gt;

template&#60;class OutputIterator,
         class T = typename std::iterator_traits&#60;OutputIterator&gt;::value_type&gt;
class iterator_writer
{
public:
    explicit iterator_writer(OutputIterator it);
    void write(T v);
};

template&#60;class OutputIterator&gt;
iterator_writer&#60;OutputIterator&gt; make_iterator_writer(OutputIterator it);

template&#60;class T, class OutputIterator&gt;
iterator_writer&#60;OutputIterator,T&gt; make_iterator_writer_for(OutputIterator it);
</pre><p>Записывает элементы в выходной итератор. Может быть создан с помощью
конструктора или одной из функций <tt>make_...</tt>.</p><h3 id="string_writer"><span class="h3_num">2.43.5</span><tt>string_writer</tt></h3><pre class="code">
#include&#60;__vic/writers/string.h&gt;

template&#60;
    class charT,
    class Tr = std::char_traits&#60;charT&gt;,
    class Al = std::allocator&#60;charT&gt;
&gt;
class basic_string_writer
{
public:
    explicit basic_string_writer(std::basic_string&#60;charT,Tr,Al&gt; &#38;s);
    void write(charT ch);
};

using string_writer = basic_string_writer&#60;char&gt;;

template&#60;class charT, class Tr, class Al&gt;
basic_string_writer&#60;charT,Tr,Al&gt;
    make_string_writer(std::basic_string&#60;charT,Tr,Al&gt; &#38;s);
</pre><p>Адаптер для <tt>std::basic_string</tt>. Может быть создан с помощью
конструктора или функции <tt>make_...</tt>.</p><h3 id="cstream_writer"><span class="h3_num">2.43.6</span><tt>cstream_writer</tt></h3><pre class="code">
#include&#60;__vic/writers/cstream.h&gt;

class cstream_writer
{
public:
    explicit cstream_writer(std::FILE *fp);
    void write(char ch) { __vic::write(fp, ch); }
};

cstream_writer make_cstream_writer(std::FILE *fp);
</pre><p>Моделирует <tt>Writer&#60;char&gt;</tt> для <tt>std::FILE</tt>. Может быть
создан с помощью конструктора или функции <tt>make_...</tt>.</p><h2 id="windows.critical_section.h"><span class="h2_num">2.44</span><tt>__vic/windows/critical_section.h</tt></h2><h3 id="windows--CriticalSection"><span class="h3_num">2.44.1</span><tt>windows::CriticalSection</tt></h3><pre class="code">
class windows::CriticalSection : private non_copyable
{
public:
    CriticalSection();
    ~CriticalSection();

    void Enter();
    bool TryEnter();
    void Leave() noexcept;

    ::CRITICAL_SECTION *handle();
    const ::CRITICAL_SECTION *handle() const;
};
</pre><p>C++ обёртка для <tt>CRITICAL_SECTION</tt> из Win32 API.</p><div class="section">Члены класса</div><div><pre class="prototype">CriticalSection()</pre><blockquote><p>Вызывает <tt>::InitializeCriticalSection()</tt>.</p></blockquote></div><div><pre class="prototype">~CriticalSection()</pre><blockquote><p>Вызывает <tt>::LeaveCriticalSection()</tt>.</p></blockquote></div><div><pre class="prototype">void Enter()</pre><blockquote><p>Вызывает <tt>::EnterCriticalSection()</tt>.</p></blockquote></div><div><pre class="prototype">bool TryEnter()</pre><blockquote><p>Вызывает <tt>::TryEnterCriticalSection()</tt> и возвращает результат.</p></blockquote></div><div><pre class="prototype">void Leave() noexcept</pre><blockquote><p>Вызывает <tt>::LeaveCriticalSection()</tt>.</p></blockquote></div><div><u><b>Замечание</b></u>: Следует избегать прямых вызовов <tt>Enter()</tt>/<tt>Leave()</tt>,
используйте объекты <a href="#windows--CSGuard"><tt>windows::CSGuard</tt></a>.</div><h3 id="windows--CSGuard"><span class="h3_num">2.44.2</span><tt>windows::CSGuard</tt></h3><pre class="code">
class windows::CSGuard : private non_copyable
{
public:
    enum adopt_t { adopt };

    explicit CSGuard(::CRITICAL_SECTION &#38;cs);
    CSGuard(::CRITICAL_SECTION &#38;cs, adopt_t);

    explicit CSGuard(CriticalSection &#38;cs);
    CSGuard(CriticalSection &#38;cs, adopt_t);

    ~CSGuard();
};
</pre><p>Класс, контролирующий время жизни блокировки. Работает как с
<tt>::CRITICAL_SECTION</tt>, так и с <a href="#windows--CriticalSection"><tt>windows::CriticalSection</tt></a>.
</p><div class="section">Члены класса</div><div><pre class="prototype">explicit CSGuard(::CRITICAL_SECTION &#38;cs)</pre><pre class="prototype">explicit CSGuard(CriticalSection &#38;cs)</pre><blockquote><p>Вызывает <tt>::EnterCriticalSection(&#38;cs)</tt>.</p></blockquote></div><div><pre class="prototype">CSGuard(::CRITICAL_SECTION &#38;cs, adopt_t)</pre><pre class="prototype">CSGuard(CriticalSection &#38;cs, adopt_t)</pre><blockquote><p>Только сохраняет ссылку на <tt>cs</tt> без вызова
<tt>::EnterCriticalSection()</tt>.</p></blockquote></div><div><pre class="prototype">~CSGuard()</pre><blockquote><p>Вызывает <tt>::LeaveCriticalSection(&#38;cs)</tt>.</p></blockquote></div><div class="section">Пример</div><pre class="code">
// Типичное использование
void reentrant_function()
{
    static __vic::windows::CriticalSection cs;
    __vic::windows::CSGuard guard(cs);
    // Критическая секция до конца этого блока
    ...
}

// Использование adopt-конструктора
__vic::windows::CriticalSection cs;
if(cs.TryEnter()) // Пытаемся войти в критическую секцию
{
    // Удачно
    using __vic::windows::CSGuard;
    CSGuard guard(cs, CSGuard::adopt);
    // Критическая секция до конца этого блока
    ...
}
else
{
    // Критическая секция занята
    ...
}
</pre><h2 id="windows.error.h"><span class="h2_num">2.45</span><tt>__vic/windows/error.h</tt></h2><p>Специфичные для Windows инструменты обработки ошибок.</p><h3 id="windows--error"><span class="h3_num">2.45.1</span><tt>windows::error</tt></h3><pre class="code">
class windows::error : public std::exception
{
public:
    explicit error(DWORD err_code = ::GetLastError());
    explicit error(const char *prompt, DWORD err_code = ::GetLastError());

    const char *what() const noexcept;
    DWORD code() const;
};
</pre><p>Обёртка для системных кодов ошибок Windows, возвращаемых функцией Win32 API
<tt>GetLastError()</tt>. См. <a href="#libc_error"><tt>libc_error</tt></a> для справки.</p><h2 id="windows.event.h"><span class="h2_num">2.46</span><tt>__vic/windows/event.h</tt></h2><h3 id="windows--event"><span class="h3_num">2.46.1</span><tt>windows::event</tt></h3><pre class="code">
class windows::Event : private non_copyable
{
public:
    explicit Event(bool bManualReset,
         bool bInitialSignaled = false, LPCSTR lpName = nullptr);
    ~Event();

    void Set();
    void Reset();
    bool Wait(DWORD timeout = INFINITE) const;
    bool wait_for(std::chrono::milliseconds ms) const; // C++11

    HANDLE handle() const;
};
</pre><p>Обёртка для Win32 API event synchronization object.</p><div class="section">Члены класса</div><div><pre class="prototype">explicit Event(bool bManualReset, bool bInitialSignaled = false, LPCSTR lpName = nullptr)</pre><blockquote><p>Создаёт объект используя <tt>::CreateEvent()</tt>. Бросает исключения при
ошибках.</p></blockquote></div><div><pre class="prototype">~Event()</pre><blockquote><p>Уничтожает объект.</p></blockquote></div><div><pre class="prototype">void Set()</pre><blockquote><p>Вызывает <tt>::SetEvent()</tt>. Бросает исключения при ошибках.</p></blockquote></div><div><pre class="prototype">void Reset()</pre><blockquote><p>Вызывает <tt>::ResetEvent()</tt>. Бросает исключения при ошибках.</p></blockquote></div><div><pre class="prototype">bool Wait(DWORD timeout = INFINITE) const</pre><blockquote><p>Вызывает <tt>::WaitForSingleObject()</tt>. Бросает исключения при ошибках.</p></blockquote></div><div><pre class="prototype">bool wait_for(std::chrono::milliseconds ms) const <span class="sign">[C++11]</span></pre><blockquote><p>Обёртка <tt>Wait()</tt>, адаптированная для chrono.</p></blockquote></div><div><pre class="prototype">HANDLE handle() const</pre><blockquote><p>Возвращает Win32 API handle.</p></blockquote></div><h2 id="windows.find_file.h"><span class="h2_num">2.47</span><tt>__vic/windows/find_file.h</tt></h2><h3 id="windows--find_file"><span class="h3_num">2.47.1</span><tt>windows::find_file</tt></h3><pre class="code">
class windows::FindFile : public WIN32_FIND_DATA, private non_copyable
{
public:
    FindFile();
    ~FindFile();

    bool FindFirst(LPCTSTR filename);
    bool FindNext();

    bool IsOpen() const;
    void Close();
    bool CloseNT() noexcept;
};
</pre><p>Обёртка для функций Win32 API
<tt>FindFirstFile()</tt>/<tt>FindNextFile()</tt>. Специальные элементы <tt>.</tt>
и <tt>..</tt> никогда не включаются в результирующий набор.</p><div class="section">Члены класса</div><div><pre class="prototype">FindFile()</pre><blockquote><div><u>Постусловие</u>: <tt>IsOpen() == false</tt></div></blockquote></div><div><pre class="prototype">~FindFile()</pre><blockquote><p>Вызывает <tt>CloseNT()</tt>, если <tt>IsOpen() == true</tt>.</p></blockquote></div><div><pre class="prototype">bool FindFirst(LPCTSTR filename)</pre><blockquote><p>Вызывает <tt>FindFirstFile()</tt>. Возвращает <tt>false</tt>, если таких
файлов не найдено. Бросает <a href="#windows--error"><tt>windows::error</tt></a> в случае других ошибок.</p><div><u>Предусловие</u>: <tt>IsOpen() == false</tt></div></blockquote></div><div><pre class="prototype">bool FindNext()</pre><blockquote><p>Вызывает <tt>FindNextFile()</tt>. Возвращает <tt>false</tt>, если больше
таких файлов нет. Бросает <a href="#windows--error"><tt>windows::error</tt></a> в случае других
ошибок.</p><div><u>Предусловие</u>: <tt>IsOpen() == true</tt></div></blockquote></div><div><pre class="prototype">bool Close()</pre><blockquote><p>Закрывает поисковый дескриптор. Бросает <a href="#windows--error"><tt>windows::error</tt></a> в случае
ошибок.</p><div><u>Предусловие</u>: <tt>IsOpen() == true</tt></div><div><u>Постусловие</u>: <tt>IsOpen() == false</tt></div></blockquote></div><div><pre class="prototype">bool CloseNT() noexcept</pre><blockquote><p>То же самое, что <tt>Close()</tt>, но возвращает <tt>false</tt> вместо того,
чтобы бросать исключения.</p><div><u>Предусловие</u>: <tt>IsOpen() == true</tt></div><div><u>Постусловие</u>: <tt>IsOpen() == false</tt></div></blockquote></div><h2 id="windows.handle.h"><span class="h2_num">2.48</span><tt>__vic/windows/handle.h</tt></h2><h3 id="windows--Handle"><span class="h3_num">2.48.1</span><tt>windows::Handle</tt></h3><pre class="code">
class windows::Handle
{
public:
    Handle() = default; // uninitialized
    constexpr Handle(HANDLE h);

    void Close();
    bool CloseNT() noexcept;
    static void Close(HANDLE h);

    bool Wait(DWORD timeout = INFINITE) const;

    bool IsInvalid() const;
    void SetInvalid();
    operator HANDLE() const;

    void swap(Handle &#38;o) noexcept;
};
</pre><p>C++ обёртка для Win32 API <tt>HANDLE</tt>.</p><div class="section">Члены класса</div><div><pre class="prototype">Handle() = default</pre><blockquote><p>Создаёт неинициализированное значение.</p></blockquote></div><div><pre class="prototype">constexpr Handle(HANDLE h)</pre><blockquote><p>Неявный преобразователь из <tt>HANDLE</tt>.</p><div><u>Постусловие</u>: <tt>*this == h</tt></div></blockquote></div><div><pre class="prototype">operator HANDLE() const</pre><blockquote><p>Неявный преобразователь в <tt>HANDLE</tt>.</p></blockquote></div><div><pre class="prototype">bool IsInvalid() const</pre><blockquote><p>Возвращает <tt>true</tt> если хранит значение <tt>INVALID_HANDLE_VALUE</tt>.
</p></blockquote></div><div><pre class="prototype">void SetInvalid()</pre><blockquote><p>Присваивает значение <tt>INVALID_HANDLE_VALUE</tt>.</p><div><u>Постусловие</u>: <tt>IsInvalid() == true</tt></div></blockquote></div><div><pre class="prototype">void Close()</pre><pre class="prototype">static void Close(HANDLE h)</pre><blockquote><p>Вызывает <tt>::CloseHandle()</tt>. Бросает исключения при ошибках.</p><div><u>Предусловие</u>: То же, что и для <tt>::CloseHandle()</tt>.</div></blockquote></div><div><pre class="prototype">bool CloseNT() noexcept</pre><blockquote><p>Вызывает <tt>::CloseHandle()</tt> и возвращает <tt>true</tt> в случае
успеха. В случае ошибки <tt>::GetLastError()</tt> может быть использована
для получения описания ошибки.</p><div><u>Предусловие</u>: То же, что и для <tt>::CloseHandle()</tt>.</div></blockquote></div><div><pre class="prototype">bool Wait(DWORD timeout = INFINITE) const</pre><blockquote><p>Вызывает <tt>::WaitForSingleObject()</tt> с указанным таймаутом. Возвращает
<tt>false</tt> в случае <tt>WAIT_TIMEOUT</tt>. Бросает исключения при ошибках.
<a href="#windows--WaitAbandoned"><tt>windows::WaitAbandoned</tt></a> бросается в случае <tt>WAIT_ABANDONED</tt>.
</p></blockquote></div><div><pre class="prototype">void swap(Handle &#38;o) noexcept</pre><blockquote><p>Обменивается значением с <tt>o</tt>.</p></blockquote></div><h3 id="windows--WaitAbandoned"><span class="h3_num">2.48.2</span><tt>windows::WaitAbandoned</tt></h3><pre class="code">
struct windows::WaitAbandoned : public std::exception
{
    const char *what() const noexcept;
};
</pre><p>Исключение, бросаемое <tt>__vic::windows::Handle::Wait()</tt>.</p><h1 id="build"><span class="h1_num">3</span>Сборка и установка</h1><p>Для сборки библиотеки требуется один из поддерживаемых компиляторов C++ и
утилита <a href="https://www.gnu.org/software/make">GNU Make</a> версии
3.82 или выше доступные в Вашем окружении командной строки (cmd).</p><p>На текущий момент поддерживаются следующие компиляторы:</p><ul><li>GNU C++ v 4.7+ (MinGW) [<tt>gcc</tt>]</li><li>Clang v 5+ with MinGW [<tt>clang</tt>]</li><li>Clang v 5+ with Visual C++ [<tt>clang-cl</tt>]</li><li>Visual C++ v 15.8+ (Visual Studio 2017) [<tt>msvc</tt>]</li><li>Visual C++ v 7.1+ (Visual Studio 2003) [<tt>msvc</tt>] поддерживается,
          но может потребоваться ручное вмешательство в makefile'ы из-за
          неподдерживаемых опций компилятора</li></ul><p>Перейдите в подкаталог <tt>src</tt> и наберите:</p><pre class="code">
C:\&gt; gmake
</pre><p>Файл библиотеки будет собран.</p><p>По умолчанию используется C++14, но используя параметр <tt>std</tt> можно
задать версию явно. Например для сборки в режиме C++98 наберите:</p><pre class="code">
C:\&gt; gmake std=98
</pre><p>Доступные значения включают: 98, 11, 14 и 17.</p><p>Также можно вручную выбрать используемый компилятор:</p><pre class="code">
C:\&gt; gmake compiler=gcc
</pre><p>В качестве альтернативы для сборки с Visual C++ и clang-cl может
использоваться NMAKE вместо gmake:</p><pre class="code">
C:\&gt; nmake -f Makefile.nmake compiler=msvc
</pre><p>После всего этого нужно скопировать получившийся файл библиотеки и содержимое
подкаталога <tt>include</tt> туда, где компилятор/компоновщик смогут их найти.</p></div></body></html>